diff --git a/README.kde-qt b/README.kde-qt
new file mode 100644
index 0000000..db3feb6
--- /dev/null
+++ b/README.kde-qt
@@ -0,0 +1,201 @@
+This is a patched version of Qt.  It may include changes made by KDE
+and Qt developers that have either not been accepted for inclusion
+into Qt, or have been accepted for a later version of Qt than this
+one.
+
+1. Configuring Qt
+=================
+
+The recommended compile line is:
+
+--default-config-begin--
+
+  ./configure -qt-gif -debug -fast -no-separate-debug-info \
+     -system-libpng -system-libjpeg -system-zlib \
+     -dbus -webkit -plugin-sql-mysql \
+     -nomake examples -nomake demos -prefix <installdir>
+
+--default-config-end--
+
+It contains "-debug", which greatly improves the use for backtraces (but
+also needs a lot more disk space and makes things slower). To build in
+release mode, replace it with "-release".
+
+It also contains "-no-separate-debug-info", which disables separate .debug
+files. Instead, the debug information will be built into the libraries.
+This option is needed when you install Qt.
+
+If you don't install Qt, it can be useful to disable this option,
+thus having separate debug symbol files. With separate debug files, you can
+just move those debug files to another directory to remove Qt debug symbols.
+Moving the files back will enable Qt debug symbols again.
+This is useful if you rarely need to step into Qt functions during debugging,
+because GDB loads much faster and uses less memory without Qt debug symbols.
+In the rare case you need to step into Qt code, you can temporarily enable
+debug symbols again by moving the debug files back. You can even load the Qt
+debug symbols from within GDB on demand, using the "symbol-file" command.
+
+If you are planning to compile Qt using an Icecream cluster you have to
+pass the option -no-pch (no precompiled headers) to configure to make
+distributed compilation work.
+
+2. Compiling Qt
+===============
+
+To compile Qt on a Unix platform, run:
+
+   export MAKEFLAGS=-j2
+   make
+   make install
+
+If your computer has more than one core or processor, you may consider
+increasing the "2" above. If you've got a compile farm available, you
+should adjust the -j argument to match the number of slots in that
+farm.
+
+3. Modifying & rebuilding Qt
+============================
+
+If you make modifications to the Qt source code, you don't need to
+build everything again. Simply go to the directory containing the
+Makefile closest to the files you changed and run "make" again.
+
+For example, if you've modified src/corelib/io/qiodevice.cpp, do:
+
+   cd src/corelib
+   make
+
+If you make a change that is not temporary, you should create a Git
+commit out of it. However, you shouldn't push those changes to
+kde-qt.git. If you have a fix that benefit others, see the "Creating
+kde-qt.git modifications" section below.
+
+4. Building Qt examples and demos
+=================================
+
+The "-nomake examples -nomake demos" arguments to the configure script
+mean that those two sections will not be configured for building,
+which is unneeded for usage of the library.  If you want to compile
+the examples or demos later, just enter either directory and type:
+
+   qmake
+   make
+
+5. Build Qt tests
+=================
+
+(Official information: http://qt.gitorious.org/qt/pages/QtAutotestsEnvironment)
+
+In order to run Qt tests, you must have a "developer build" of Qt. For
+that, you need to reconfigure Qt and add the "-developer-build"
+option. That option is technically equivalent to the options:
+
+   -debug -prefix $PWD -DQT_BUILD_INTERNAL
+
+To run a test, go to its source dir in tests/auto/testname. Type
+"make" to build it, then run it (either ./tst_testname, or "make install").
+
+6. Building Qt documentation
+============================
+
+To build and install the documentation, run:
+
+   make docs
+   ./config.status
+   make install
+
+It is necessary to do this once only, even if you rebuild Qt later.
+
+7. Using Qt uninstalled
+=======================
+
+To use without having to install it, configure it as follows:
+
+   ./configure <other configure options>  -prefix $PWD
+   make sub-src
+   make sub-tools
+
+Attention: DO NOT run
+
+   make install
+
+If you do, Qt will overwrite your include/ directory with its
+installation.
+
+8. Creating kde-qt.git modifications
+====================================
+
+If you have fixed a bug in Qt or modified it in any way that may
+benefit others, please share your change in the form of a patch. Do
+not commit your changes directly to the main branch because they
+may be lost in a future update if they have not been added to the
+official Qt release.
+
+The exception to the above rule is that if the fix has been accepted
+by Qt Software (and so will appear in the very next release of Qt),
+then it should be simply cherry-picked from the Qt development
+branch. Note that you shouldn't do this for changes that have been
+accepted into a release which is not the very next.
+In this case, you should use the following command:
+
+   git cherry-pick -x SHA1_OF_THE_FIX
+where SHA1_OF_THE_FIX is the SHA-1 of the commit that you want to
+introduce. Then push the change to the server.
+
+Before creating a patch, it is recommended to contact Qt Software
+support via qt-bugs@trolltech.com and explain the situation. There may
+be a solution for the problem already or a new direction that should
+be accounted for.
+
+To create a patch, do the following:
+  a) look at the listing of branches in
+  http://qt.gitorious.org/+kde-developers/qt/kde-qt/commits/HEAD and
+  select the next number.
+
+  b) create a new branch out of a clean, released version of Qt, (for
+  example, 4.5.1), using the number above and a brief description of
+  your fix. For example:
+      git checkout -b patches/0180-window-role v4.5.1
+  You can see the available released versions of Qt with:
+      git tag
+
+  c) make your changes to the Qt source code and verify that it
+  compiles, links and works (please run the respective unit tests).
+
+  c) commit your changes to Git, using the "git commit" command. Please
+  see http://qt.gitorious.org/qt/pages/GitIntroductionWithQt and
+  http://qt.gitorious.org/qt/pages/QtCodingStyle for information on
+  how to create commits
+  Note that you can create multiple commits.
+
+  e) merge the change to the main branch, for example, 4.5.1-patched:
+      git checkout 4.5.1-patched
+      git merge patches/0180-window-role
+
+  f) push the changes you made to your branch and to the main server:
+      git push git@gitorious.org:qt/kde-qt.git 4.5.1-patched patches/0180-window-role
+  (Don't forget to list both branch names)
+
+Don't forget to submit your patch to using the Qt Contribution Model,
+along with the long description of the issue found. See
+http://qt.gitorious.org/qt/pages/QtContributionGuidelines for
+information how. You can submit the branch you've just sent to the
+server.
+
+9. Troubleshooting: Re-configuring and re-compiling
+==================================================
+
+For those updating the source in a directory where Qt has already
+been compiled, you may need to run the following commands from the
+top directory of your Qt sources:
+
+	find . -name '*.moc' | xargs rm
+
+Sometimes ./configure will refuse to run.  You may need to:
+	rm .qmake.cache
+
+If you think you may have run "make install" on an install-less Qt
+(srcdir == $QTDIR), run:
+
+	rm -rf include
+	bin/syncqt
diff --git a/bin/syncqt b/bin/syncqt
index a14a82d..ac140eb 100755
--- a/bin/syncqt
+++ b/bin/syncqt
@@ -366,9 +366,13 @@ sub fixPaths {
         $match_dir = $tmp;
         $i = $slash;
     }
+    my $cnt_ofs = 0;
+    if($match_dir =~ /^[a-zA-Z]:$/) {
+      $cnt_ofs = 1;
+    }
     if($match_dir) {
         my $after = substr($dir, length($match_dir));
-        my $count = ($after =~ tr,/,,);
+        my $count = ($after =~ tr,/,,) - $cnt_ofs;
         my $dots = "";
         for(my $i = 0; $i < $count; $i++) {
             $dots .= "../";
diff --git a/config.tests/unix/3dnow/3dnow.pro b/config.tests/unix/3dnow/3dnow.pro
index 90a8a19..791c5a3 100644
--- a/config.tests/unix/3dnow/3dnow.pro
+++ b/config.tests/unix/3dnow/3dnow.pro
@@ -1,3 +1,2 @@
 SOURCES = 3dnow.cpp
-CONFIG -= x11 qt
-mac:CONFIG -= app_bundle
+CONFIG -= x11 qt app_bundle
diff --git a/config.tests/unix/clock-gettime/clock-gettime.pro b/config.tests/unix/clock-gettime/clock-gettime.pro
index c527535..50ba344 100644
--- a/config.tests/unix/clock-gettime/clock-gettime.pro
+++ b/config.tests/unix/clock-gettime/clock-gettime.pro
@@ -1,4 +1,3 @@
 SOURCES = clock-gettime.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 include(clock-gettime.pri)
diff --git a/config.tests/unix/clock-monotonic/clock-monotonic.pro b/config.tests/unix/clock-monotonic/clock-monotonic.pro
index 961e3a8..9e8c35f 100644
--- a/config.tests/unix/clock-monotonic/clock-monotonic.pro
+++ b/config.tests/unix/clock-monotonic/clock-monotonic.pro
@@ -1,4 +1,3 @@
 SOURCES = clock-monotonic.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 include(../clock-gettime/clock-gettime.pri)
diff --git a/config.tests/unix/cups/cups.pro b/config.tests/unix/cups/cups.pro
index d7b78c8..7d8447a 100644
--- a/config.tests/unix/cups/cups.pro
+++ b/config.tests/unix/cups/cups.pro
@@ -1,4 +1,3 @@
 SOURCES = cups.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lcups
diff --git a/config.tests/unix/db2/db2.pro b/config.tests/unix/db2/db2.pro
index 0fa39a8..8ee9365 100644
--- a/config.tests/unix/db2/db2.pro
+++ b/config.tests/unix/db2/db2.pro
@@ -1,4 +1,3 @@
 SOURCES = db2.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -ldb2
diff --git a/config.tests/unix/dbus/dbus.pro b/config.tests/unix/dbus/dbus.pro
index 1e4aea7..d307629 100644
--- a/config.tests/unix/dbus/dbus.pro
+++ b/config.tests/unix/dbus/dbus.pro
@@ -1,3 +1,2 @@
 SOURCES = dbus.cpp
-CONFIG -= qt
-mac:CONFIG -= app_bundle
+CONFIG -= qt app_bundle
diff --git a/config.tests/unix/doubleformat/doubleformattest.pro b/config.tests/unix/doubleformat/doubleformattest.pro
index 7e51dea..08284ee 100644
--- a/config.tests/unix/doubleformat/doubleformattest.pro
+++ b/config.tests/unix/doubleformat/doubleformattest.pro
@@ -1,3 +1,2 @@
 SOURCES = doubleformattest.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
diff --git a/config.tests/unix/endian/endiantest.pro b/config.tests/unix/endian/endiantest.pro
index 7b739eb..bab6273 100644
--- a/config.tests/unix/endian/endiantest.pro
+++ b/config.tests/unix/endian/endiantest.pro
@@ -1,3 +1,2 @@
 SOURCES = endiantest.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
diff --git a/config.tests/unix/floatmath/floatmath.pro b/config.tests/unix/floatmath/floatmath.pro
index 4c78563..7478b4d 100644
--- a/config.tests/unix/floatmath/floatmath.pro
+++ b/config.tests/unix/floatmath/floatmath.pro
@@ -1,3 +1,2 @@
 SOURCES = floatmath.cpp
-CONFIG -= x11 qt
-
+CONFIG -= x11 qt app_bundle
diff --git a/config.tests/unix/freetype/freetype.pro b/config.tests/unix/freetype/freetype.pro
index e84158e..afd7b6f 100644
--- a/config.tests/unix/freetype/freetype.pro
+++ b/config.tests/unix/freetype/freetype.pro
@@ -1,5 +1,5 @@
 SOURCES = freetype.cpp
 CONFIG += x11
-CONFIG -= qt
+CONFIG -= qt app_bundle
 LIBS += -lfreetype
 include(freetype.pri)
diff --git a/config.tests/unix/getaddrinfo/getaddrinfo.pro b/config.tests/unix/getaddrinfo/getaddrinfo.pro
index c9121db..af63815 100644
--- a/config.tests/unix/getaddrinfo/getaddrinfo.pro
+++ b/config.tests/unix/getaddrinfo/getaddrinfo.pro
@@ -1,4 +1,3 @@
 SOURCES = getaddrinfotest.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += $$QMAKE_LIBS_NETWORK
diff --git a/config.tests/unix/getifaddrs/getifaddrs.pro b/config.tests/unix/getifaddrs/getifaddrs.pro
index c3fead6..aa44091 100644
--- a/config.tests/unix/getifaddrs/getifaddrs.pro
+++ b/config.tests/unix/getifaddrs/getifaddrs.pro
@@ -1,5 +1,4 @@
 SOURCES = getifaddrs.cpp
-CONFIG -= qt
-mac:CONFIG -= app_bundle
+CONFIG -= qt app_bundle
 QT =
 LIBS += $$QMAKE_LIBS_NETWORK
diff --git a/config.tests/unix/glib/glib.pro b/config.tests/unix/glib/glib.pro
index 15d059d..c7cd53d 100644
--- a/config.tests/unix/glib/glib.pro
+++ b/config.tests/unix/glib/glib.pro
@@ -1,2 +1,2 @@
 SOURCES = glib.cpp
-CONFIG -= qt
+CONFIG -= qt app_bundle
diff --git a/config.tests/unix/gnu-libiconv/gnu-libiconv.pro b/config.tests/unix/gnu-libiconv/gnu-libiconv.pro
index d879b20..02ad928 100644
--- a/config.tests/unix/gnu-libiconv/gnu-libiconv.pro
+++ b/config.tests/unix/gnu-libiconv/gnu-libiconv.pro
@@ -1,4 +1,3 @@
 SOURCES = gnu-libiconv.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -liconv
diff --git a/config.tests/unix/gstreamer/gstreamer.pro b/config.tests/unix/gstreamer/gstreamer.pro
index 7d4aa8e..29fc886 100644
--- a/config.tests/unix/gstreamer/gstreamer.pro
+++ b/config.tests/unix/gstreamer/gstreamer.pro
@@ -1,3 +1,3 @@
 SOURCES = gstreamer.cpp
-CONFIG -= qt
+CONFIG -= qt app_bundle
 LIBS += -lgstinterfaces-0.10 -lgstvideo-0.10 -lgstbase-0.10
diff --git a/config.tests/unix/ibase/ibase.pro b/config.tests/unix/ibase/ibase.pro
index 01e7429..f54130f 100644
--- a/config.tests/unix/ibase/ibase.pro
+++ b/config.tests/unix/ibase/ibase.pro
@@ -1,4 +1,3 @@
 SOURCES = ibase.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lgds
diff --git a/config.tests/unix/iconv/iconv.pro b/config.tests/unix/iconv/iconv.pro
index 8cdc776..336069b 100644
--- a/config.tests/unix/iconv/iconv.pro
+++ b/config.tests/unix/iconv/iconv.pro
@@ -1,3 +1,4 @@
 SOURCES = iconv.cpp
 CONFIG -= qt dylib app_bundle
 mac:LIBS += -liconv
+darwin-*:LIBS += -liconv
diff --git a/config.tests/unix/inotify/inotify.pro b/config.tests/unix/inotify/inotify.pro
index e2e1560..eea124e 100644
--- a/config.tests/unix/inotify/inotify.pro
+++ b/config.tests/unix/inotify/inotify.pro
@@ -1,3 +1,2 @@
 SOURCES = inotifytest.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
diff --git a/config.tests/unix/ipv6/ipv6.pro b/config.tests/unix/ipv6/ipv6.pro
index c51e61b..e0090f9 100644
--- a/config.tests/unix/ipv6/ipv6.pro
+++ b/config.tests/unix/ipv6/ipv6.pro
@@ -1,3 +1,2 @@
 SOURCES = ipv6test.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
diff --git a/config.tests/unix/ipv6ifname/ipv6ifname.pro b/config.tests/unix/ipv6ifname/ipv6ifname.pro
index ed62869..c15966a 100644
--- a/config.tests/unix/ipv6ifname/ipv6ifname.pro
+++ b/config.tests/unix/ipv6ifname/ipv6ifname.pro
@@ -1,5 +1,4 @@
 SOURCES = ipv6ifname.cpp
-CONFIG -= qt
-mac:CONFIG -= app_bundle
+CONFIG -= qt app_bundle
 QT =
 LIBS += $$QMAKE_LIBS_NETWORK
diff --git a/config.tests/unix/largefile/largefile.pro b/config.tests/unix/largefile/largefile.pro
index d7affc6..a466935 100644
--- a/config.tests/unix/largefile/largefile.pro
+++ b/config.tests/unix/largefile/largefile.pro
@@ -1,3 +1,2 @@
 SOURCES=largefiletest.cpp
-CONFIG-=qt dylib
-mac:CONFIG -= app_bundle
+CONFIG-=qt dylib app_bundle
diff --git a/config.tests/unix/libjpeg/libjpeg.pro b/config.tests/unix/libjpeg/libjpeg.pro
index d06888c..ad91bb8 100644
--- a/config.tests/unix/libjpeg/libjpeg.pro
+++ b/config.tests/unix/libjpeg/libjpeg.pro
@@ -1,4 +1,3 @@
 SOURCES = libjpeg.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -ljpeg
diff --git a/config.tests/unix/libmng/libmng.pro b/config.tests/unix/libmng/libmng.pro
index ee57ecd..147e916 100644
--- a/config.tests/unix/libmng/libmng.pro
+++ b/config.tests/unix/libmng/libmng.pro
@@ -1,4 +1,3 @@
 SOURCES = libmng.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lmng
diff --git a/config.tests/unix/libpng/libpng.pro b/config.tests/unix/libpng/libpng.pro
index f038386..74e53e0 100644
--- a/config.tests/unix/libpng/libpng.pro
+++ b/config.tests/unix/libpng/libpng.pro
@@ -1,4 +1,3 @@
 SOURCES = libpng.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lpng
diff --git a/config.tests/unix/libtiff/libtiff.pro b/config.tests/unix/libtiff/libtiff.pro
index 60ba7d1..122bb83 100644
--- a/config.tests/unix/libtiff/libtiff.pro
+++ b/config.tests/unix/libtiff/libtiff.pro
@@ -1,4 +1,3 @@
 SOURCES = libtiff.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -ltiff
diff --git a/config.tests/unix/mmx/mmx.pro b/config.tests/unix/mmx/mmx.pro
index d2fea7f..66352ae 100644
--- a/config.tests/unix/mmx/mmx.pro
+++ b/config.tests/unix/mmx/mmx.pro
@@ -1,3 +1,2 @@
 SOURCES = mmx.cpp
-CONFIG -= x11 qt
-mac:CONFIG -= app_bundle
+CONFIG -= x11 qt app_bundle
diff --git a/config.tests/unix/mremap/mremap.pro b/config.tests/unix/mremap/mremap.pro
index a36d756..7516e3b 100644
--- a/config.tests/unix/mremap/mremap.pro
+++ b/config.tests/unix/mremap/mremap.pro
@@ -1,3 +1,2 @@
 SOURCES = mremap.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
diff --git a/config.tests/unix/mysql/mysql.pro b/config.tests/unix/mysql/mysql.pro
index a22579e..ad7b9c9 100644
--- a/config.tests/unix/mysql/mysql.pro
+++ b/config.tests/unix/mysql/mysql.pro
@@ -1,4 +1,3 @@
 SOURCES = mysql.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lmysqlclient
diff --git a/config.tests/unix/mysql_r/mysql_r.pro b/config.tests/unix/mysql_r/mysql_r.pro
index 8c06067..1838533 100644
--- a/config.tests/unix/mysql_r/mysql_r.pro
+++ b/config.tests/unix/mysql_r/mysql_r.pro
@@ -1,4 +1,3 @@
 SOURCES = ../mysql/mysql.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lmysqlclient_r
diff --git a/config.tests/unix/nis/nis.pro b/config.tests/unix/nis/nis.pro
index 1f985b2..5d4fd2a 100644
--- a/config.tests/unix/nis/nis.pro
+++ b/config.tests/unix/nis/nis.pro
@@ -1,5 +1,4 @@
 SOURCES = nis.cpp
-CONFIG -= qt dylib
-mac: CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 solaris-*:LIBS += -lnsl
 else:LIBS += $$QMAKE_LIBS_NIS
diff --git a/config.tests/unix/oci/oci.pro b/config.tests/unix/oci/oci.pro
index 4add225..eeccbea 100644
--- a/config.tests/unix/oci/oci.pro
+++ b/config.tests/unix/oci/oci.pro
@@ -1,4 +1,3 @@
 SOURCES = oci.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lclntsh
diff --git a/config.tests/unix/odbc/odbc.pro b/config.tests/unix/odbc/odbc.pro
index c588ede..f7a8766 100644
--- a/config.tests/unix/odbc/odbc.pro
+++ b/config.tests/unix/odbc/odbc.pro
@@ -1,4 +1,3 @@
 SOURCES = odbc.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lodbc
diff --git a/config.tests/unix/openssl/openssl.pro b/config.tests/unix/openssl/openssl.pro
index 6891e78..275af07 100644
--- a/config.tests/unix/openssl/openssl.pro
+++ b/config.tests/unix/openssl/openssl.pro
@@ -1,4 +1,3 @@
 SOURCES = openssl.cpp
-CONFIG -= x11 qt
-mac:CONFIG -= app_bundle
+CONFIG -= x11 qt app_bundle
 include(openssl.pri)
diff --git a/config.tests/unix/psql/psql.pro b/config.tests/unix/psql/psql.pro
index 64bb3d6..2227104 100644
--- a/config.tests/unix/psql/psql.pro
+++ b/config.tests/unix/psql/psql.pro
@@ -1,4 +1,3 @@
 SOURCES = psql.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lpq
diff --git a/config.tests/unix/ptrsize/ptrsizetest.pro b/config.tests/unix/ptrsize/ptrsizetest.pro
index 41aba86..e480bf4 100644
--- a/config.tests/unix/ptrsize/ptrsizetest.pro
+++ b/config.tests/unix/ptrsize/ptrsizetest.pro
@@ -1,3 +1,2 @@
 SOURCES = ptrsizetest.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
diff --git a/config.tests/unix/sqlite/sqlite.pro b/config.tests/unix/sqlite/sqlite.pro
index ba2cac1..62380f1 100644
--- a/config.tests/unix/sqlite/sqlite.pro
+++ b/config.tests/unix/sqlite/sqlite.pro
@@ -1,3 +1,2 @@
 SOURCES = sqlite.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
diff --git a/config.tests/unix/sqlite2/sqlite2.pro b/config.tests/unix/sqlite2/sqlite2.pro
index 14a64d5..e7bac94 100644
--- a/config.tests/unix/sqlite2/sqlite2.pro
+++ b/config.tests/unix/sqlite2/sqlite2.pro
@@ -1,4 +1,3 @@
 SOURCES = sqlite2.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lsqlite
diff --git a/config.tests/unix/sse/sse.pro b/config.tests/unix/sse/sse.pro
index 4cc34a7..7e09bc2 100644
--- a/config.tests/unix/sse/sse.pro
+++ b/config.tests/unix/sse/sse.pro
@@ -1,3 +1,2 @@
 SOURCES = sse.cpp
-CONFIG -= x11 qt
-mac:CONFIG -= app_bundle
+CONFIG -= x11 qt app_bundle
diff --git a/config.tests/unix/sse2/sse2.pro b/config.tests/unix/sse2/sse2.pro
index d4a21aa..8350c6b 100644
--- a/config.tests/unix/sse2/sse2.pro
+++ b/config.tests/unix/sse2/sse2.pro
@@ -1,3 +1,2 @@
 SOURCES = sse2.cpp
-CONFIG -= x11 qt
-mac:CONFIG -= app_bundle
+CONFIG -= x11 qt app_bundle
diff --git a/config.tests/unix/stl/stl.pro b/config.tests/unix/stl/stl.pro
index a2feab4..6b75323 100644
--- a/config.tests/unix/stl/stl.pro
+++ b/config.tests/unix/stl/stl.pro
@@ -1,3 +1,2 @@
 SOURCES = stltest.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
diff --git a/config.tests/unix/tds/tds.pro b/config.tests/unix/tds/tds.pro
index 5516a14..9e5ce70 100644
--- a/config.tests/unix/tds/tds.pro
+++ b/config.tests/unix/tds/tds.pro
@@ -1,4 +1,3 @@
 SOURCES = tds.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lsybdb
diff --git a/config.tests/unix/tslib/tslib.pro b/config.tests/unix/tslib/tslib.pro
index 1191120..825fe31 100644
--- a/config.tests/unix/tslib/tslib.pro
+++ b/config.tests/unix/tslib/tslib.pro
@@ -1,3 +1,3 @@
 SOURCES = tslib.cpp
-CONFIG -= qt 
+CONFIG -= qt app_bundle 
 LIBS += -lts
diff --git a/config.tests/unix/zlib/zlib.pro b/config.tests/unix/zlib/zlib.pro
index 67cc870..8460548 100644
--- a/config.tests/unix/zlib/zlib.pro
+++ b/config.tests/unix/zlib/zlib.pro
@@ -1,4 +1,3 @@
 SOURCES = zlib.cpp
-CONFIG -= qt dylib
-mac:CONFIG -= app_bundle
+CONFIG -= qt dylib app_bundle
 LIBS += -lz
diff --git a/config.tests/x11/opengl/opengl.pro b/config.tests/x11/opengl/opengl.pro
index 432bd8d..d2841f7 100644
--- a/config.tests/x11/opengl/opengl.pro
+++ b/config.tests/x11/opengl/opengl.pro
@@ -7,4 +7,4 @@ for(p, QMAKE_LIBDIR_OPENGL) {
 }
 
 CONFIG -= qt
-LIBS += -lGL -lGLU
+LIBS += -lGL -lGLU -Wl,-dylib_file,/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib
diff --git a/configure b/configure
index 146ba82..5c79204 100755
--- a/configure
+++ b/configure
@@ -165,6 +165,7 @@ UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 #-------------------------------------------------------------------------------
 
 PLATFORM_X11=no
+PLATFORM_DARWIN=no
 PLATFORM_MAC=no
 PLATFORM_QWS=no
 
@@ -222,7 +223,7 @@ fi
 #-------------------------------------------------------------------------------
 # check the license
 #-------------------------------------------------------------------------------
-COMMERCIAL_USER=ask
+COMMERCIAL_USER=no
 CFG_DEV=no
 CFG_NOKIA=no
 CFG_EMBEDDED=no
@@ -1012,6 +1013,11 @@ while [ "$#" -gt 0 ]; do
             VAL=`echo $1 | sed 's,-D,,'`
         fi
         ;;
+    -isystem)
+        VAR="add_isystempath"
+        shift
+        VAL="$1"
+        ;;
     -I?*|-I)
         VAR="add_ipath"
         if [ "$1" = "-I" ]; then
@@ -1264,6 +1270,7 @@ while [ "$#" -gt 0 ]; do
     x11)
         if [ "$PLATFORM_MAC" = "yes" ]; then
             PLATFORM_MAC=no
+            PLATFORM_DARWIN=yes
         elif [ "$PLATFORM_QWS" = "yes" ]; then
             PLATFORM_QWS=no
         fi
@@ -2020,6 +2027,9 @@ while [ "$#" -gt 0 ]; do
     add_ipath)
         I_FLAGS="$I_FLAGS -I\"${VAL}\""
         ;;
+    add_isystempath)
+        I_FLAGS="$I_FLAGS -isystem \"${VAL}\""
+        ;;
     add_lpath)
         L_FLAGS="$L_FLAGS -L\"${VAL}\""
         ;;
@@ -2912,7 +2922,7 @@ else
 fi
 
 QMAKE_CONF_COMPILER=`getQMakeConf "$XQMAKESPEC" | grep "^QMAKE_CXX[^_A-Z0-9]" | sed "s,.* *= *\(.*\)$,\1," | tail -1`
-TEST_COMPILER="$CC"
+TEST_COMPILER="$CXX"
 [ -z "$TEST_COMPILER" ] && TEST_COMPILER=$QMAKE_CONF_COMPILER
 
 # auto-detect precompiled header support
@@ -4382,6 +4392,9 @@ if true; then ###[ '!' -f "$outpath/bin/qmake" ];
 		EXTRA_LFLAGS="$EXTRA_LFLAGS \$(SDK_LFLAGS)"
             fi
         fi
+	if [ "$PLATFORM_X11" = "yes" ] && [ "$PLATFORM_DARWIN" = "yes" ]; then
+	    EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS -D__USE_WS_X11__"
+	fi
         [ "$CFG_EMBEDDED" != "no" ] && EXTRA_CFLAGS="$EXTRA_CFLAGS -DQWS"
         if [ '!' -z "$D_FLAGS" ]; then
             for DEF in $D_FLAGS; do
@@ -5359,7 +5372,7 @@ if [ "$PLATFORM_X11" = "yes" ]; then
 fi # X11
 
 
-if [ "$PLATFORM_MAC" = "yes" ]; then
+if [ "$PLATFORM_MAC" = "yes" ] || [ "$PLATFORM_DARWIN" = "yes" ]; then
     if [ "$CFG_PHONON" != "no" ]; then
         # Always enable Phonon (unless it was explicitly disabled)
         CFG_PHONON=yes
@@ -5502,7 +5515,7 @@ if [ "$CFG_LIBFREETYPE" = "auto" ]; then
 fi
 
 if [ "$CFG_ENDIAN" = "auto" ]; then
-    if [ "$PLATFORM_MAC" = "yes" ]; then
+    if [ "$PLATFORM_MAC" = "yes" ] || [ "$PLATFORM_DARWIN" = "yes" ]; then
 	true #leave as auto
     else
         "$unixtests/endian.test" "$XQMAKESPEC" $OPT_VERBOSE "$relpath" "$outpath"
@@ -5523,7 +5536,7 @@ if [ "$CFG_ENDIAN" = "auto" ]; then
 fi
 
 if [ "$CFG_HOST_ENDIAN" = "auto" ]; then
-    if [ "$PLATFORM_MAC" = "yes" ]; then
+    if [ "$PLATFORM_MAC" = "yes" ] || [ "$PLATFORM_DARWIN" = "yes" ]; then
 	true #leave as auto
     else
         "$unixtests/endian.test" "$QMAKESPEC" $OPT_VERBOSE "$relpath" "$outpath"
@@ -6167,7 +6180,7 @@ else
     QT_CONFIG="$QT_CONFIG freetype"
 fi
 
-if [ "x$PLATFORM_MAC" = "xyes" ]; then
+if [ "x$PLATFORM_MAC" = "xyes" ] || [ "x$PLATFORM_DARWIN" = "xyes" ]; then
     #On Mac we implicitly link against libz, so we
     #never use the 3rdparty stuff.
     [ "$CFG_ZLIB" = "yes" ] && CFG_ZLIB="system"
@@ -6247,7 +6260,7 @@ fi
 [ '!' -z "$L_FLAGS" ] && QMakeVar add QMAKE_LIBDIR_FLAGS "$L_FLAGS"
 [ '!' -z "$l_FLAGS" ] && QMakeVar add LIBS "$l_FLAGS"
 
-if [ "$PLATFORM_MAC" = "yes" ]; then
+if [ "$PLATFORM_MAC" = "yes" ] || [ "$PLATFORM_DARWIN" = "yes" ]; then
     if [ "$CFG_RPATH" = "yes" ]; then
        QMAKE_CONFIG="$QMAKE_CONFIG absolute_library_soname"
     fi
@@ -6852,7 +6865,7 @@ if [ "$CFG_FRAMEWORK" = "yes" ]; then
     echo "#define QT_MAC_FRAMEWORK_BUILD" >>"$outpath/src/corelib/global/qconfig.h.new"
 fi
 
-if [ "$PLATFORM_MAC" = "yes" ]; then
+if [ "$PLATFORM_MAC" = "yes" ] || [ "$PLATFORM_DARWIN" = "yes" ]; then
     cat >>"$outpath/src/corelib/global/qconfig.h.new" <<EOF
 #if defined(__LP64__)
 # define QT_POINTER_SIZE 8
diff --git a/configure-for-fink.sh b/configure-for-fink.sh
new file mode 100755
index 0000000..58e09ef
--- /dev/null
+++ b/configure-for-fink.sh
@@ -0,0 +1,57 @@
+#!/bin/sh -e
+
+MYDIR=`dirname $0`
+TOPDIR=`cd $MYDIR; pwd`
+
+FINKPREFIX="$1"; shift
+PKGNAME="$1"; shift
+
+if [ -z "$FINKPREFIX" ] || [ -z "$PKGNAME" ]; then
+	echo "usage: $0 <fink_prefix> <pkgname>"
+	exit 1
+fi
+
+QTDIR=`pwd`
+PATH="$QTDIR/bin:$FINKPREFIX/lib/freetype219/bin:$PATH"
+
+EXTRA_ARGS=""
+
+[ -z "$CC"  ] && CC=gcc-4.0
+[ -z "$CXX" ] && CXX=g++-4.0
+
+if [ "$PKGNAME" = "qt4-x11" ]; then
+	EXTRA_ARGS="-x11 -platform darwin-g++ -xplatform darwin-g++"
+else
+	EXTRA_ARGS="-platform macx-g++ -xplatform macx-g++"
+fi
+
+case `sw_vers -productVersion` in
+	10.[01234]*)
+		;;
+	*)
+		LDFLAGS="$LDFLAGS -Wl,-dead_strip_dylibs"
+		;;
+esac
+
+export FINKPREFIX QTDIR PATH LIBRESOLV CC CXX EXTRA_ARGS LDFLAGS
+
+echo "yes" | sh $TOPDIR/configure \
+	"-I$FINKPREFIX/lib/system-openssl/include" "-L$FINKPREFIX/lib/system-openssl/lib" \
+	"-I$FINKPREFIX/lib/freetype219/include" "-I$FINKPREFIX/lib/freetype219/include/freetype2" "-L$FINKPREFIX/lib/freetype219/lib" \
+	"-I$FINKPREFIX/lib/fontconfig2/include" "-I$FINKPREFIX/lib/fontconfig2/include" "-L$FINKPREFIX/lib/fontconfig2/lib" \
+	"-I$FINKPREFIX/include" -isystem /usr/X11R6/include "-L$FINKPREFIX/lib" "-L/usr/X11R6/lib" \
+	-prefix "$FINKPREFIX/lib/$PKGNAME" -docdir "$FINKPREFIX/share/doc/$PKGNAME" \
+	-no-fast -webkit -openssl-linked -reduce-exports \
+	-exceptions -qt-gif -system-freetype -phonon -phonon-backend \
+	-no-sql-ibase -no-sql-mysql -no-sql-odbc -no-sql-psql \
+	-plugin-sql-sqlite -dbus-linked $EXTRA_ARGS "$@"
+
+# don't link against older versions of self
+/usr/bin/find . -name Makefile -print0 | xargs -0 perl -pi -e "s,-L$FINKPREFIX/lib/$PKGNAME/lib,,g"
+
+# attempt to counterfix qmake's warped fileFixify logic that makes install break
+# when $FINKPREFIX is a symlink and something exists already at -libdir or -datadir etc
+pushd $FINKPREFIX;
+	FixifiedSW=`/bin/pwd`;
+popd
+/usr/bin/find . -name Makefile -print0 | xargs -0 perl -pi -e "s,\\$\\(INSTALL_ROOT\\)$FixifiedSW,\\$\\(INSTALL_ROOT\\)$FINKPREFIX,g"
diff --git a/mkspecs/common/mac.conf b/mkspecs/common/mac.conf
index 5d88ac4..ca58917 100644
--- a/mkspecs/common/mac.conf
+++ b/mkspecs/common/mac.conf
@@ -17,7 +17,7 @@ QMAKE_FIX_RPATH         = install_name_tool -id
 QMAKE_RPATH		=
 
 QMAKE_LIBS_DYNLOAD	=
-QMAKE_LIBS_OPENGL	= -framework OpenGL -framework AGL
+QMAKE_LIBS_OPENGL	= -framework OpenGL -framework AGL -Wl,-dylib_file,/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib
 QMAKE_LIBS_OPENGL_QT	= $$QMAKE_LIBS_OPENGL
 QMAKE_LIBS_THREAD	=
 
diff --git a/mkspecs/darwin-g++/qmake.conf b/mkspecs/darwin-g++/qmake.conf
index 72baa89..4b02ed0 100644
--- a/mkspecs/darwin-g++/qmake.conf
+++ b/mkspecs/darwin-g++/qmake.conf
@@ -6,7 +6,7 @@
 
 MAKEFILE_GENERATOR	= UNIX
 TEMPLATE		= app
-CONFIG			+= qt warn_on release link_prl native_precompiled_headers
+CONFIG			+= qt warn_on release lib_version_first link_prl native_precompiled_headers
 QT			+= core gui
 DEFINES                 += __USE_WS_X11__
 
@@ -69,12 +69,13 @@ QMAKE_LFLAGS_VERSION    = -current_version$${LITERAL_WHITESPACE}
 QMAKE_LFLAGS_COMPAT_VERSION = -compatibility_version$${LITERAL_WHITESPACE}
 
 QMAKE_RPATH		=
+QMAKE_FIX_RPATH		= install_name_tool -id 
 
 QMAKE_LIBS_DYNLOAD	=
 QMAKE_LIBS_X11		= -lXext -lX11 -lm
 QMAKE_LIBS_X11SM	= -lSM -lICE
-QMAKE_LIBS_OPENGL	= -lGLU -lGL
-QMAKE_LIBS_OPENGL_QT	= -lGL
+QMAKE_LIBS_OPENGL	= -lGLU -lGL -Wl,-dylib_file,/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib
+QMAKE_LIBS_OPENGL_QT	= -lGL -Wl,-dylib_file,/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib
 QMAKE_LIBS_THREAD	=
 
 QMAKE_MOC		= $$[QT_INSTALL_BINS]/moc
diff --git a/projects.pro b/projects.pro
index aa1eb71..8ae64c2 100644
--- a/projects.pro
+++ b/projects.pro
@@ -149,6 +149,9 @@ unix {
    DEFAULT_QMAKESPEC ~= s,^.*mkspecs/,,g
    mkspecs.commands += $(DEL_FILE) $(INSTALL_ROOT)$$mkspecs.path/default; $(SYMLINK) $$DEFAULT_QMAKESPEC $(INSTALL_ROOT)$$mkspecs.path/default
 }
+win32 {
+   mkspecs.files += $$QT_BUILD_TREE/mkspecs/default
+}
 INSTALLS += mkspecs
 
 false:macx { #mac install location
diff --git a/qmake/generators/mac/pbuilder_pbx.cpp b/qmake/generators/mac/pbuilder_pbx.cpp
index 488d8d0..1c21110 100644
--- a/qmake/generators/mac/pbuilder_pbx.cpp
+++ b/qmake/generators/mac/pbuilder_pbx.cpp
@@ -52,7 +52,7 @@
 #  include <sys/types.h>
 #  include <sys/stat.h>
 #endif
-#ifdef Q_OS_DARWIN
+#ifdef Q_OS_MAC
 #include <ApplicationServices/ApplicationServices.h>
 #include <private/qcore_mac_p.h>
 #endif
@@ -1689,7 +1689,7 @@ ProjectBuilderMakefileGenerator::pbuilderVersion() const
     } else {
         QString version, version_plist = project->first("QMAKE_PBUILDER_VERSION_PLIST");
         if(version_plist.isEmpty()) {
-#ifdef Q_OS_DARWIN
+#ifdef Q_OS_MAC
             ret = QLatin1String("34");
             QCFType<CFURLRef> cfurl;
             OSStatus err = LSFindApplicationForInfo(0, CFSTR("com.apple.Xcode"), 0, 0, &cfurl);
diff --git a/qmake/property.cpp b/qmake/property.cpp
index ea4842a..ac54854 100644
--- a/qmake/property.cpp
+++ b/qmake/property.cpp
@@ -81,29 +81,32 @@ QMakeProperty::keyBase(bool version) const
 QString
 QMakeProperty::value(QString v, bool just_check)
 {
+    QString ret;
     if(v == "QT_INSTALL_PREFIX")
-        return QLibraryInfo::location(QLibraryInfo::PrefixPath);
+        ret = QLibraryInfo::location(QLibraryInfo::PrefixPath);
     else if(v == "QT_INSTALL_DATA")
-        return QLibraryInfo::location(QLibraryInfo::DataPath);
+        ret = QLibraryInfo::location(QLibraryInfo::DataPath);
     else if(v == "QT_INSTALL_DOCS")
-        return QLibraryInfo::location(QLibraryInfo::DocumentationPath);
+        ret = QLibraryInfo::location(QLibraryInfo::DocumentationPath);
     else if(v == "QT_INSTALL_HEADERS")
-        return QLibraryInfo::location(QLibraryInfo::HeadersPath);
+        ret = QLibraryInfo::location(QLibraryInfo::HeadersPath);
     else if(v == "QT_INSTALL_LIBS")
-        return QLibraryInfo::location(QLibraryInfo::LibrariesPath);
+        ret = QLibraryInfo::location(QLibraryInfo::LibrariesPath);
     else if(v == "QT_INSTALL_BINS")
-        return QLibraryInfo::location(QLibraryInfo::BinariesPath);
+        ret = QLibraryInfo::location(QLibraryInfo::BinariesPath);
     else if(v == "QT_INSTALL_PLUGINS")
-        return QLibraryInfo::location(QLibraryInfo::PluginsPath);
+        ret = QLibraryInfo::location(QLibraryInfo::PluginsPath);
     else if(v == "QT_INSTALL_TRANSLATIONS")
-        return QLibraryInfo::location(QLibraryInfo::TranslationsPath);
+        ret = QLibraryInfo::location(QLibraryInfo::TranslationsPath);
     else if(v == "QT_INSTALL_CONFIGURATION")
-        return QLibraryInfo::location(QLibraryInfo::SettingsPath);
+        ret = QLibraryInfo::location(QLibraryInfo::SettingsPath);
     else if(v == "QT_INSTALL_EXAMPLES")
-        return QLibraryInfo::location(QLibraryInfo::ExamplesPath);
+        ret = QLibraryInfo::location(QLibraryInfo::ExamplesPath);
     else if(v == "QT_INSTALL_DEMOS")
-        return QLibraryInfo::location(QLibraryInfo::DemosPath);
-    else if(v == "QMAKE_MKSPECS")
+        ret = QLibraryInfo::location(QLibraryInfo::DemosPath);
+    if(!ret.isEmpty())
+        return QDir::toNativeSeparators(ret);
+    if(v == "QMAKE_MKSPECS")
         return qmake_mkspec_paths().join(Option::target_mode == Option::TARG_WIN_MODE ? ";" : ":");
     else if(v == "QMAKE_VERSION")
         return qmake_version();
@@ -116,7 +119,7 @@ QMakeProperty::value(QString v, bool just_check)
     int slash = v.lastIndexOf('/');
     QVariant var = settings->value(keyBase(slash == -1) + v);
     bool ok = var.isValid();
-    QString ret = var.toString();
+    ret = var.toString();
     if(!ok) {
         QString version = qmake_version();
         if(slash != -1) {
diff --git a/src/3rdparty/phonon/CMakeLists.txt b/src/3rdparty/phonon/CMakeLists.txt
index a25ec5d..c18c3e7 100644
--- a/src/3rdparty/phonon/CMakeLists.txt
+++ b/src/3rdparty/phonon/CMakeLists.txt
@@ -55,7 +55,7 @@ if (CMAKE_COMPILER_IS_GNUCXX)
    if (CMAKE_SYSTEM_NAME MATCHES Linux)
      set ( CMAKE_C_FLAGS     "${CMAKE_C_FLAGS} -Wno-long-long -std=iso9899:1990 -Wundef -Wcast-align -Werror-implicit-function-declaration -Wchar-subscripts -Wall -W -Wpointer-arith -Wwrite-strings -Wformat-security -Wmissing-format-attribute -fno-common")
      set ( CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wnon-virtual-dtor -Wno-long-long -ansi -Wundef -Wcast-align -Wchar-subscripts -Wall -W -Wpointer-arith -Wformat-security -fno-exceptions -fno-check-new -fno-common")
-     add_definitions (-D_BSD_SOURCE -DQT_NO_EXCEPTIONS)
+     add_definitions (-D_BSD_SOURCE)
    endif (CMAKE_SYSTEM_NAME MATCHES Linux)
 
    # gcc under Windows
@@ -115,7 +115,7 @@ if (CMAKE_COMPILER_IS_GNUCXX)
       string(REGEX MATCH "(--enable-libstdcxx-allocator=mt)" _GCC_COMPILED_WITH_BAD_ALLOCATOR "${_gcc_alloc_info}")
    endif (GCC_IS_NEWER_THAN_4_1)
 
-   if (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR AND NOT WIN32)
+   if (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR)
       set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fvisibility=hidden")
       set (KDE4_C_FLAGS "-fvisibility=hidden")
       # check that Qt defines Q_DECL_EXPORT as __attribute__ ((visibility("default")))
@@ -137,9 +137,9 @@ if (CMAKE_COMPILER_IS_GNUCXX)
       if (GCC_IS_NEWER_THAN_4_2)
           set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fvisibility-inlines-hidden")
       endif (GCC_IS_NEWER_THAN_4_2)
-   else (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR AND NOT WIN32)
+   else (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR)
       set (__KDE_HAVE_GCC_VISIBILITY 0)
-   endif (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR AND NOT WIN32)
+   endif (__KDE_HAVE_GCC_VISIBILITY AND GCC_IS_NEWER_THAN_4_1 AND NOT _GCC_COMPILED_WITH_BAD_ALLOCATOR)
 
 endif (CMAKE_COMPILER_IS_GNUCXX)
 
@@ -149,8 +149,8 @@ set(CMAKE_COLOR_MAKEFILE ON)
 
 set(PHONON_LIB_MAJOR_VERSION "4")
 set(PHONON_LIB_MINOR_VERSION "3")
-set(PHONON_LIB_PATCH_VERSION "50")
-set(PHONON_LIB_VERSION "${PHONON_LIB_MAJOR_VERSION}.4.0")
+set(PHONON_LIB_PATCH_VERSION "1")
+set(PHONON_LIB_VERSION "${PHONON_LIB_MAJOR_VERSION}.3.1")
 set(PHONON_LIB_SOVERSION ${PHONON_LIB_MAJOR_VERSION})
 
 add_definitions(${QT_DEFINITIONS})
@@ -177,15 +177,11 @@ endmacro(_SET_FANCY)
 
 set(LIB_SUFFIX "" CACHE STRING "Define suffix of directory name (32/64)" )
 
-if (WIN32)
-    _set_fancy(EXEC_INSTALL_PREFIX         "."                                     "Base directory for executables and libraries")
-else(WIN32)
-    _set_fancy(EXEC_INSTALL_PREFIX         "${CMAKE_INSTALL_PREFIX}"              "Base directory for executables and libraries")
-endif(WIN32)
-_set_fancy(SHARE_INSTALL_PREFIX        "${EXEC_INSTALL_PREFIX}/share"             "Base directory for files which go to share/")
-_set_fancy(INCLUDE_INSTALL_DIR         "${EXEC_INSTALL_PREFIX}/include"           "The subdirectory to the header prefix")
+_set_fancy(EXEC_INSTALL_PREFIX         "${CMAKE_INSTALL_PREFIX}"                   "Base directory for executables and libraries")
+_set_fancy(SHARE_INSTALL_PREFIX        "${CMAKE_INSTALL_PREFIX}/share"             "Base directory for files which go to share/")
 _set_fancy(BIN_INSTALL_DIR             "${EXEC_INSTALL_PREFIX}/bin"                "The install dir for executables (default ${EXEC_INSTALL_PREFIX}/bin)")
 _set_fancy(LIB_INSTALL_DIR             "${EXEC_INSTALL_PREFIX}/lib${LIB_SUFFIX}"   "The subdirectory relative to the install prefix where libraries will be installed (default is ${EXEC_INSTALL_PREFIX}/lib${LIB_SUFFIX})")
+_set_fancy(INCLUDE_INSTALL_DIR         "${CMAKE_INSTALL_PREFIX}/include"           "The subdirectory to the header prefix")
 _set_fancy(PLUGIN_INSTALL_DIR          "${LIB_INSTALL_DIR}/kde4"                   "The subdirectory relative to the install prefix where plugins will be installed (default is ${LIB_INSTALL_DIR}/kde4)")
 _set_fancy(ICON_INSTALL_DIR            "${SHARE_INSTALL_PREFIX}/icons"             "The icon install dir (default ${SHARE_INSTALL_PREFIX}/share/icons/)")
 _set_fancy(SERVICES_INSTALL_DIR        "${SHARE_INSTALL_PREFIX}/kde4/services"     "The install dir for service (desktop, protocol, ...) files")
@@ -200,8 +196,6 @@ set(INSTALL_TARGETS_DEFAULT_ARGS  RUNTIME DESTINATION "${BIN_INSTALL_DIR}"
 if(APPLE)
    set(INSTALL_TARGETS_DEFAULT_ARGS  ${INSTALL_TARGETS_DEFAULT_ARGS}
                                      BUNDLE DESTINATION "${BUNDLE_INSTALL_DIR}" )
-	set(CMAKE_SHARED_MODULE_CREATE_C_FLAGS   "${CMAKE_SHARED_MODULE_CREATE_C_FLAGS}   -flat_namespace -undefined dynamic_lookup")
-	set(CMAKE_SHARED_MODULE_CREATE_CXX_FLAGS "${CMAKE_SHARED_MODULE_CREATE_CXX_FLAGS} -flat_namespace -undefined dynamic_lookup")
 endif(APPLE)
 
 if (CMAKE_SYSTEM_NAME MATCHES Linux)
@@ -255,6 +249,7 @@ if(APPLE)
 endif(APPLE)
 
 
+add_subdirectory(cmake)
 add_subdirectory(phonon)
 add_subdirectory(includes)
 if (Q_WS_MAC AND BUILD_PHONON_QT7)
diff --git a/src/3rdparty/phonon/ds9/CMakeLists.txt b/src/3rdparty/phonon/ds9/CMakeLists.txt
index 7378b53..1bb6f6f 100644
--- a/src/3rdparty/phonon/ds9/CMakeLists.txt
+++ b/src/3rdparty/phonon/ds9/CMakeLists.txt
@@ -40,15 +40,14 @@ if (BUILD_PHONON_DS9)
 	)
 
     add_definitions(-DPHONON_MAKE_QT_ONLY_BACKEND -DUNICODE)
-    automoc4_add_library(phonon_ds9 MODULE ${phonon_ds9_SRCS})
+    automoc4_add_library(phonon_ds9 SHARED ${phonon_ds9_SRCS})
     set_target_properties(phonon_ds9 PROPERTIES PREFIX "")
     target_link_libraries(phonon_ds9
                 ${PHONON_LIBS}  ${QT_QTOPENGL_LIBRARY} ${OPENGL_gl_LIBRARY}
                 dxguid strmiids dmoguids msdmo ole32 oleaut32 uuid gdi32)
-    # 'MODULE' is treated as a LIBRARY
     install(TARGETS phonon_ds9
 	    RUNTIME DESTINATION ${BIN_INSTALL_DIR}/phonon_backend
-	    LIBRARY DESTINATION ${BIN_INSTALL_DIR}/phonon_backend
+	    LIBRARY DESTINATION ${LIB_INSTALL_DIR}
 	    ARCHIVE DESTINATION ${LIB_INSTALL_DIR})
     install(FILES ds9.desktop DESTINATION ${SERVICES_INSTALL_DIR}/phononbackends)
 endif (BUILD_PHONON_DS9)
diff --git a/src/3rdparty/phonon/ds9/ds9.desktop b/src/3rdparty/phonon/ds9/ds9.desktop
index 764390e..ece3c9c 100644
--- a/src/3rdparty/phonon/ds9/ds9.desktop
+++ b/src/3rdparty/phonon/ds9/ds9.desktop
@@ -9,69 +9,28 @@ X-KDE-PhononBackendInfo-Website=http://qt.nokia.com/
 InitialPreference=15
 
 Name=DirectShow9
-Name[bg]=DirectShow9
-Name[ca]=DirectShow9
-Name[cs]=DirectShow9
-Name[da]=DirectShow9
-Name[de]=DirectShow9
-Name[el]=DirectShow9
-Name[en_GB]=DirectShow9
-Name[es]=DirectShow9
-Name[et]=DirectShow9
-Name[eu]=DirectShow9
-Name[fr]=DirectShow9
-Name[ga]=DirectShow9
-Name[gl]=DirectShow9
-Name[hsb]=DirectShow9
-Name[hu]=DirectShow9
-Name[is]=DirectShow9
-Name[it]=DirectShow9
-Name[ja]=DirectShow9
-Name[ko]=DirectShow9
-Name[ku]=DirectShow9
-Name[lt]=DirectShow9
-Name[lv]=DirectShow9
-Name[nds]=DirectShow9
-Name[nl]=DirectShow9
-Name[nn]=DirectShow9
 Name[pa]=ਡਾਇਰੈਕਸ਼ੋ9
-Name[pl]=DirectShow9
-Name[pt]=DirectShow9
-Name[pt_BR]=DirectShow9
-Name[se]=DirectShow9
 Name[sk]=DirectShow 9
 Name[sl]=DirectShow 9
 Name[sr]=Директшоу‑9
 Name[sr@latin]=DirectShow‑9
 Name[sv]=Directshow 9
-Name[tr]=DirectShow9
-Name[uk]=DirectShow9
 Name[x-test]=xxDirectShow9xx
-Name[zh_CN]=DirectShow9
-Name[zh_TW]=DirectShow9
 
 Comment=Phonon DirectShow9 backend
 Comment[bg]=Phonon DirectShow9
 Comment[ca]=Dorsal DirectShow9 del Phonon
-Comment[cs]=Phonon DirectShow9 backend
 Comment[da]=DirectShow9-backend til Phonon
 Comment[de]=Phonon-Treiber für DirectShow9
 Comment[el]=Σύστημα υποστήριξης DirectShow9 του Phonon
-Comment[en_GB]=Phonon DirectShow9 backend
 Comment[es]=Motor DirectShow9 para Phonon
 Comment[et]=Phononi DirectShow9 taustaprogramm
-Comment[eu]=Phonon DirectShow9 backend
 Comment[fr]=Système de gestion DirectShow9 pour Phonon 
 Comment[ga]=Inneall DirectShow9 le haghaidh Phonon
 Comment[gl]=Infraestrutura de DirectShow9 para Phonon
-Comment[hsb]=Phonon DirectShow9 backend
-Comment[hu]=Phonon DirectShow9 modul
-Comment[is]=Phonon DirectShow9 bakendi
 Comment[it]=Motore DirectShow9 di Phonon
 Comment[ja]=Phonon DirectShow9 バックエンド
 Comment[ko]=Phonon DirectShow9 백엔드
-Comment[ku]=Binesaza Phonon DirectShow9
-Comment[lt]=Phonon DirectShow9 galinė sąsaja
 Comment[lv]=Phonon DirectShow9 aizmugure
 Comment[nds]=Phonon-Hülpprogrmm DirectShow9
 Comment[nl]=DirectShow9-backend (Phonon)
@@ -80,7 +39,6 @@ Comment[pa]=ਫੋਨੋਨ ਡਾਇਰੈਕਟਸ਼ੋ9 ਬੈਕਐਂਡ
 Comment[pl]=Obsługa DirectShow9 przez Phonon
 Comment[pt]=Infra-estrutura do DirectShow9 para o Phonon
 Comment[pt_BR]=Infraestrutura Phonon DirectShow9
-Comment[se]=Phonon DirectShow9 duogášmohtor
 Comment[sk]=Phonon DirectShow 9 podsystém
 Comment[sl]=Phononova Hrbtenica DirectShow 9
 Comment[sr]=Директшоу‑9 као позадина Фонона
diff --git a/src/3rdparty/phonon/gstreamer/CMakeLists.txt b/src/3rdparty/phonon/gstreamer/CMakeLists.txt
index 08f892a..d529fb6 100644
--- a/src/3rdparty/phonon/gstreamer/CMakeLists.txt
+++ b/src/3rdparty/phonon/gstreamer/CMakeLists.txt
@@ -1,4 +1,4 @@
-# Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+# Copyright (C) 2009 Nokia Corporation. All rights reserved.
 # Copyright (C) 2008 Matthias Kretz <kretz@kde.org>
 #
 # This library is free software: you can redistribute it and/or modify
@@ -19,7 +19,7 @@ include(ConfigureChecks.cmake)
 if (BUILD_PHONON_GSTREAMER)
    include_directories(
 	  ${CMAKE_CURRENT_BINARY_DIR}
-	  ${GSTREAMER_INCLUDE_DIR} 
+	  ${GSTREAMER_INCLUDE_DIR}
 	  ${GLIB2_INCLUDE_DIR}
       ${LIBXML2_INCLUDE_DIR}
 	  ${X11_X11_INCLUDE_PATH})
@@ -34,7 +34,6 @@ if (BUILD_PHONON_GSTREAMER)
 
    set(phonon_gstreamer_SRCS
       audiooutput.cpp
-      artssink.cpp
       backend.cpp
       devicemanager.cpp
       effectmanager.cpp
@@ -50,14 +49,20 @@ if (BUILD_PHONON_GSTREAMER)
       message.cpp
       audioeffect.cpp
       abstractrenderer.cpp
-      x11renderer.cpp
       widgetrenderer.cpp
       glrenderer.cpp
       volumefadereffect.cpp
+      audiodataoutput.cpp
       )
 
-   find_package(Alsa)
-   macro_ensure_version("0.10.22" ${GSTREAMER_VERSION} GSTREAMER_HAS_NONBLOCKING_ALSASINK)
+   if(NOT WIN32)
+      set(phonon_gstreamer_SRCS
+          ${phonon_gstreamer_SRCS}
+          artssink.cpp
+          x11renderer.cpp)
+      macro_optional_find_package(Alsa)
+      macro_ensure_version("0.10.22" ${GSTREAMER_VERSION} GSTREAMER_HAS_NONBLOCKING_ALSASINK)
+   endif(NOT WIN32)
    if(ALSA_FOUND AND NOT GSTREAMER_HAS_NONBLOCKING_ALSASINK)
       add_definitions(-DUSE_ALSASINK2)
       include_directories(${ALSA_INCLUDES})
@@ -78,6 +83,9 @@ if (BUILD_PHONON_GSTREAMER)
    if(ALSA_FOUND)
       target_link_libraries(phonon_gstreamer ${ASOUND_LIBRARY})
    endif(ALSA_FOUND)
+   if(USE_INSTALL_PLUGIN)
+       target_link_libraries(phonon_gstreamer ${GSTREAMER_PLUGIN_PBUTILS_LIBRARIES})
+   endif(USE_INSTALL_PLUGIN)
 
    install(TARGETS phonon_gstreamer DESTINATION ${PLUGIN_INSTALL_DIR}/plugins/phonon_backend)
    install(FILES gstreamer.desktop DESTINATION ${SERVICES_INSTALL_DIR}/phononbackends)
diff --git a/src/3rdparty/phonon/gstreamer/ConfigureChecks.cmake b/src/3rdparty/phonon/gstreamer/ConfigureChecks.cmake
index f2922e1..095a0e9 100644
--- a/src/3rdparty/phonon/gstreamer/ConfigureChecks.cmake
+++ b/src/3rdparty/phonon/gstreamer/ConfigureChecks.cmake
@@ -1,4 +1,4 @@
-# Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+# Copyright (C) 2009 Nokia Corporation. All rights reserved.
 #
 # This library is free software: you can redistribute it and/or modify
 # it under the terms of the GNU Lesser General Public License as published by
@@ -17,6 +17,7 @@ macro_log_feature(GSTREAMER_FOUND "GStreamer" "gstreamer 0.10 is required for th
 
 macro_optional_find_package(GStreamerPlugins)
 macro_log_feature(GSTREAMER_PLUGIN_VIDEO_LIBRARIES "GStreamer video plugin" "The gstreamer video plugin (part of gstreamer-plugins-base 0.10) is required for the multimedia gstreamer backend" "http://gstreamer.freedesktop.org/modules/" FALSE "0.10")
+macro_log_feature(GSTREAMER_PLUGIN_AUDIO_LIBRARIES "GStreamer audio plugin" "The gstreamer audio plugin (part of gstreamer-plugins-base 0.10) is required for the multimedia gstreamer backend" "http://gstreamer.freedesktop.org/modules/" FALSE "0.10")
 
 macro_optional_find_package(GLIB2)
 macro_log_feature(GLIB2_FOUND "GLib2" "GLib 2 is required to compile the gstreamer backend for Phonon" "http://www.gtk.org/download/" FALSE)
@@ -30,8 +31,8 @@ macro_log_feature(LIBXML2_FOUND "LibXml2" "LibXml2 is required to compile the gs
 macro_optional_find_package(OpenGL)
 macro_log_feature(OPENGL_FOUND "OpenGL" "OpenGL support is required to compile the gstreamer backend for Phonon" "" FALSE)
 
-if (GSTREAMER_FOUND AND GSTREAMER_PLUGIN_VIDEO_LIBRARIES AND GLIB2_FOUND AND GOBJECT_FOUND AND LIBXML2_FOUND AND OPENGL_FOUND)
+if (GSTREAMER_FOUND AND GSTREAMER_PLUGIN_VIDEO_LIBRARIES AND GSTREAMER_PLUGIN_AUDIO_LIBRARIES AND GLIB2_FOUND AND GOBJECT_FOUND AND LIBXML2_FOUND AND OPENGL_FOUND)
    set(BUILD_PHONON_GSTREAMER TRUE)
-else (GSTREAMER_FOUND AND GSTREAMER_PLUGIN_VIDEO_LIBRARIES AND GLIB2_FOUND AND GOBJECT_FOUND AND LIBXML2_FOUND AND OPENGL_FOUND)
+else (GSTREAMER_FOUND AND GSTREAMER_PLUGIN_VIDEO_LIBRARIES AND GSTREAMER_PLUGIN_AUDIO_LIBRARIES AND GLIB2_FOUND AND GOBJECT_FOUND AND LIBXML2_FOUND AND OPENGL_FOUND)
    set(BUILD_PHONON_GSTREAMER FALSE)
-endif (GSTREAMER_FOUND AND GSTREAMER_PLUGIN_VIDEO_LIBRARIES AND GLIB2_FOUND AND GOBJECT_FOUND AND LIBXML2_FOUND AND OPENGL_FOUND)
+endif (GSTREAMER_FOUND AND GSTREAMER_PLUGIN_VIDEO_LIBRARIES AND GSTREAMER_PLUGIN_AUDIO_LIBRARIES AND GLIB2_FOUND AND GOBJECT_FOUND AND LIBXML2_FOUND AND OPENGL_FOUND)
diff --git a/src/3rdparty/phonon/gstreamer/abstractrenderer.cpp b/src/3rdparty/phonon/gstreamer/abstractrenderer.cpp
index 5d88d10..924b611 100644
--- a/src/3rdparty/phonon/gstreamer/abstractrenderer.cpp
+++ b/src/3rdparty/phonon/gstreamer/abstractrenderer.cpp
@@ -17,7 +17,6 @@
 
 #include "abstractrenderer.h"
 
-#ifndef QT_NO_PHONON_VIDEO
 QT_BEGIN_NAMESPACE
 
 namespace Phonon
@@ -53,5 +52,5 @@ void AbstractRenderer::movieSizeChanged(const QSize &size)
 } //namespace Phonon::Gstreamer
 
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_VIDEO
+
 
diff --git a/src/3rdparty/phonon/gstreamer/abstractrenderer.h b/src/3rdparty/phonon/gstreamer/abstractrenderer.h
index 10a2822..140413d 100644
--- a/src/3rdparty/phonon/gstreamer/abstractrenderer.h
+++ b/src/3rdparty/phonon/gstreamer/abstractrenderer.h
@@ -23,7 +23,6 @@
 #include "medianode.h"
 #include <phonon/videowidget.h>
 
-#ifndef QT_NO_PHONON_VIDEO
 QT_BEGIN_NAMESPACE
 
 class QString;
@@ -59,5 +58,5 @@ protected:
 } //namespace Phonon::Gstreamer
 
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_VIDEO
+
 #endif // Phonon_GSTREAMER_ABSTRACTRENDERER_H
diff --git a/src/3rdparty/phonon/gstreamer/artssink.cpp b/src/3rdparty/phonon/gstreamer/artssink.cpp
index 441607d..ff56da9 100644
--- a/src/3rdparty/phonon/gstreamer/artssink.cpp
+++ b/src/3rdparty/phonon/gstreamer/artssink.cpp
@@ -233,7 +233,7 @@ static void arts_sink_init (ArtsSink * src, ArtsSinkClass * g_class)
     Q_UNUSED(g_class);
     GST_DEBUG_OBJECT (src, "initializing artssink");
     src->stream = 0;
-#ifndef QT_NO_LIBRARY
+
     p_arts_init =  (Ptr_arts_init)QLibrary::resolve(QLatin1String("artsc"), 0, "arts_init");
     p_arts_play_stream =  (Ptr_arts_play_stream)QLibrary::resolve(QLatin1String("artsc"), 0, "arts_play_stream");
     p_arts_close_stream =  (Ptr_arts_close_stream)QLibrary::resolve(QLatin1String("artsc"), 0, "arts_close_stream");
@@ -250,7 +250,6 @@ static void arts_sink_init (ArtsSink * src, ArtsSinkClass * g_class)
         }
     }
     sinkCount ++;
-#endif //QT_NO_LIBRARY
 }
 
 static void arts_sink_dispose (GObject * object)
diff --git a/src/3rdparty/phonon/gstreamer/audiodataoutput.cpp b/src/3rdparty/phonon/gstreamer/audiodataoutput.cpp
new file mode 100644
index 0000000..30dabdf
--- /dev/null
+++ b/src/3rdparty/phonon/gstreamer/audiodataoutput.cpp
@@ -0,0 +1,143 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006 Matthias Kretz <kretz@kde.org>
+    Copyright (C) 2009 Martin Sandsmark <sandsmark@samfundet.no>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "audiodataoutput.h"
+#include "gsthelper.h"
+#include "medianode.h"
+#include "mediaobject.h"
+#include <QtCore/QVector>
+#include <QtCore/QMap>
+#include <phonon/audiooutput.h>
+
+namespace Phonon
+{
+namespace Gstreamer
+{
+AudioDataOutput::AudioDataOutput(Backend *backend, QObject *parent)
+    : QObject(parent),
+    MediaNode(backend, AudioSink | AudioSource)
+{
+    static int count = 0;
+    m_name = "AudioDataOutput" + QString::number(count++);
+
+    m_queue = gst_element_factory_make ("identity", NULL);
+    gst_object_ref(m_queue);
+    m_isValid = true;
+}
+
+AudioDataOutput::~AudioDataOutput()
+{
+    gst_element_set_state(m_queue, GST_STATE_NULL);
+    gst_object_unref(m_queue);
+}
+
+int AudioDataOutput::dataSize() const
+{
+    return m_dataSize;
+}
+
+int AudioDataOutput::sampleRate() const
+{
+    return 44100;
+}
+
+void AudioDataOutput::setDataSize(int size)
+{
+    m_dataSize = size;
+}
+
+typedef QMap<Phonon::AudioDataOutput::Channel, QVector<float> > FloatMap;
+typedef QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > IntMap;
+
+inline void AudioDataOutput::convertAndEmit(const QVector<qint16> &leftBuffer, const QVector<qint16> &rightBuffer)
+{
+    //TODO: Floats
+    IntMap map;
+    map.insert(Phonon::AudioDataOutput::LeftChannel, leftBuffer);
+    map.insert(Phonon::AudioDataOutput::RightChannel, rightBuffer);
+    emit dataReady(map);
+}
+
+void AudioDataOutput::processBuffer(GstPad*, GstBuffer* buffer, gpointer gThat)
+{
+    // TODO emit endOfMedia
+    AudioDataOutput *that = reinterpret_cast<AudioDataOutput*>(gThat);
+
+    // determine the number of channels
+    GstStructure* structure = gst_caps_get_structure (GST_BUFFER_CAPS(buffer), 0);
+    gst_structure_get_int (structure, "channels", &that->m_channels);
+
+    if (that->m_channels > 2 || that->m_channels < 0) {
+        qWarning() << Q_FUNC_INFO << ": Number of channels not supported: " << that->m_channels;
+        return;
+    }
+
+    gint16 *data = reinterpret_cast<gint16*>(GST_BUFFER_DATA(buffer));
+    guint size = GST_BUFFER_SIZE(buffer) / sizeof(gint16);
+
+    that->m_pendingData.reserve(that->m_pendingData.size() + size);
+
+    for (uint i=0; i<size; i++) {
+        // 8 bit? interleaved? yay for lacking documentation!
+        that->m_pendingData.append(data[i]);
+    }
+
+    while (that->m_pendingData.size() > that->m_dataSize * that->m_channels) {
+        if (that->m_channels == 1) {
+            QVector<qint16> intBuffer(that->m_dataSize);
+            memcpy(intBuffer.data(), that->m_pendingData.constData(), that->m_dataSize * sizeof(qint16));
+
+            that->convertAndEmit(intBuffer, intBuffer);
+            int newSize = that->m_pendingData.size() - that->m_dataSize;
+            memmove(that->m_pendingData.data(), that->m_pendingData.constData() + that->m_dataSize, newSize * sizeof(qint16));
+            that->m_pendingData.resize(newSize);
+        } else {
+            QVector<qint16> left(that->m_dataSize), right(that->m_dataSize);
+            for (int i=0; i<that->m_dataSize; i++) {
+                left[i] = that->m_pendingData[i*2];
+                right[i] = that->m_pendingData[i*2+1];
+            }
+            that->m_pendingData.resize(that->m_pendingData.size() - that->m_dataSize*2);
+            that->convertAndEmit(left, right);
+        }
+    }
+}
+
+void AudioDataOutput::mediaNodeEvent(const MediaNodeEvent *event)
+{
+    if (event->type() == MediaNodeEvent::MediaObjectConnected && root()) {
+        g_object_set(G_OBJECT(audioElement()), "sync", true, (const char*)NULL);
+        GstPad *audiopad = gst_element_get_pad (audioElement(), "src");
+        gst_pad_add_buffer_probe (audiopad, G_CALLBACK(processBuffer), this);
+        gst_object_unref (audiopad);
+        return;
+    }
+
+    MediaNode::mediaNodeEvent(event);
+}
+
+}} //namespace Phonon::Gstreamer
+
+#include "moc_audiodataoutput.cpp"
+// vim: sw=4 ts=4
+
diff --git a/src/3rdparty/phonon/gstreamer/audiodataoutput.h b/src/3rdparty/phonon/gstreamer/audiodataoutput.h
new file mode 100644
index 0000000..5e30a1d
--- /dev/null
+++ b/src/3rdparty/phonon/gstreamer/audiodataoutput.h
@@ -0,0 +1,84 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006 Matthias Kretz <kretz@kde.org>
+    Copyright (C) 2009 Martin Sandsmark <sandsmark@samfundet.no>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef Phonon_GSTREAMER_AUDIODATAOUTPUT_H
+#define Phonon_GSTREAMER_AUDIODATAOUTPUT_H
+
+#include "abstractaudiooutput.h"
+#include "backend.h"
+#include "medianode.h"
+#include <phonon/audiodataoutput.h>
+#include <phonon/audiodataoutputinterface.h>
+
+namespace Phonon
+{
+namespace Gstreamer
+{
+    /**
+     * \author Martin Sandsmark <sandsmark@samfundet.no>
+     */
+    class AudioDataOutput : public QObject,
+                            public AudioDataOutputInterface,
+                            public MediaNode
+    {
+        Q_OBJECT
+        Q_INTERFACES(Phonon::AudioDataOutputInterface Phonon::Gstreamer::MediaNode)
+
+        public:
+            AudioDataOutput(Backend *, QObject *);
+            ~AudioDataOutput();
+
+        public Q_SLOTS:
+            int dataSize() const;
+            int sampleRate() const;
+            void setDataSize(int size);
+
+        public:
+            /// callback function for handling new audio data
+            static void processBuffer(GstPad*, GstBuffer*, gpointer);
+
+            Phonon::AudioDataOutput* frontendObject() const { return m_frontend; }
+            void setFrontendObject(Phonon::AudioDataOutput *frontend) { m_frontend = frontend; }
+
+            GstElement *audioElement() { return m_queue; }
+
+            void mediaNodeEvent(const MediaNodeEvent *event);
+
+
+        signals:
+            void dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > &data);
+            void dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<float> > &data);
+            void endOfMedia(int remainingSamples);
+
+        private:
+            void convertAndEmit(const QVector<qint16>&, const QVector<qint16>&);
+
+            GstElement *m_queue;
+            int m_dataSize;
+            QVector<qint16> m_pendingData;
+            Phonon::AudioDataOutput *m_frontend;
+            int m_channels;
+    };
+}} //namespace Phonon::Gstreamer
+
+// vim: sw=4 ts=4 tw=80
+#endif // Phonon_FAKE_AUDIODATAOUTPUT_H
diff --git a/src/3rdparty/phonon/gstreamer/audioeffect.cpp b/src/3rdparty/phonon/gstreamer/audioeffect.cpp
index d3d7a35..db72c8b 100644
--- a/src/3rdparty/phonon/gstreamer/audioeffect.cpp
+++ b/src/3rdparty/phonon/gstreamer/audioeffect.cpp
@@ -23,7 +23,7 @@
 #include "gsthelper.h"
 
 #include <gst/gst.h>
-#ifndef QT_NO_PHONON_EFFECT
+
 QT_BEGIN_NAMESPACE
 
 namespace Phonon
@@ -75,5 +75,4 @@ GstElement* AudioEffect::createEffectBin()
 } //namespace Phonon::Gstreamer
 
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_EFFECT
 #include "moc_audioeffect.cpp"
diff --git a/src/3rdparty/phonon/gstreamer/audioeffect.h b/src/3rdparty/phonon/gstreamer/audioeffect.h
index f49f8d2..3a985e5 100644
--- a/src/3rdparty/phonon/gstreamer/audioeffect.h
+++ b/src/3rdparty/phonon/gstreamer/audioeffect.h
@@ -29,8 +29,8 @@
 
 #include <gst/gst.h>
 
-#ifndef QT_NO_PHONON_EFFECT
 QT_BEGIN_NAMESPACE
+
 namespace Phonon
 {
 namespace Gstreamer
@@ -49,7 +49,7 @@ namespace Gstreamer
             QString m_effectName;
     };
 }} //namespace Phonon::Gstreamer
+
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_EFFECT
 
 #endif // Phonon_GSTREAMER_AUDIOEFFECT_H
diff --git a/src/3rdparty/phonon/gstreamer/audiooutput.cpp b/src/3rdparty/phonon/gstreamer/audiooutput.cpp
index 641ff6b..4cfc42c 100644
--- a/src/3rdparty/phonon/gstreamer/audiooutput.cpp
+++ b/src/3rdparty/phonon/gstreamer/audiooutput.cpp
@@ -125,6 +125,7 @@ void AudioOutput::setVolume(qreal newVolume)
 bool AudioOutput::setOutputDevice(int newDevice)
 {
     m_backend->logMessage(Q_FUNC_INFO + QString::number(newDevice), Backend::Info, this);
+
     if (newDevice == m_device)
         return true;
 
@@ -135,20 +136,11 @@ bool AudioOutput::setOutputDevice(int newDevice)
     }
 
     bool success = false;
-    const QList<AudioDevice> deviceList = m_backend->deviceManager()->audioOutputDevices();
-    int deviceIdx = -1;
-    for (int i=0; i<deviceList.size(); i++) {
-        if (deviceList.at(i).id == newDevice) {
-            deviceIdx = i;
-            break;
-        }
-    }
-
-    if (m_audioSink && deviceIdx >= 0) {
+    if (m_audioSink &&  newDevice >= 0) {
         // Save previous state
         GstState oldState = GST_STATE(m_audioSink);
         const QByteArray oldDeviceValue = GstHelper::property(m_audioSink, "device");
-        const QByteArray deviceId = deviceList.at(deviceIdx).gstId;
+        const QByteArray deviceId = m_backend->deviceManager()->gstId(newDevice);
         m_device = newDevice;
 
         // We test if the device can be opened by checking if it can go from NULL to READY state
diff --git a/src/3rdparty/phonon/gstreamer/backend.cpp b/src/3rdparty/phonon/gstreamer/backend.cpp
index dab6f35..86cf92f 100644
--- a/src/3rdparty/phonon/gstreamer/backend.cpp
+++ b/src/3rdparty/phonon/gstreamer/backend.cpp
@@ -18,6 +18,7 @@
 #include "common.h"
 #include "backend.h"
 #include "audiooutput.h"
+#include "audiodataoutput.h"
 #include "audioeffect.h"
 #include "mediaobject.h"
 #include "videowidget.h"
@@ -26,6 +27,7 @@
 #include "message.h"
 #include "volumefadereffect.h"
 #include <gst/interfaces/propertyprobe.h>
+#include <phonon/pulsesupport.h>
 
 #include <QtCore/QSet>
 #include <QtCore/QVariant>
@@ -49,26 +51,28 @@ Backend::Backend(QObject *parent, const QVariantList &)
         , m_debugLevel(Warning)
         , m_isValid(false)
 {
+    // Initialise PulseAudio support
+    PulseSupport *pulse = PulseSupport::getInstance();
+    connect(pulse, SIGNAL(objectDescriptionChanged(ObjectDescriptionType)), SIGNAL(objectDescriptionChanged(ObjectDescriptionType)));
+
     // In order to support reloading, we only set the app name once...
     static bool first = true;
     if (first) {
         first = false;
         g_set_application_name(qApp->applicationName().toUtf8());
     }
-
     GError *err = 0;
     bool wasInit = gst_init_check(0, 0, &err);  //init gstreamer: must be called before any gst-related functions
     if (err)
         g_error_free(err);
 
     qRegisterMetaType<Message>("Message");
-#ifndef QT_NO_PROPERTIES
+
     setProperty("identifier",     QLatin1String("phonon_gstreamer"));
     setProperty("backendName",    QLatin1String("Gstreamer"));
     setProperty("backendComment", QLatin1String("Gstreamer plugin for Phonon"));
     setProperty("backendVersion", QLatin1String("0.2"));
-    setProperty("backendWebsite", QLatin1String("http://qt.nokia.com/"));
-#endif //QT_NO_PROPERTIES
+    setProperty("backendWebsite", QLatin1String("http://qtsoftware.com/"));
 
     //check if we should enable debug output
     QString debugLevelString = qgetenv("PHONON_GST_DEBUG");
@@ -92,6 +96,9 @@ Backend::Backend(QObject *parent, const QVariantList &)
 
 Backend::~Backend() 
 {
+    delete m_effectManager;
+    delete m_deviceManager;
+    PulseSupport::shutdown();
 }
 
 gboolean Backend::busCall(GstBus *bus, GstMessage *msg, gpointer data)
@@ -119,20 +126,15 @@ QObject *Backend::createObject(BackendInterface::Class c, QObject *parent, const
     case MediaObjectClass:
         return new MediaObject(this, parent);
 
-    case AudioOutputClass: {
-            AudioOutput *ao = new AudioOutput(this, parent);
-            m_audioOutputs.append(ao);
-            return ao;
-        }
-#ifndef QT_NO_PHONON_EFFECT
+    case AudioOutputClass:
+        return new AudioOutput(this, parent);
+
     case EffectClass:
         return new AudioEffect(this, args[0].toInt(), parent);
-#endif //QT_NO_PHONON_EFFECT
+
     case AudioDataOutputClass:
-        logMessage("createObject() : AudioDataOutput not implemented");
-        break;
+        return new AudioDataOutput(this, parent);
 
-#ifndef QT_NO_PHONON_VIDEO
     case VideoDataOutputClass:
         logMessage("createObject() : VideoDataOutput not implemented");
         break;
@@ -141,11 +143,9 @@ QObject *Backend::createObject(BackendInterface::Class c, QObject *parent, const
             QWidget *widget =  qobject_cast<QWidget*>(parent);
             return new VideoWidget(this, widget);
         }
-#endif //QT_NO_PHONON_VIDEO
-#ifndef QT_NO_PHONON_VOLUMEFADEREFFECT
+
     case VolumeFaderEffectClass:
         return new VolumeFaderEffect(this, parent);
-#endif //QT_NO_PHONON_VOLUMEFADEREFFECT
 
     case VisualizationClass:  //Fall through
     default:
@@ -214,14 +214,14 @@ QStringList Backend::availableMimeTypes() const
         GstPluginFeature *feature = GST_PLUGIN_FEATURE(iter->data);
         QString klass = gst_element_factory_get_klass(GST_ELEMENT_FACTORY(feature));
 
-        if (klass == QLatin1String("Codec/Decoder") ||
-            klass == QLatin1String("Codec/Decoder/Audio") ||
-            klass == QLatin1String("Codec/Decoder/Video") ||
-            klass == QLatin1String("Codec/Demuxer") ||
-            klass == QLatin1String("Codec/Demuxer/Audio") ||
-            klass == QLatin1String("Codec/Demuxer/Video") ||
-            klass == QLatin1String("Codec/Parser") ||
-            klass == QLatin1String("Codec/Parser/Audio") ||
+        if (klass == QLatin1String("Codec/Decoder") || 
+            klass == QLatin1String("Codec/Decoder/Audio") || 
+            klass == QLatin1String("Codec/Decoder/Video") || 
+            klass == QLatin1String("Codec/Demuxer") || 
+            klass == QLatin1String("Codec/Demuxer/Audio") || 
+            klass == QLatin1String("Codec/Demuxer/Video") || 
+            klass == QLatin1String("Codec/Parser") || 
+            klass == QLatin1String("Codec/Parser/Audio") || 
             klass == QLatin1String("Codec/Parser/Video")) {
 
             const GList *static_templates;
@@ -258,6 +258,10 @@ QList<int> Backend::objectDescriptionIndexes(ObjectDescriptionType type) const
     if (!isValid())
         return list;
 
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive() && (Phonon::AudioOutputDeviceType == type || Phonon::AudioCaptureDeviceType == type))
+        return pulse->objectDescriptionIndexes(type);
+
     switch (type) {
     case Phonon::AudioOutputDeviceType: {
             QList<AudioDevice> deviceList = deviceManager()->audioOutputDevices();
@@ -291,16 +295,17 @@ QHash<QByteArray, QVariant> Backend::objectDescriptionProperties(ObjectDescripti
     if (!isValid())
         return ret;
 
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive() && (Phonon::AudioOutputDeviceType == type || Phonon::AudioCaptureDeviceType == type))
+        return pulse->objectDescriptionProperties(type, index);
+
     switch (type) {
     case Phonon::AudioOutputDeviceType: {
-            QList<AudioDevice> audioDevices = deviceManager()->audioOutputDevices();
-            foreach(const AudioDevice &device, audioDevices) {
-                if (device.id == index) {
-                    ret.insert("name", device.gstId);
-                    ret.insert("description", device.description);
-                    ret.insert("icon", QLatin1String("audio-card"));
-                    break;
-                }
+            AudioDevice* ad;
+            if ((ad = deviceManager()->audioDevice(index))) {
+                ret.insert("name", ad->gstId);
+                ret.insert("description", ad->description);
+                ret.insert("icon", ad->icon);
             }
         }
         break;
@@ -429,7 +434,7 @@ EffectManager* Backend::effectManager() const
 
 /**
  * Returns a debuglevel that is determined by the
- * PHONON_GSTREAMER_DEBUG environment variable.
+ * PHONON_GST_DEBUG environment variable.
  *
  *  Warning - important warnings
  *  Info    - general info
diff --git a/src/3rdparty/phonon/gstreamer/backend.h b/src/3rdparty/phonon/gstreamer/backend.h
index 2aab6fa..d157f11 100644
--- a/src/3rdparty/phonon/gstreamer/backend.h
+++ b/src/3rdparty/phonon/gstreamer/backend.h
@@ -86,7 +86,6 @@ private Q_SLOTS:
 
 private:
     static gboolean busCall(GstBus *bus, GstMessage *msg, gpointer data);
-    QList<QPointer<AudioOutput> > m_audioOutputs;
 
     DeviceManager *m_deviceManager;
     EffectManager *m_effectManager;
diff --git a/src/3rdparty/phonon/gstreamer/devicemanager.cpp b/src/3rdparty/phonon/gstreamer/devicemanager.cpp
index 60e860f..e62d281 100644
--- a/src/3rdparty/phonon/gstreamer/devicemanager.cpp
+++ b/src/3rdparty/phonon/gstreamer/devicemanager.cpp
@@ -24,6 +24,7 @@
 #include "widgetrenderer.h"
 #include "x11renderer.h"
 #include "artssink.h"
+#include "pulsesupport.h"
 
 #ifdef USE_ALSASINK2
 #include "alsasink2.h"
@@ -44,9 +45,12 @@ namespace Gstreamer
 AudioDevice::AudioDevice(DeviceManager *manager, const QByteArray &gstId)
         : gstId(gstId)
 {
-    //get an id
-    static int counter = 0;
-    id = counter++;
+    // This should never be called when PulseAudio is active.
+    Q_ASSERT(!PulseSupport::getInstance()->isActive());
+
+    id = manager->allocateDeviceId();
+    icon = "audio-card";
+
     //get name from device
     if (gstId == "default") {
         description = "Default audio device";
@@ -71,22 +75,25 @@ AudioDevice::AudioDevice(DeviceManager *manager, const QByteArray &gstId)
 DeviceManager::DeviceManager(Backend *backend)
         : QObject(backend)
         , m_backend(backend)
+        , m_audioDeviceCounter(0)
 {
-    m_audioSink = qgetenv("PHONON_GST_AUDIOSINK");
-    m_videoSinkWidget = qgetenv("PHONON_GST_VIDEOMODE");
-
-#ifndef QT_NO_SETTINGS
     QSettings settings(QLatin1String("Trolltech"));
     settings.beginGroup(QLatin1String("Qt"));
 
+    PulseSupport *pulse = PulseSupport::getInstance();
+    m_audioSink = qgetenv("PHONON_GST_AUDIOSINK");
     if (m_audioSink.isEmpty()) {
         m_audioSink = settings.value(QLatin1String("audiosink"), "Auto").toByteArray().toLower();
+        if (m_audioSink == "auto" && pulse->isActive())
+            m_audioSink = "pulsesink";
     }
+    if ("pulsesink" != m_audioSink)
+        pulse->disable();
 
+    m_videoSinkWidget = qgetenv("PHONON_GST_VIDEOMODE");
     if (m_videoSinkWidget.isEmpty()) {
         m_videoSinkWidget = settings.value(QLatin1String("videomode"), "Auto").toByteArray().toLower();
     }
-#endif //QT_NO_SETTINGS
 
     if (m_backend->isValid())
         updateDeviceList();
@@ -246,7 +253,6 @@ GstElement *DeviceManager::createAudioSink(Category category)
     return sink;
 }
 
-#ifndef QT_NO_PHONON_VIDEO
 AbstractRenderer *DeviceManager::createVideoRenderer(VideoWidget *parent)
 {
 #if !defined(QT_NO_OPENGL) && !defined(QT_OPENGL_ES)
@@ -269,11 +275,18 @@ AbstractRenderer *DeviceManager::createVideoRenderer(VideoWidget *parent)
 #endif
     return new WidgetRenderer(parent);
 }
-#endif //QT_NO_PHONON_VIDEO
 
-/*
- * Returns a positive device id or -1 if device
- * does not exist
+/**
+ * Allocate a device id for a new audio device
+ */
+int DeviceManager::allocateDeviceId()
+{
+    return m_audioDeviceCounter++;
+}
+
+
+/**
+ * Returns a positive device id or -1 if device does not exist
  *
  * The gstId is typically in the format hw:1,0
  */
@@ -288,16 +301,30 @@ int DeviceManager::deviceId(const QByteArray &gstId) const
 }
 
 /**
- * Get a human-readable description from a device id
+ * Returns a gstId or "default" if device does not exist
+ *
+ * The gstId is typically in the format hw:1,0
  */
-QByteArray DeviceManager::deviceDescription(int id) const
+const QByteArray DeviceManager::gstId(int deviceId)
+{
+    if (!PulseSupport::getInstance()->isActive()) {
+        AudioDevice *ad = audioDevice(deviceId);
+        if (ad)
+            return QByteArray(ad->gstId);
+    }
+    return QByteArray("default");
+}
+
+/**
+* Get the AudioDevice for a given device id
+*/
+AudioDevice* DeviceManager::audioDevice(int id)
 {
     for (int i = 0 ; i < m_audioDeviceList.size() ; ++i) {
-        if (m_audioDeviceList[i].id == id) {
-            return m_audioDeviceList[i].description;
-        }
+        if (m_audioDeviceList[i].id == id)
+            return &m_audioDeviceList[i];
     }
-    return QByteArray();
+    return NULL;
 }
 
 /**
@@ -311,8 +338,11 @@ void DeviceManager::updateDeviceList()
     QList<QByteArray> list;
 
     if (audioSink) {
-        list = GstHelper::extractProperties(audioSink, "device");
-        list.prepend("default");
+        if (!PulseSupport::getInstance()->isActive()) {
+            // If we're using pulse, the PulseSupport class takes care of things for us.
+            list = GstHelper::extractProperties(audioSink, "device");
+            list.prepend("default");
+        }
 
         for (int i = 0 ; i < list.size() ; ++i) {
             QByteArray gstId = list.at(i);
diff --git a/src/3rdparty/phonon/gstreamer/devicemanager.h b/src/3rdparty/phonon/gstreamer/devicemanager.h
index a5e8289..9c6aa8d 100644
--- a/src/3rdparty/phonon/gstreamer/devicemanager.h
+++ b/src/3rdparty/phonon/gstreamer/devicemanager.h
@@ -42,6 +42,7 @@ public :
     int id;
     QByteArray gstId;
     QByteArray description;
+    QString icon;
 };
 
 class DeviceManager : public QObject {
@@ -51,8 +52,10 @@ public:
     virtual ~DeviceManager();
     const QList<AudioDevice> audioOutputDevices() const;
     GstPad *requestPad(int device) const;
+    int allocateDeviceId();
     int deviceId(const QByteArray &gstId) const;
-    QByteArray deviceDescription(int id) const;
+    const QByteArray gstId(int id);
+    AudioDevice* audioDevice(int id);
     GstElement *createGNOMEAudioSink(Category category);
     GstElement *createAudioSink(Category category = NoCategory);
     AbstractRenderer *createVideoRenderer(VideoWidget *parent);
@@ -68,6 +71,7 @@ private:
     bool canOpenDevice(GstElement *element) const;
     Backend *m_backend;
     QList <AudioDevice> m_audioDeviceList;
+    int m_audioDeviceCounter;
     QTimer m_devicePollTimer;
     QByteArray m_audioSink;
     QByteArray m_videoSinkWidget;
diff --git a/src/3rdparty/phonon/gstreamer/effect.cpp b/src/3rdparty/phonon/gstreamer/effect.cpp
index 4937246..f653535 100644
--- a/src/3rdparty/phonon/gstreamer/effect.cpp
+++ b/src/3rdparty/phonon/gstreamer/effect.cpp
@@ -25,8 +25,8 @@
 
 #include <gst/gst.h>
 
-#ifndef QT_NO_PHONON_EFFECT
 QT_BEGIN_NAMESPACE
+
 namespace Phonon
 {
 namespace Gstreamer
@@ -241,6 +241,6 @@ void Effect::setParameterValue(const EffectParameter &p, const QVariant &v)
 
 }
 } //namespace Phonon::Gstreamer
+
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_EFFECT
 #include "moc_effect.cpp"
diff --git a/src/3rdparty/phonon/gstreamer/effect.h b/src/3rdparty/phonon/gstreamer/effect.h
index 51cbe9c..dbbb457 100644
--- a/src/3rdparty/phonon/gstreamer/effect.h
+++ b/src/3rdparty/phonon/gstreamer/effect.h
@@ -28,8 +28,8 @@
 
 #include <gst/gst.h>
 
-#ifndef QT_NO_PHONON_EFFECT
 QT_BEGIN_NAMESPACE
+
 namespace Phonon
 {
 namespace Gstreamer
@@ -58,7 +58,7 @@ namespace Gstreamer
             QList<Phonon::EffectParameter> m_parameterList;
     };
 }} //namespace Phonon::Gstreamer
+
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_EFFECT
 
 #endif // Phonon_GSTREAMER_EFFECT_H
diff --git a/src/3rdparty/phonon/gstreamer/gstreamer.desktop b/src/3rdparty/phonon/gstreamer/gstreamer.desktop
index b62472b..7fb4000 100644
--- a/src/3rdparty/phonon/gstreamer/gstreamer.desktop
+++ b/src/3rdparty/phonon/gstreamer/gstreamer.desktop
@@ -10,27 +10,69 @@ Icon=phonon-gstreamer
 InitialPreference=10
 
 Name=GStreamer
+Name[bg]=GStreamer
+Name[ca]=GStreamer
+Name[cs]=GStreamer
+Name[da]=GStreamer
+Name[de]=GStreamer
+Name[el]=GStreamer
+Name[en_GB]=GStreamer
+Name[es]=GStreamer
+Name[et]=GStreamer
+Name[eu]=GStreamer
+Name[fr]=GStreamer
+Name[ga]=GStreamer
+Name[gl]=GStreamer
+Name[hsb]=GStreamer
+Name[hu]=GStreamer
+Name[is]=GStreamer
+Name[it]=GStreamer
+Name[ja]=GStreamer
+Name[ko]=GStreamer
+Name[ku]=GStreamer
+Name[lt]=GStreamer
+Name[lv]=GStreamer
+Name[nds]=GStreamer
+Name[nl]=GStreamer
+Name[nn]=GStreamer
 Name[pa]=ਜੀਸਟੀਰਮਰ
+Name[pl]=GStreamer
+Name[pt]=GStreamer
+Name[pt_BR]=GStreamer
+Name[se]=GStreamer
+Name[sk]=GStreamer
+Name[sl]=GStreamer
 Name[sr]=Гстример
+Name[sr@latin]=GStreamer
 Name[sv]=Gstreamer
+Name[tr]=GStreamer
+Name[uk]=GStreamer
 Name[x-test]=xxGStreamerxx
+Name[zh_CN]=GStreamer
+Name[zh_TW]=GStreamer
 
 Comment=Phonon GStreamer backend
 Comment[bg]=Phonon GStreamer
 Comment[ca]=Dorsal GStreamer del Phonon
+Comment[cs]=Phonon GStreamer backend
 Comment[da]=GStreamer-backend til Phonon
 Comment[de]=Phonon-Treiber für GStreamer
 Comment[el]=Σύστημα υποστήριξης GStreamer του Phonon
+Comment[en_GB]=Phonon GStreamer backend
 Comment[es]=Motor GStreamer para Phonon
 Comment[et]=Phononi GStreameri taustaprogramm
+Comment[eu]=Phonon GStreamer backend
 Comment[fr]=Système de gestion GStreamer pour Phonon 
 Comment[ga]=Inneall GStreamer le haghaidh Phonon
 Comment[gl]=Infraestrutura de GStreamer para Phonon
+Comment[hsb]=Phonon GStreamer backend
+Comment[hu]=Phonon GStreamer modul
 Comment[is]=Phonon GStreamer bakendi
 Comment[it]=Motore Gstreamer di Phonon
 Comment[ja]=Phonon GStreamer バックエンド
 Comment[ko]=Phonon GStreamer 백엔드
 Comment[ku]=Binesaza Phonon GStreamer
+Comment[lt]=Phonon GStreamer galinė sąsaja
 Comment[lv]=Phonon GStreamer aizmugure
 Comment[nds]=Phonon-Hülpprogramm GStreamer
 Comment[nl]=GStreamer-backend (Phonon)
@@ -39,6 +81,7 @@ Comment[pa]=ਫੋਨੋਨ ਜਸਟੀਰਮਰ ਬੈਕਐਂਡ
 Comment[pl]=Obsługa GStreamera przez Phonon
 Comment[pt]=Infra-estrutura do GStreamer para o Phonon
 Comment[pt_BR]=Infraestrutura Phonon GStreamer
+Comment[se]=Phonon GStreamer duogášmohtor
 Comment[sk]=GStreamer podsystém
 Comment[sl]=Phononova hrbtenica GStreamer
 Comment[sr]=Гстример као позадина Фонона
diff --git a/src/3rdparty/phonon/gstreamer/mediaobject.cpp b/src/3rdparty/phonon/gstreamer/mediaobject.cpp
index eafaeec..10aa8fd 100644
--- a/src/3rdparty/phonon/gstreamer/mediaobject.cpp
+++ b/src/3rdparty/phonon/gstreamer/mediaobject.cpp
@@ -16,6 +16,7 @@
 */
 #include <cmath>
 #include <gst/interfaces/propertyprobe.h>
+#include <gst/pbutils/install-plugins.h>
 #include "common.h"
 #include "mediaobject.h"
 #include "videowidget.h"
@@ -53,6 +54,7 @@ MediaObject::MediaObject(Backend *backend, QObject *parent)
         , m_tickTimer(new QTimer(this))
         , m_prefinishMark(0)
         , m_transitionTime(0)
+        , m_isStream(false)
         , m_posAtSeek(-1)
         , m_prefinishMarkReachedNotEmitted(true)
         , m_aboutToFinishEmitted(false)
@@ -79,6 +81,7 @@ MediaObject::MediaObject(Backend *backend, QObject *parent)
         , m_autoplayTitles(true)
         , m_availableTitles(0)
         , m_currentTitle(1)
+        , m_pendingTitle(1)
 {
     qRegisterMetaType<GstCaps*>("GstCaps*");
     qRegisterMetaType<State>("State");
@@ -87,7 +90,7 @@ MediaObject::MediaObject(Backend *backend, QObject *parent)
     m_name = "MediaObject" + QString::number(count++);
 
     if (!m_backend->isValid()) {
-        setError(tr("Cannot start playback. \n\nCheck your GStreamer installation and make sure you "
+        setError(tr("Cannot start playback. \n\nCheck your Gstreamer installation and make sure you "
                     "\nhave libgstreamer-plugins-base installed."), Phonon::FatalError);
     } else {
         m_root = this;
@@ -95,7 +98,7 @@ MediaObject::MediaObject(Backend *backend, QObject *parent)
         m_backend->addBusWatcher(this);
         connect(m_tickTimer, SIGNAL(timeout()), SLOT(emitTick()));
     }
-    connect(this, SIGNAL(stateChanged(Phonon::State, Phonon::State)), 
+    connect(this, SIGNAL(stateChanged(Phonon::State, Phonon::State)),
             this, SLOT(notifyStateChange(Phonon::State, Phonon::State)));
 
 }
@@ -136,6 +139,14 @@ QString stateString(const Phonon::State &state)
     return QString();
 }
 
+void
+pluginInstallationDone( GstInstallPluginsReturn res, gpointer userData )
+{
+    // Nothing inside yet
+    Q_UNUSED(res);
+    Q_UNUSED(userData);
+}
+
 void MediaObject::saveState()
 {
     //Only first resumeState is respected
@@ -195,13 +206,35 @@ void MediaObject::noMorePadsAvailable ()
     if (m_missingCodecs.size() > 0) {
         bool canPlay = (m_hasAudio || m_videoStreamFound);
         Phonon::ErrorType error = canPlay ? Phonon::NormalError : Phonon::FatalError;
+#ifdef PLUGIN_INSTALL_API
+        GstInstallPluginsContext *ctx = gst_install_plugins_context_new ();
+        gchar *details[2];
+        details[0] = m_missingCodecs[0].toLocal8Bit().data();
+        details[1] = NULL;
+        GstInstallPluginsReturn status;
+
+        status = gst_install_plugins_async( details, ctx, pluginInstallationDone, NULL );
+        gst_install_plugins_context_free ( ctx );
+
+        if ( status != GST_INSTALL_PLUGINS_STARTED_OK )
+        {
+            if( status == GST_INSTALL_PLUGINS_HELPER_MISSING )
+                setError(QString(tr("Missing codec helper script assistant.")), Phonon::FatalError );
+            else
+                setError(QString(tr("Plugin codec installation failed for codec: %0"))
+                        .arg(m_missingCodecs[0].split("|")[3]), error);
+        }
+        m_missingCodecs.clear();
+#else
+        QString codecs = m_missingCodecs.join(", ");
+
         if (error == Phonon::NormalError && m_hasVideo && !m_videoStreamFound) {
             m_hasVideo = false;
             emit hasVideoChanged(false);
         }
-        QString codecs = m_missingCodecs.join(", ");
         setError(QString(tr("A required codec is missing. You need to install the following codec(s) to play this content: %0")).arg(codecs), error);
         m_missingCodecs.clear();
+#endif
     }
 }
 
@@ -226,7 +259,6 @@ void MediaObject::cb_unknown_type (GstElement *decodebin, GstPad *pad, GstCaps *
     QString value = "unknown codec";
 
     // These functions require GStreamer > 0.10.12
-#ifndef QT_NO_LIBRARY
     static Ptr_gst_pb_utils_init p_gst_pb_utils_init = 0;
     static Ptr_gst_pb_utils_get_codec_description p_gst_pb_utils_get_codec_description = 0;
     if (!p_gst_pb_utils_init) {
@@ -240,15 +272,21 @@ void MediaObject::cb_unknown_type (GstElement *decodebin, GstPad *pad, GstCaps *
         codecName = p_gst_pb_utils_get_codec_description (caps);
         value = QString::fromUtf8(codecName);
         g_free (codecName);
-    } else
-#endif //QT_NO_LIBRARY
-    {
+    } else {
         // For GStreamer versions < 0.10.12
         GstStructure *str = gst_caps_get_structure (caps, 0);
         value = QString::fromUtf8(gst_structure_get_name (str));
-
     }
-    media->addMissingCodecName(value);
+
+#ifdef PLUGIN_INSTALL_API
+    QString plugins = QString("gstreamer|0.10|%0|%1|decoder-%2")
+        .arg( qApp->applicationName() )
+        .arg( value )
+        .arg( QString::fromUtf8(gst_caps_to_string (caps) ) );
+    media->addMissingCodecName( plugins );
+#else
+    media->addMissingCodecName( value );
+#endif
 }
 
 static void notifyVideoCaps(GObject *obj, GParamSpec *, gpointer data)
@@ -309,7 +347,7 @@ void MediaObject::connectVideo(GstPad *pad)
             m_backend->logMessage("Video track connected", Backend::Info, this);
             // Note that the notify::caps _must_ be installed after linking to work with Dapper
             m_capsHandler = g_signal_connect(pad, "notify::caps", G_CALLBACK(notifyVideoCaps), this);
- 
+
             if (!m_loading && !m_hasVideo) {
                 m_hasVideo = m_videoStreamFound;
                 emit hasVideoChanged(m_hasVideo);
@@ -368,7 +406,10 @@ bool MediaObject::createPipefromURL(const QUrl &url)
     }
 
     // Create a new datasource based on the input URL
-    QByteArray encoded_cstr_url = url.toEncoded();
+    // add the 'file' scheme if it's missing; the double '/' is needed!
+    QByteArray encoded_cstr_url = (url.scheme() == QLatin1String("") ?
+                    "file://" + url.toEncoded() :
+                    url.toEncoded());
     m_datasource = gst_element_make_from_uri(GST_URI_SRC, encoded_cstr_url.constData(), (const char*)NULL);
     if (!m_datasource)
         return false;
@@ -388,6 +429,14 @@ bool MediaObject::createPipefromURL(const QUrl &url)
             g_object_set (G_OBJECT (m_datasource), "read-speed", 2, (const char*)NULL);
             m_backend->logMessage(QString("new device speed : 2X"), Backend::Info, this);
         }
+  }
+
+    /* make HTTP sources send extra headers so we get icecast
+     * metadata in case the stream is an icecast stream */
+    if (encoded_cstr_url.startsWith("http://")
+        && g_object_class_find_property (G_OBJECT_GET_CLASS (m_datasource), "iradio-mode")) {
+        g_object_set (m_datasource, "iradio-mode", TRUE, NULL);
+        m_isStream = true;
     }
 
     // Link data source into pipeline
@@ -408,7 +457,6 @@ bool MediaObject::createPipefromURL(const QUrl &url)
  */
 bool MediaObject::createPipefromStream(const MediaSource &source)
 {
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     // Remove any existing data source
     if (m_datasource) {
         gst_bin_remove(GST_BIN(m_pipeline), m_datasource);
@@ -430,10 +478,6 @@ bool MediaObject::createPipefromStream(const MediaSource &source)
         return false;
     }
     return true;
-#else //QT_NO_PHONON_ABSTRACTMEDIASTREAM
-    Q_UNUSED(source);
-    return false;
-#endif
 }
 
 void MediaObject::createPipeline()
@@ -676,7 +720,7 @@ void MediaObject::changeState(State newstate)
         return;
 
     Phonon::State oldState = m_state;
-    m_state = newstate; // m_state must be set before emitting, since 
+    m_state = newstate; // m_state must be set before emitting, since
                         // Error state requires that state() will return the new value
     m_pendingState = newstate;
     emit stateChanged(newstate, oldState);
@@ -861,7 +905,7 @@ void MediaObject::setSource(const MediaSource &source)
     // such as failing duration queries etc
     GstState state;
     gst_element_set_state(m_pipeline, GST_STATE_NULL);
-    gst_element_get_state (m_pipeline, &state, NULL, 2000);
+    gst_element_get_state(m_pipeline, &state, NULL, 2000);
 
     m_source = source;
     emit currentSourceChanged(m_source);
@@ -885,7 +929,7 @@ void MediaObject::setSource(const MediaSource &source)
     m_aboutToFinishEmitted = false;
     m_error = NoError;
     m_errorString = QString();
-    
+
     m_bufferPercent = 0;
     m_prefinishMarkReachedNotEmitted = true;
     m_aboutToFinishEmitted = false;
@@ -894,11 +938,16 @@ void MediaObject::setSource(const MediaSource &source)
     setTotalTime(-1);
     m_atEndOfStream = false;
 
-    // Clear exising meta tags
+    m_availableTitles = 0;
+    m_pendingTitle = 1;
+    m_currentTitle = 1;
+
+    // Clear existing meta tags
     m_metaData.clear();
+    m_isStream = false;
 
     switch (source.type()) {
-    case MediaSource::Url: {            
+    case MediaSource::Url: {
             if (createPipefromURL(source.url()))
                 m_loading = true;
             else
@@ -930,9 +979,9 @@ void MediaObject::setSource(const MediaSource &source)
 
     case MediaSource::Disc:
         {
-            QString mediaUrl;
-            switch (source.discType()) {
-            case Phonon::NoDisc:
+       QString mediaUrl;
+       switch (source.discType()) {
+       case Phonon::NoDisc:
                 qWarning() << "I should never get to see a MediaSource that is a disc but doesn't specify which one";
                 return;
             case Phonon::Cd:  // CD tracks can be specified by setting the url in the following way uri=cdda:4
@@ -1004,13 +1053,10 @@ void MediaObject::getStreamInfo()
         emit hasVideoChanged(m_hasVideo);
     }
 
-    m_availableTitles = 1;
-    gint64 titleCount;
-    GstFormat format = gst_format_get_by_nick("track");
-    if (gst_element_query_duration (m_pipeline, &format, &titleCount)) {
-        //check if returned format is still "track",
-        //gstreamer sometimes returns the total time, if tracks information is not available.
-        if (qstrcmp(gst_format_get_name(format), "track") == 0)  {
+    if (m_source.discType() == Phonon::Cd) {
+        gint64 titleCount;
+        GstFormat format = gst_format_get_by_nick("track");
+        if (gst_element_query_duration (m_pipeline, &format, &titleCount)) {
             int oldAvailableTitles = m_availableTitles;
             m_availableTitles = (int)titleCount;
             if (m_availableTitles != oldAvailableTitles) {
@@ -1077,7 +1123,7 @@ void MediaObject::seek(qint64 time)
         }
 
         quint64 current = currentTime();
-        quint64 total = totalTime(); 
+        quint64 total = totalTime();
 
         if (current < total - m_prefinishMark)
             m_prefinishMarkReachedNotEmitted = true;
@@ -1098,7 +1144,7 @@ void MediaObject::emitTick()
 
     if (m_tickInterval > 0 && currentTime != m_previousTickTime) {
         emit tick(currentTime);
-        m_previousTickTime = currentTime;        
+        m_previousTickTime = currentTime;
     }
     if (m_state == Phonon::PlayingState) {
         if (currentTime >= totalTime - m_prefinishMark) {
@@ -1109,7 +1155,12 @@ void MediaObject::emitTick()
         }
         // Prepare load of next source
         if (currentTime >= totalTime - ABOUT_TO_FINNISH_TIME) {
-            if (!m_aboutToFinishEmitted) {
+            if (m_source.type() == MediaSource::Disc &&
+                m_autoplayTitles &&
+                m_availableTitles > 1 &&
+                m_currentTitle < m_availableTitles) {
+                m_aboutToFinishEmitted = false;
+            } else if (!m_aboutToFinishEmitted) {
                 m_aboutToFinishEmitted = true; // track is about to finish
                 emit aboutToFinish();
             }
@@ -1213,7 +1264,7 @@ void MediaObject::handleBusMessage(const Message &message)
 
     switch (GST_MESSAGE_TYPE (gstMessage)) {
 
-    case GST_MESSAGE_EOS: 
+    case GST_MESSAGE_EOS:
         m_backend->logMessage("EOS recieved", Backend::Info, this);
         handleEndOfStream();
         break;
@@ -1222,14 +1273,98 @@ void MediaObject::handleBusMessage(const Message &message)
             GstTagList* tag_list = 0;
             gst_message_parse_tag(gstMessage, &tag_list);
             if (tag_list) {
+                TagMap newTags;
+                gst_tag_list_foreach (tag_list, &foreach_tag_function, &newTags);
+                gst_tag_list_free(tag_list);
+
+                // Determine if we should no fake the album/artist tags.
+                // This is a little confusing as we want to fake it on initial
+                // connection where title, album and artist are all missing.
+                // There are however times when we get just other information,
+                // e.g. codec, and so we want to only do clever stuff if we
+                // have a commonly available tag (ORGANIZATION) or we have a
+                // change in title
+                bool fake_it =
+                   (m_isStream
+                    && ((!newTags.contains("TITLE")
+                         && newTags.contains("ORGANIZATION"))
+                        || (newTags.contains("TITLE")
+                            && m_metaData.value("TITLE") != newTags.value("TITLE")))
+                    && !newTags.contains("ALBUM")
+                    && !newTags.contains("ARTIST"));
+
                 TagMap oldMap = m_metaData; // Keep a copy of the old one for reference
-                // Append any new meta tags to the existing tag list
-                gst_tag_list_foreach (tag_list, &foreach_tag_function, &m_metaData);
+
+                // Now we've checked the new data, append any new meta tags to the existing tag list
+                // We cannot use TagMap::iterator as this is a multimap and when streaming data
+                // could in theory be lost.
+                QList<QString> keys = newTags.keys();
+                for (QList<QString>::iterator i = keys.begin(); i != keys.end(); ++i) {
+                    QString key = *i;
+                    if (m_isStream) {
+                        // If we're streaming, we need to remove data in m_metaData
+                        // in order to stop it filling up indefinitely (as it's a multimap)
+                        m_metaData.remove(key);
+                    }
+                    QList<QString> values = newTags.values(key);
+                    for (QList<QString>::iterator j = values.begin(); j != values.end(); ++j) {
+                        QString value = *j;
+                        QString currVal = m_metaData.value(key);
+                        if (!m_metaData.contains(key) || currVal != value) {
+                            m_metaData.insert(key, value);
+                        }
+                    }
+                }
+
                 m_backend->logMessage("Meta tags found", Backend::Info, this);
-                if (oldMap != m_metaData && !m_loading)
-                    emit metaDataChanged(m_metaData);
-                gst_tag_list_free(tag_list);
-            }
+                if (oldMap != m_metaData) {
+                    // This is a bit of a hack to ensure that stream metadata is
+                    // returned. We get as much as we can from the Shoutcast server's
+                    // StreamTitle= header. If further info is decoded from the stream
+                    // itself later, then it will overwrite this info.
+                    if (m_isStream && fake_it) {
+                        m_metaData.remove("ALBUM");
+                        m_metaData.remove("ARTIST");
+
+                        // Detect whether we want to "fill in the blanks"
+                        QString str;
+                        if (m_metaData.contains("TITLE"))
+                        {
+                            str = m_metaData.value("TITLE");
+                            int splitpoint;
+                            // Check to see if our title matches "%s - %s"
+                            // Where neither %s are empty...
+                            if ((splitpoint = str.indexOf(" - ")) > 0
+                                && str.size() > (splitpoint+3)) {
+                                m_metaData.insert("ARTIST", str.left(splitpoint));
+                                m_metaData.replace("TITLE", str.mid(splitpoint+3));
+                            }
+                        } else {
+                            str = m_metaData.value("GENRE");
+                            if (!str.isEmpty())
+                                m_metaData.insert("TITLE", str);
+                            else
+                                m_metaData.insert("TITLE", "Streaming Data");
+                        }
+                        if (!m_metaData.contains("ARTIST")) {
+                            str = m_metaData.value("LOCATION");
+                            if (!str.isEmpty())
+                                m_metaData.insert("ARTIST", str);
+                            else
+                                m_metaData.insert("ARTIST", "Streaming Data");
+                        }
+                        str = m_metaData.value("ORGANIZATION");
+                        if (!str.isEmpty())
+                            m_metaData.insert("ALBUM", str);
+                        else
+                            m_metaData.insert("ALBUM", "Streaming Data");
+                    }
+                    // As we manipulate the title, we need to recompare
+                    // oldMap and m_metaData here...
+                    if (oldMap != m_metaData && !m_loading)
+                        emit metaDataChanged(m_metaData);
+                }
+			}
         }
         break;
 
@@ -1255,6 +1390,9 @@ void MediaObject::handleBusMessage(const Message &message)
                 m_backend->logMessage("gstreamer: pipeline state set to playing", Backend::Info, this);
                 m_tickTimer->start();
                 changeState(Phonon::PlayingState);
+                if ((m_source.type() == MediaSource::Disc) && (m_currentTitle != m_pendingTitle)) {
+                    setTrack(m_pendingTitle);
+                }
                 if (m_resumeState && m_oldState == Phonon::PlayingState) {
                     seek(m_oldPos);
                     m_resumeState = false;
@@ -1290,6 +1428,9 @@ void MediaObject::handleBusMessage(const Message &message)
                     changeState(Phonon::StoppedState);
                 m_backend->logMessage("gstreamer: pipeline state set to ready", Backend::Debug, this);
                 m_tickTimer->stop();
+                if ((m_source.type() == MediaSource::Disc) && (m_currentTitle != m_pendingTitle)) {
+                    setTrack(m_pendingTitle);
+                }
                 break;
 
             case GST_STATE_VOID_PENDING :
@@ -1328,7 +1469,7 @@ void MediaObject::handleBusMessage(const Message &message)
                             setError(err->message, Phonon::FatalError);
                         gst_caps_unref (caps);
                         gst_object_unref (sinkPad);
-                   } 
+                   }
                } else {
                     setError(QString(err->message), Phonon::FatalError);
                }
@@ -1400,8 +1541,8 @@ void MediaObject::handleBusMessage(const Message &message)
         //case GST_MESSAGE_STEP_DONE:
         //case GST_MESSAGE_LATENCY: only from 0.10.12
         //case GST_MESSAGE_ASYNC_DONE: only from 0.10.13
-    default: 
-        break; 
+    default:
+        break;
     }
 }
 
@@ -1417,7 +1558,8 @@ void MediaObject::handleEndOfStream()
     if (!m_seekable)
         m_atEndOfStream = true;
 
-    if (m_autoplayTitles &&
+    if (m_source.type() == MediaSource::Disc &&
+        m_autoplayTitles &&
         m_availableTitles > 1 &&
         m_currentTitle < m_availableTitles) {
         _iface_setCurrentTitle(m_currentTitle + 1);
@@ -1502,15 +1644,30 @@ int MediaObject::_iface_currentTitle() const
 
 void MediaObject::_iface_setCurrentTitle(int title)
 {
-    GstFormat trackFormat = gst_format_get_by_nick("track");
     m_backend->logMessage(QString("setCurrentTitle %0").arg(title), Backend::Info, this);
-    if ((title == m_currentTitle) || (title < 1) || (title > m_availableTitles))
+    if ((title == m_currentTitle) || (title == m_pendingTitle))
+        return;
+
+    m_pendingTitle = title;
+
+    if (m_state == Phonon::PlayingState || m_state == Phonon::StoppedState) {
+        setTrack(m_pendingTitle);
+    } else {
+        setState(Phonon::StoppedState);
+    }
+}
+
+void MediaObject::setTrack(int title)
+{
+    if (((m_state != Phonon::PlayingState) && (m_state != Phonon::StoppedState)) || (title < 1) || (title > m_availableTitles))
         return;
 
-    m_currentTitle = title;
 
     //let's seek to the beginning of the song
-    if (gst_element_seek_simple(m_pipeline, trackFormat, GST_SEEK_FLAG_FLUSH, m_currentTitle - 1)) {
+    GstFormat trackFormat = gst_format_get_by_nick("track");
+    m_backend->logMessage(QString("setTrack %0").arg(title), Backend::Info, this);
+    if (gst_element_seek_simple(m_pipeline, trackFormat, GST_SEEK_FLAG_FLUSH, title - 1)) {
+        m_currentTitle = title;
         updateTotalTime();
         m_atEndOfStream = false;
         emit titleChanged(title);
diff --git a/src/3rdparty/phonon/gstreamer/mediaobject.h b/src/3rdparty/phonon/gstreamer/mediaobject.h
index 64b3510..2db596d 100644
--- a/src/3rdparty/phonon/gstreamer/mediaobject.h
+++ b/src/3rdparty/phonon/gstreamer/mediaobject.h
@@ -55,6 +55,7 @@ class MediaObject : public QObject, public MediaObjectInterface
         , public MediaNode
 {
     friend class Stream;
+    friend class AudioDataOutput;
     Q_OBJECT
     Q_INTERFACES(Phonon::MediaObjectInterface
 #ifndef QT_NO_PHONON_MEDIACONTROLLER
@@ -236,6 +237,7 @@ private:
     int _iface_availableTitles() const;
     int _iface_currentTitle() const;
     void _iface_setCurrentTitle(int title);
+    void setTrack(int title);
 
     bool m_resumeState;
     State m_oldState;
@@ -250,6 +252,7 @@ private:
     MediaSource m_nextSource;
     qint32 m_prefinishMark;
     qint32 m_transitionTime;
+	bool m_isStream;
 
     qint64 m_posAtSeek;
 
@@ -285,6 +288,7 @@ private:
     bool m_autoplayTitles;
     int m_availableTitles;
     int m_currentTitle;
+    int m_pendingTitle;
 };
 }
 } //namespace Phonon::Gstreamer
diff --git a/src/3rdparty/phonon/gstreamer/phononsrc.cpp b/src/3rdparty/phonon/gstreamer/phononsrc.cpp
index 97d7220..f893fb5 100644
--- a/src/3rdparty/phonon/gstreamer/phononsrc.cpp
+++ b/src/3rdparty/phonon/gstreamer/phononsrc.cpp
@@ -109,25 +109,18 @@ static void phonon_src_class_init (PhononSrcClass * klass)
 static void phonon_src_init (PhononSrc * src, PhononSrcClass * g_class)
 {
     Q_UNUSED(g_class);
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     src->device = 0;
-#else
-    Q_UNUSED(src);
-#endif
 }
 
 static void phonon_src_finalize (GObject * object)
 {
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     PhononSrc *src;
     src = GST_PHONON_SRC (object);
     delete src->device;
     src->device = 0;
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
     G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
 static gboolean phonon_src_set_device(PhononSrc * src, StreamReader* device)
 {
     GstState state;
@@ -152,7 +145,6 @@ wrong_state:
         return FALSE;
     }
 }
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
 
 static void phonon_src_set_property (GObject * object, guint prop_id, const GValue * value, GParamSpec * pspec)
 {
@@ -161,7 +153,6 @@ static void phonon_src_set_property (GObject * object, guint prop_id, const GVal
     src = GST_PHONON_SRC (object);
 
     switch (prop_id) {
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     case ARG_PHONONSRC:
     {
         StreamReader *dev = (StreamReader*)(g_value_get_pointer(value));
@@ -169,9 +160,6 @@ static void phonon_src_set_property (GObject * object, guint prop_id, const GVal
             phonon_src_set_device(src, dev);
         break;
     }
-#else
-    Q_UNUSED(value);
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
    default:
        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
        break;
@@ -186,13 +174,9 @@ static void phonon_src_get_property (GObject * object, guint prop_id, GValue * v
     src = GST_PHONON_SRC (object);
 
     switch (prop_id) {
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     case ARG_PHONONSRC:
         g_value_set_pointer(value, src->device);
         break;
-#else //QT_NO_PHONON_ABSTRACTMEDIASTREAM
-    Q_UNUSED(value);
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
     default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
         break;
@@ -201,7 +185,6 @@ static void phonon_src_get_property (GObject * object, guint prop_id, GValue * v
 
 static GstFlowReturn phonon_src_create_read (PhononSrc * src, guint64 offset, guint length, GstBuffer ** buffer)
 {
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     Q_ASSERT(src->device);
     if (!src->device)
         return GST_FLOW_ERROR;
@@ -221,13 +204,6 @@ static GstFlowReturn phonon_src_create_read (PhononSrc * src, guint64 offset, gu
 
     gst_mini_object_unref(GST_MINI_OBJECT(buf));
     return GST_FLOW_ERROR;
-#else //QT_NO_PHONON_ABSTRACTMEDIASTREAM
-    Q_UNUSED(src);
-    Q_UNUSED(offset);
-    Q_UNUSED(length);
-    Q_UNUSED(buffer);
-    return GST_FLOW_ERROR;
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
 }
 
 static GstFlowReturn phonon_src_create (GstBaseSrc * basesrc, guint64 offset, guint length, GstBuffer ** buffer)
@@ -242,23 +218,19 @@ static GstFlowReturn phonon_src_create (GstBaseSrc * basesrc, guint64 offset, gu
 static gboolean phonon_src_is_seekable (GstBaseSrc * basesrc)
 {
     PhononSrc *src = GST_PHONON_SRC (basesrc);
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     if (src->device)
         return src->device->streamSeekable();
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
     return false;
 }
 
 static gboolean phonon_src_get_size (GstBaseSrc * basesrc, guint64 * size)
 {
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     PhononSrc *src;
     src = GST_PHONON_SRC (basesrc);
     if (src->device && src->device->streamSeekable()) {
         *size = src->device->streamSize();
         return TRUE;
     }
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
     *size = 0;
     return FALSE;
 }
diff --git a/src/3rdparty/phonon/gstreamer/phononsrc.h b/src/3rdparty/phonon/gstreamer/phononsrc.h
index a50f8a2..a2cd8b3 100644
--- a/src/3rdparty/phonon/gstreamer/phononsrc.h
+++ b/src/3rdparty/phonon/gstreamer/phononsrc.h
@@ -49,9 +49,7 @@ typedef struct _PhononSrcClass PhononSrcClass;
 // PhononSrc:
 struct _PhononSrc {
     GstBaseSrc element;
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     StreamReader *device;
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
 };
 
 struct _PhononSrcClass {
diff --git a/src/3rdparty/phonon/gstreamer/qwidgetvideosink.h b/src/3rdparty/phonon/gstreamer/qwidgetvideosink.h
index 73a494a..f83dba5 100644
--- a/src/3rdparty/phonon/gstreamer/qwidgetvideosink.h
+++ b/src/3rdparty/phonon/gstreamer/qwidgetvideosink.h
@@ -19,6 +19,7 @@
 #define Phonon_GSTREAMER_VIDEOSINK_H
 
 #include "common.h"
+#include "qwidgetvideosink.h"
 
 #include <QtCore/QByteArray>
 #include <QtCore/QEvent>
diff --git a/src/3rdparty/phonon/gstreamer/streamreader.cpp b/src/3rdparty/phonon/gstreamer/streamreader.cpp
index f8219e6..04fa6cc 100644
--- a/src/3rdparty/phonon/gstreamer/streamreader.cpp
+++ b/src/3rdparty/phonon/gstreamer/streamreader.cpp
@@ -20,7 +20,7 @@ along with this library.  If not, see <http://www.gnu.org/licenses/>.
 #include <phonon/streaminterface.h>
 
 QT_BEGIN_NAMESPACE
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
+
 namespace Phonon
 {
 namespace Gstreamer
@@ -49,6 +49,5 @@ bool StreamReader::read(quint64 pos, int length, char * buffer)
 
 }
 }
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
 
 QT_END_NAMESPACE
diff --git a/src/3rdparty/phonon/gstreamer/streamreader.h b/src/3rdparty/phonon/gstreamer/streamreader.h
index 387370c..c2e61c8 100644
--- a/src/3rdparty/phonon/gstreamer/streamreader.h
+++ b/src/3rdparty/phonon/gstreamer/streamreader.h
@@ -23,8 +23,6 @@ along with this library.  If not, see <http://www.gnu.org/licenses/>.
 
 QT_BEGIN_NAMESPACE
 
-#ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
-
 namespace Phonon
 {
     class MediaSource;
@@ -93,8 +91,6 @@ private:
     }
 }
 
-#endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
-
 QT_END_NAMESPACE
 
 #endif
diff --git a/src/3rdparty/phonon/gstreamer/videowidget.cpp b/src/3rdparty/phonon/gstreamer/videowidget.cpp
index e1f0ec9..efc750a 100644
--- a/src/3rdparty/phonon/gstreamer/videowidget.cpp
+++ b/src/3rdparty/phonon/gstreamer/videowidget.cpp
@@ -33,7 +33,6 @@
 #include "widgetrenderer.h"
 #include "x11renderer.h"
 
-#ifndef QT_NO_PHONON_VIDEO
 QT_BEGIN_NAMESPACE
 
 namespace Phonon
@@ -384,6 +383,5 @@ void VideoWidget::mediaNodeEvent(const MediaNodeEvent *event)
 } //namespace Phonon::Gstreamer
 
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_VIDEO
 
 #include "moc_videowidget.cpp"
diff --git a/src/3rdparty/phonon/gstreamer/videowidget.h b/src/3rdparty/phonon/gstreamer/videowidget.h
index dc0754d..47f4e08 100644
--- a/src/3rdparty/phonon/gstreamer/videowidget.h
+++ b/src/3rdparty/phonon/gstreamer/videowidget.h
@@ -25,10 +25,10 @@
 #include "common.h"
 #include "medianode.h"
 #include "abstractrenderer.h"
+#include "videowidget.h"
 
 #include <gst/gst.h>
 
-#ifndef QT_NO_PHONON_VIDEO
 QT_BEGIN_NAMESPACE
 
 class QString;
@@ -103,5 +103,5 @@ private:
 } //namespace Phonon::Gstreamer
 
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_VIDEO
+
 #endif // Phonon_GSTREAMER_VIDEOWIDGET_H
diff --git a/src/3rdparty/phonon/gstreamer/volumefadereffect.cpp b/src/3rdparty/phonon/gstreamer/volumefadereffect.cpp
index bf0d646..d7ee11b 100644
--- a/src/3rdparty/phonon/gstreamer/volumefadereffect.cpp
+++ b/src/3rdparty/phonon/gstreamer/volumefadereffect.cpp
@@ -21,11 +21,11 @@
 
 QT_BEGIN_NAMESPACE
 
-#ifndef QT_NO_PHONON_VOLUMEFADEREFFECT
 namespace Phonon
 {
 namespace Gstreamer
 {
+
 VolumeFaderEffect::VolumeFaderEffect(Backend *backend, QObject *parent) 
     : Effect(backend, parent, AudioSource | AudioSink)
     , m_fadeCurve(Phonon::VolumeFaderEffect::Fade3Decibel)
@@ -156,7 +156,7 @@ bool VolumeFaderEffect::event(QEvent *event)
 }
 
 }} //namespace Phonon::Gstreamer
-#endif //QT_NO_PHONON_VOLUMEFADEREFFECT
+
 QT_END_NAMESPACE
 
 #include "moc_volumefadereffect.cpp"
diff --git a/src/3rdparty/phonon/gstreamer/volumefadereffect.h b/src/3rdparty/phonon/gstreamer/volumefadereffect.h
index 748d2d6..d74014c 100644
--- a/src/3rdparty/phonon/gstreamer/volumefadereffect.h
+++ b/src/3rdparty/phonon/gstreamer/volumefadereffect.h
@@ -30,7 +30,7 @@
 #include <gst/gst.h>
 
 QT_BEGIN_NAMESPACE
-#ifndef QT_NO_PHONON_VOLUMEFADEREFFECT
+
 namespace Phonon
 {
 namespace Gstreamer
@@ -64,7 +64,7 @@ namespace Gstreamer
             QTime m_fadeStartTime;
     };
 }} //namespace Phonon::Gstreamer
-#endif //QT_NO_PHONON_VOLUMEFADEREFFECT
+
 QT_END_NAMESPACE
 
 #endif // Phonon_GSTREAMER_VOLUMEFADEREFFECT_H
diff --git a/src/3rdparty/phonon/gstreamer/widgetrenderer.cpp b/src/3rdparty/phonon/gstreamer/widgetrenderer.cpp
index 423af9d..d4a411f 100644
--- a/src/3rdparty/phonon/gstreamer/widgetrenderer.cpp
+++ b/src/3rdparty/phonon/gstreamer/widgetrenderer.cpp
@@ -32,7 +32,6 @@
 # define GL_TEXTURE2    0x84C2
 #endif
 
-#ifndef QT_NO_PHONON_VIDEO
 QT_BEGIN_NAMESPACE
 
 static void frameRendered()
@@ -149,4 +148,3 @@ bool WidgetRenderer::eventFilter(QEvent * event)
 } //namespace Phonon::Gstreamer
 
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_VIDEO
diff --git a/src/3rdparty/phonon/gstreamer/widgetrenderer.h b/src/3rdparty/phonon/gstreamer/widgetrenderer.h
index 03ee9c0..ff64fa7 100644
--- a/src/3rdparty/phonon/gstreamer/widgetrenderer.h
+++ b/src/3rdparty/phonon/gstreamer/widgetrenderer.h
@@ -26,7 +26,6 @@
 #include <QtOpenGL/QGLWidget>
 #endif
 
-#ifndef QT_NO_PHONON_VIDEO
 QT_BEGIN_NAMESPACE
 
 class QString;
@@ -60,5 +59,5 @@ private:
 } //namespace Phonon::Gstreamer
 
 QT_END_NAMESPACE
-#endif //QT_NO_PHONON_VIDEO
+
 #endif // Phonon_GSTREAMER_WIDGETRENDERER_H
diff --git a/src/3rdparty/phonon/gstreamer/x11renderer.cpp b/src/3rdparty/phonon/gstreamer/x11renderer.cpp
index 73877a8..9977001 100644
--- a/src/3rdparty/phonon/gstreamer/x11renderer.cpp
+++ b/src/3rdparty/phonon/gstreamer/x11renderer.cpp
@@ -138,6 +138,7 @@ void X11Renderer::scaleModeChanged(Phonon::VideoWidget::ScaleMode)
 void X11Renderer::movieSizeChanged(const QSize &movieSize)
 {
     Q_UNUSED(movieSize);
+
     if (m_renderWidget) {
         m_renderWidget->setGeometry(m_videoWidget->calculateDrawFrameRect());
     }
diff --git a/src/3rdparty/phonon/includes/CMakeLists.txt b/src/3rdparty/phonon/includes/CMakeLists.txt
index dff86c3..349acd8 100644
--- a/src/3rdparty/phonon/includes/CMakeLists.txt
+++ b/src/3rdparty/phonon/includes/CMakeLists.txt
@@ -35,7 +35,7 @@ install( FILES
   Phonon/VolumeFaderEffect
   Phonon/VolumeFaderInterface
   Phonon/VolumeSlider
-DESTINATION ${INCLUDE_INSTALL_DIR}/KDE/Phonon COMPONENT Devel)
+DESTINATION ${INCLUDE_INSTALL_DIR}/KDE/Phonon)
 
 install(FILES
   Phonon/Experimental/AbstractVideoDataOutput
@@ -46,4 +46,4 @@ install(FILES
   Phonon/Experimental/VideoFrame
   Phonon/Experimental/VideoFrame2
   Phonon/Experimental/Visualization
-DESTINATION ${INCLUDE_INSTALL_DIR}/KDE/Phonon/Experimental COMPONENT Devel)
+DESTINATION ${INCLUDE_INSTALL_DIR}/KDE/Phonon/Experimental)
diff --git a/src/3rdparty/phonon/mmf/abstractaudioeffect.cpp b/src/3rdparty/phonon/mmf/abstractaudioeffect.cpp
index a559249..a793390 100644
--- a/src/3rdparty/phonon/mmf/abstractaudioeffect.cpp
+++ b/src/3rdparty/phonon/mmf/abstractaudioeffect.cpp
@@ -29,10 +29,6 @@ using namespace Phonon::MMF;
   \internal
 */
 
-/*! \namespace Phonon::MMF
-  \internal
-*/
-
 AbstractAudioEffect::AbstractAudioEffect(QObject *parent,
                                          const QList<EffectParameter> &params) : MediaNode::MediaNode(parent)
                                                                                , m_params(params)
diff --git a/src/3rdparty/phonon/mmf/ancestormovemonitor.cpp b/src/3rdparty/phonon/mmf/ancestormovemonitor.cpp
index 18ced94..0447d57 100644
--- a/src/3rdparty/phonon/mmf/ancestormovemonitor.cpp
+++ b/src/3rdparty/phonon/mmf/ancestormovemonitor.cpp
@@ -26,7 +26,7 @@ QT_BEGIN_NAMESPACE
 
 using namespace Phonon::MMF;
 
-/*! \class Phonon::MMF::AncestorMoveMonitor
+/*! \class MMF::AncestorMoveMonitor
   \internal
   \brief Class which installs a global event filter, and listens for move
   events which may affect the absolute position of widgets registered with
@@ -34,11 +34,6 @@ using namespace Phonon::MMF;
   See QTBUG-4956
 */
 
-
-/*! \class Phonon::MMF::VideoOutputObserver
-    \internal
-*/
-
 //-----------------------------------------------------------------------------
 // Constructor / destructor
 //-----------------------------------------------------------------------------
diff --git a/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump.cpp b/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump.cpp
new file mode 100644
index 0000000..9add439
--- /dev/null
+++ b/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump.cpp
@@ -0,0 +1,527 @@
+/*  This file is part of the KDE project.
+
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+This library is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 or 3 of the License.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include <QByteArray>
+#include <QDebug>
+#include <QHash>
+#include <QTextStream>
+#include <QWidget>
+
+#include "objectdump.h"
+#include "objecttree.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace ObjectDump
+{
+
+//-----------------------------------------------------------------------------
+// QObjectAnnotator
+//-----------------------------------------------------------------------------
+
+QAnnotator::~QAnnotator()
+{
+
+}
+
+
+//-----------------------------------------------------------------------------
+// Annotators
+//-----------------------------------------------------------------------------
+
+QList<QByteArray> QAnnotatorBasic::annotation(const QObject& object)
+{
+    QList<QByteArray> result;
+
+    QByteArray array;
+    QTextStream stream(&array);
+
+    stream << '[' << &object << ']';
+    stream << ' ';
+    stream << object.metaObject()->className();
+
+    if (object.objectName() != "")
+        stream << " \"" << object.objectName() << '"';
+
+    if (object.isWidgetType())
+        stream << " isWidget";
+
+    stream.flush();
+    result.append(array);
+    return result;
+}
+
+QList<QByteArray> QAnnotatorWidget::annotation(const QObject& object)
+{
+    QList<QByteArray> result;
+
+    const QWidget* widget = qobject_cast<const QWidget*>(&object);
+    if (widget) {
+
+        QByteArray array;
+        QTextStream stream(&array);
+
+        stream << "widget: ";
+
+        if (widget->isVisible())
+            stream << "visible ";
+        else
+            stream << "invisible ";
+
+        stream << widget->x() << ',' << widget->y() << ' ';
+        stream << widget->size().width() << 'x'<< widget->size().height() << ' ';
+
+        stream << "hint " << widget->sizeHint().width() << 'x' << widget->sizeHint().height();
+
+        stream.flush();
+        result.append(array);
+    }
+
+    return result;
+}
+
+
+//-----------------------------------------------------------------------------
+// Base class for QDumperPrivate, QVisitorPrivate
+//-----------------------------------------------------------------------------
+
+class QDumperBase
+{
+public:
+    QDumperBase();
+    ~QDumperBase();
+
+    void setPrefix(const QString& prefix);
+    void addAnnotator(QAnnotator* annotator);
+
+protected:
+    QByteArray m_prefix;
+    QList<QAnnotator*> m_annotators;
+
+};
+
+QDumperBase::QDumperBase()
+{
+
+}
+
+QDumperBase::~QDumperBase()
+{
+    QAnnotator* annotator;
+    foreach(annotator, m_annotators)
+        delete annotator;
+}
+
+void QDumperBase::setPrefix(const QString& prefix)
+{
+    m_prefix = prefix.count()
+        ? (prefix + " ").toAscii()
+        : prefix.toAscii();
+}
+
+void QDumperBase::addAnnotator(QAnnotator* annotator)
+{
+    // Protect against an exception occurring during QList::append
+    QScopedPointer<QAnnotator> holder(annotator);
+    m_annotators.append(annotator);
+    holder.take();
+}
+
+
+//-----------------------------------------------------------------------------
+// QDumper
+//-----------------------------------------------------------------------------
+
+class QDumperPrivate : public QDumperBase
+{
+public:
+    QDumperPrivate();
+    ~QDumperPrivate();
+
+    void dumpObject(const QObject& object);
+
+};
+
+
+QDumperPrivate::QDumperPrivate()
+{
+
+}
+
+QDumperPrivate::~QDumperPrivate()
+{
+
+}
+
+void QDumperPrivate::dumpObject(const QObject& object)
+{
+    QAnnotator* annotator;
+    foreach(annotator, m_annotators) {
+
+        const QList<QByteArray> annotations = annotator->annotation(object);
+        QByteArray annotation;
+        foreach(annotation, annotations) {
+            QByteArray buffer(m_prefix);
+            buffer.append(annotation);
+            qDebug() << buffer.constData();
+        }
+    }
+}
+
+
+QDumper::QDumper()
+    : d_ptr(new QDumperPrivate)
+{
+
+}
+
+QDumper::~QDumper()
+{
+
+}
+
+void QDumper::setPrefix(const QString& prefix)
+{
+    d_func()->setPrefix(prefix);
+}
+
+void QDumper::addAnnotator(QAnnotator* annotator)
+{
+    d_func()->addAnnotator(annotator);
+}
+
+void QDumper::dumpObject(const QObject& object)
+{
+    d_func()->dumpObject(object);
+}
+
+
+//-----------------------------------------------------------------------------
+// QVisitor
+//-----------------------------------------------------------------------------
+
+class QVisitorPrivate : public QDumperBase
+{
+public:
+    QVisitorPrivate();
+    ~QVisitorPrivate();
+
+    void setIndent(unsigned indent);
+
+    void visitNode(const QObject& object);
+    void visitComplete();
+
+private:
+    class Node
+    {
+    public:
+        Node();
+        ~Node();
+
+        QList<QByteArray>   m_annotation;
+        QList<Node*>        m_children;
+
+        typedef QList<Node*>::const_iterator child_iterator;
+    };
+
+private:
+    Node* findNode(const QObject* object) const;
+    QByteArray branchBuffer(const QList<bool>& branches, bool isNodeLine, bool isLastChild) const;
+    void dumpRecursive(const Node& node, QList<bool> branches, bool isLastChild);
+    void dumpNode(const Node& node, const QList<bool>& branches, bool isLastChild);
+
+private:
+    unsigned m_indent;
+
+    QScopedPointer<Node> m_root;
+
+    // Hash table used to associate internal nodes with QObjects
+    typedef QHash<const QObject*, Node*> Hash;
+    Hash m_hash;
+};
+
+static const unsigned DefaultIndent = 2;
+
+QVisitorPrivate::QVisitorPrivate()
+    :   m_indent(DefaultIndent)
+{
+
+}
+
+QVisitorPrivate::~QVisitorPrivate()
+{
+
+}
+
+void QVisitorPrivate::setIndent(unsigned indent)
+{
+    m_indent = indent;
+}
+
+// Builds up a mirror of the object tree, rooted in m_root, with each node
+// storing annotations generated by
+void QVisitorPrivate::visitNode(const QObject& object)
+{
+    QObject* const objectParent = object.parent();
+    Node* const nodeParent = objectParent ? findNode(objectParent) : 0;
+
+    // Create a new node and store in scoped pointer for exception safety
+    Node* node = new Node;
+    QScopedPointer<Node> nodePtr(node);
+
+    // Associate node with QObject
+    m_hash.insert(&object, node);
+
+    // Insert node into internal tree
+    if (nodeParent)
+    {
+        nodeParent->m_children.append(nodePtr.take());
+    }
+    else
+    {
+        Q_ASSERT(m_root.isNull());
+        m_root.reset(nodePtr.take());
+    }
+
+    // Generate and store annotations
+    QAnnotator* annotator;
+    foreach(annotator, m_annotators)
+        node->m_annotation.append( annotator->annotation(object) );
+}
+
+void QVisitorPrivate::visitComplete()
+{
+    QList<bool> branches;
+    static const bool isLastChild = true;
+    dumpRecursive(*m_root, branches, isLastChild);
+    m_root.reset(0);
+}
+
+QVisitorPrivate::Node* QVisitorPrivate::findNode(const QObject* object) const
+{
+    Hash::const_iterator i = m_hash.find(object);
+    return (m_hash.end() == i) ? 0 : *i;
+}
+
+QByteArray QVisitorPrivate::branchBuffer
+    (const QList<bool>& branches, bool isNodeLine, bool isLastChild) const
+{
+    const int depth = branches.count();
+
+    const QByteArray indent(m_indent, ' ');
+    const QByteArray horiz(m_indent, '-');
+
+    QByteArray buffer;
+    QTextStream stream(&buffer);
+
+    for (int i=0; i<depth-1; ++i) {
+        if (branches[i])
+            stream << '|';
+        else
+            stream << ' ';
+        stream << indent;
+    }
+
+    if (depth) {
+        if (isNodeLine)
+            stream << '+' << horiz;
+        else {
+            if (!isLastChild)
+                stream << '|';
+            else
+                stream << ' ';
+            stream << indent;
+        }
+    }
+
+    stream.flush();
+    buffer.push_front(m_prefix);
+
+    return buffer;
+}
+
+void QVisitorPrivate::dumpRecursive
+    (const Node& node, QList<bool> branches, bool isLastChild)
+{
+    dumpNode(node, branches, isLastChild);
+
+    // Recurse down tree
+    const Node::child_iterator begin = node.m_children.begin();
+    const Node::child_iterator end = node.m_children.end();
+    for (Node::child_iterator i = begin; end != i; ++i) {
+
+        isLastChild = (end == i + 1);
+
+        if (begin == i)
+            branches.push_back(!isLastChild);
+        else
+            branches.back() = !isLastChild;
+
+        static const bool isNodeLine = false;
+        const QByteArray buffer = branchBuffer(branches, isNodeLine, false);
+        qDebug() << buffer.constData();
+
+        dumpRecursive(**i, branches, isLastChild);
+    }
+}
+
+void QVisitorPrivate::dumpNode
+    (const Node& node, const QList<bool>& branches, bool isLastChild)
+{
+    const QList<QByteArray>::const_iterator
+        begin = node.m_annotation.begin(), end = node.m_annotation.end();
+
+    if (begin == end) {
+        // No annotations - just dump the object pointer
+        const bool isNodeLine = true;
+        QByteArray buffer = branchBuffer(branches, isNodeLine, isLastChild);
+        qDebug() << 0; // TODO
+    }
+    else {
+        // Dump annotations
+        for (QList<QByteArray>::const_iterator i = begin; end != i; ++i) {
+            const bool isNodeLine = (begin == i);
+            QByteArray buffer = branchBuffer(branches, isNodeLine, isLastChild);
+            buffer.append(*i);
+            qDebug() << buffer.constData();
+        }
+    }
+}
+
+
+// QVisitorPrivate::Node
+
+QVisitorPrivate::Node::Node()
+{
+
+}
+
+QVisitorPrivate::Node::~Node()
+{
+    Node* child;
+    foreach(child, m_children)
+        delete child;
+}
+
+
+// QVisitor
+
+QVisitor::QVisitor()
+    : d_ptr(new QVisitorPrivate)
+{
+
+}
+
+QVisitor::~QVisitor()
+{
+
+}
+
+void QVisitor::setPrefix(const QString& prefix)
+{
+    d_func()->setPrefix(prefix);
+}
+
+void QVisitor::setIndent(unsigned indent)
+{
+    d_func()->setIndent(indent);
+}
+
+void QVisitor::addAnnotator(QAnnotator* annotator)
+{
+    d_func()->addAnnotator(annotator);
+}
+
+void QVisitor::visitPrepare()
+{
+    // Do nothing
+}
+
+void QVisitor::visitNode(const QObject& object)
+{
+    d_func()->visitNode(object);
+}
+
+void QVisitor::visitComplete()
+{
+    d_func()->visitComplete();
+}
+
+
+//-----------------------------------------------------------------------------
+// Utility functions
+//-----------------------------------------------------------------------------
+
+void addDefaultAnnotators_sys(QDumper& visitor);
+void addDefaultAnnotators_sys(QVisitor& visitor);
+
+void addDefaultAnnotators(QDumper& dumper)
+{
+    dumper.addAnnotator(new QAnnotatorBasic);
+    dumper.addAnnotator(new QAnnotatorWidget);
+
+    // Add platform-specific annotators
+    addDefaultAnnotators_sys(dumper);
+}
+
+void addDefaultAnnotators(QVisitor& visitor)
+{
+    visitor.addAnnotator(new QAnnotatorBasic);
+    visitor.addAnnotator(new QAnnotatorWidget);
+
+    // Add platform-specific annotators
+    addDefaultAnnotators_sys(visitor);
+}
+
+void dumpTreeFromRoot(const QObject& root, QVisitor& visitor)
+{
+    // Set up iteration range
+    ObjectTree::DepthFirstConstIterator begin(root), end;
+
+    // Invoke generic visitor algorithm
+    ObjectTree::visit(begin, end, visitor);
+}
+
+void dumpTreeFromLeaf(const QObject& leaf, QVisitor& visitor)
+{
+    // Walk up to root
+    const QObject* root = &leaf;
+    while(root->parent())
+    {
+        root = root->parent();
+    }
+
+    dumpTreeFromRoot(*root, visitor);
+}
+
+void dumpAncestors(const QObject& leaf, QVisitor& visitor)
+{
+    // Set up iteration range
+    ObjectTree::AncestorConstIterator begin(leaf), end;
+
+    // Invoke generic visitor algorithm
+    ObjectTree::visit(begin, end, visitor);
+}
+
+
+} // namespace ObjectDump
+
+QT_END_NAMESPACE
+
+
+
diff --git a/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump.h b/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump.h
new file mode 100644
index 0000000..e94b3ac
--- /dev/null
+++ b/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump.h
@@ -0,0 +1,166 @@
+/*  This file is part of the KDE project.
+
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+This library is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 or 3 of the License.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef OBJECTDUMP_H
+#define OBJECTDUMP_H
+
+#include "objectdump_global.h"
+
+#include <QObject>
+#include <QList>
+#include <QByteArray>
+#include <QScopedPointer>
+
+QT_BEGIN_NAMESPACE
+
+namespace ObjectDump
+{
+
+/**
+ * Abstract base for annotator classes invoked by QVisitor.
+ */
+class OBJECTDUMP_EXPORT QAnnotator : public QObject
+{
+    Q_OBJECT
+public:
+    virtual ~QAnnotator();
+    virtual QList<QByteArray> annotation(const QObject& object) = 0;
+};
+
+/**
+ * Annotator which replicates QObject::dumpObjectTree functionality.
+ */
+class OBJECTDUMP_EXPORT QAnnotatorBasic : public QAnnotator
+{
+    Q_OBJECT
+public:
+    QList<QByteArray> annotation(const QObject& object);
+};
+
+/**
+ * Annotator which returns widget information.
+ */
+class OBJECTDUMP_EXPORT QAnnotatorWidget : public QAnnotator
+{
+    Q_OBJECT
+public:
+    QList<QByteArray> annotation(const QObject& object);
+};
+
+
+class QDumperPrivate;
+
+/**
+ * Class used to dump information about individual QObjects.
+ */
+class OBJECTDUMP_EXPORT QDumper : public QObject
+{
+    Q_OBJECT
+    Q_DECLARE_PRIVATE(QDumper)
+
+public:
+    QDumper();
+    ~QDumper();
+
+    /**
+     * Specify a prefix, to be printed on each line of output.
+     */
+    void setPrefix(const QString& prefix);
+
+    /**
+     * Takes ownership of annotator.
+     */
+    void addAnnotator(QAnnotator* annotator);
+
+    /**
+     * Invoke each annotator on the object and write to debug output.
+     */
+    void dumpObject(const QObject& object);
+
+private:
+    QScopedPointer<QDumperPrivate> d_ptr;
+
+};
+
+
+class QVisitorPrivate;
+
+/**
+ * Visitor class which dumps information about nodes in the object tree.
+ */
+class OBJECTDUMP_EXPORT QVisitor : public QObject
+{
+    Q_OBJECT
+    Q_DECLARE_PRIVATE(QVisitor)
+
+public:
+    QVisitor();
+    ~QVisitor();
+
+    /**
+     * Specify a prefix, to be printed on each line of output.
+     */
+    void setPrefix(const QString& prefix);
+
+    /**
+     * Set number of spaces by which each level of the tree is indented.
+     */
+    void setIndent(unsigned indent);
+
+    /**
+     * Called by the visitor algorithm before starting the visit.
+     */
+    void visitPrepare();
+
+    /**
+     * Called by the visitor algorithm as each node is visited.
+     */
+    void visitNode(const QObject& object);
+
+    /**
+     * Called by the visitor algorithm when the visit is complete.
+     */
+    void visitComplete();
+
+    /**
+     * Takes ownership of annotator.
+     */
+    void addAnnotator(QAnnotator* annotator);
+
+private:
+    QScopedPointer<QVisitorPrivate> d_ptr;
+
+};
+
+
+//-----------------------------------------------------------------------------
+// Utility functions
+//-----------------------------------------------------------------------------
+
+void OBJECTDUMP_EXPORT addDefaultAnnotators(QDumper& dumper);
+void OBJECTDUMP_EXPORT addDefaultAnnotators(QVisitor& visitor);
+
+void OBJECTDUMP_EXPORT dumpTreeFromRoot(const QObject& root, QVisitor& visitor);
+void OBJECTDUMP_EXPORT dumpTreeFromLeaf(const QObject& leaf, QVisitor& visitor);
+void OBJECTDUMP_EXPORT dumpAncestors(const QObject& leaf, QVisitor& visitor);
+
+} // namespace ObjectDump
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump_global.h b/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump_global.h
new file mode 100644
index 0000000..b8987e0
--- /dev/null
+++ b/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump_global.h
@@ -0,0 +1,30 @@
+/*  This file is part of the KDE project.
+
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+This library is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 or 3 of the License.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef OBJECTDUMP_GLOBAL_H
+#define OBJECTDUMP_GLOBAL_H
+
+#include <QtCore/QtGlobal>
+
+#if defined(OBJECTDUMP_LIBRARY)
+#  define OBJECTDUMP_EXPORT
+#else
+#  define OBJECTDUMP_EXPORT
+#endif
+
+#endif
diff --git a/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump_stub.cpp b/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump_stub.cpp
new file mode 100644
index 0000000..6207dac
--- /dev/null
+++ b/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump_stub.cpp
@@ -0,0 +1,40 @@
+/*  This file is part of the KDE project.
+
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+This library is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 or 3 of the License.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "objectdump.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace ObjectDump
+{
+
+void addDefaultAnnotators_sys(QDumper& /*dumper*/)
+{
+
+}
+
+void addDefaultAnnotators_sys(QVisitor& /*visitor*/)
+{
+
+}
+
+} // namespace ObjectDump
+
+QT_END_NAMESPACE
+
+
diff --git a/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump_symbian.cpp b/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump_symbian.cpp
new file mode 100644
index 0000000..03220a7
--- /dev/null
+++ b/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump_symbian.cpp
@@ -0,0 +1,168 @@
+/*  This file is part of the KDE project.
+
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+This library is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 or 3 of the License.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include <QTextStream>
+#include <QWidget>
+#include <coecntrl.h>
+#include "objectdump_symbian.h"
+
+#include <QtGui/private/qwidget_p.h> // to access QWExtra
+
+QT_BEGIN_NAMESPACE
+
+namespace ObjectDump
+{
+namespace Symbian
+{
+
+QList<QByteArray> QAnnotatorWidget::annotation(const QObject& object)
+{
+    QList<QByteArray> result;
+
+    const QWidget* widget = qobject_cast<const QWidget*>(&object);
+    if (widget) {
+
+        const QWExtra* extra = qt_widget_private(const_cast<QWidget *>(widget))->extraData();
+
+        if (extra) {
+
+            QByteArray array;
+            QTextStream stream(&array);
+
+            stream << "widget (Symbian): ";
+            stream << "activated " << extra->activated << ' ';
+            stream << "disableBlit " << extra->disableBlit << ' ';
+
+            stream.flush();
+            result.append(array);
+        }
+    }
+
+    return result;
+}
+
+QList<QByteArray> QAnnotatorControl::annotation(const QObject& object)
+{
+    QList<QByteArray> result;
+
+    const QWidget* widget = qobject_cast<const QWidget*>(&object);
+    if (widget) {
+
+        const CCoeControl* control = widget->effectiveWinId();
+        if (control) {
+
+            QByteArray array;
+            QTextStream stream(&array);
+
+            stream << "control: " << control << ' ';
+            stream << "parent " << control->Parent() << ' ';
+
+            if (control->IsVisible())
+                stream << "visible ";
+            else
+                stream << "invisible ";
+
+            stream << control->Position().iX << ',' << control->Position().iY << ' ';
+            stream << control->Size().iWidth << 'x' << control->Size().iHeight;
+
+            if (control->OwnsWindow())
+                stream << " ownsWindow ";
+
+            stream.flush();
+            result.append(array);
+        }
+    }
+
+    return result;
+}
+
+QList<QByteArray> QAnnotatorWindow::annotation(const QObject& object)
+{
+    QList<QByteArray> result;
+
+    const QWidget* widget = qobject_cast<const QWidget*>(&object);
+    if (widget) {
+
+        const CCoeControl* control = widget->effectiveWinId();
+        RDrawableWindow *window = 0;
+
+        if (control && (window = control->DrawableWindow())) {
+
+            QByteArray array;
+            QTextStream stream(&array);
+
+            stream << "window: ";
+
+            // ClientHandle() is available first in 5.0.
+#if !defined(__SERIES60_31__) && !defined(__S60_32__)
+            if (QSysInfo::s60Version() > QSysInfo::SV_S60_3_2)
+                // Client-side window handle
+                // Cast to a void pointer so that log output is in hexadecimal format.
+                stream << "cli " << reinterpret_cast<const void*>(window->ClientHandle()) << ' ';
+#endif
+
+            // Server-side address of CWsWindow object
+            // This is useful for correlation with the window tree dumped by the window
+            // server (see RWsSession::LogCommand).
+            // Cast to a void pointer so that log output is in hexadecimal format.
+            stream << "srv " << reinterpret_cast<const void*>(window->WsHandle()) << ' ';
+
+            stream << "group " << window->WindowGroupId() << ' ';
+
+            // Client-side handle to the parent window.
+            // Cast to a void pointer so that log output is in hexadecimal format.
+            stream << "parent " << reinterpret_cast<const void*>(window->Parent()) << ' ';
+
+            stream << window->Position().iX << ',' << window->Position().iY << ' ';
+            stream << '(' << window->AbsPosition().iX << ',' << window->AbsPosition().iY << ") ";
+            stream << window->Size().iWidth << 'x' << window->Size().iHeight << ' ';
+
+            const TDisplayMode displayMode = window->DisplayMode();
+            stream << "mode " << displayMode << ' ';
+
+            stream << "ord " << window->OrdinalPosition();
+
+            stream.flush();
+            result.append(array);
+        }
+    }
+
+    return result;
+}
+
+} // namespace Symbian
+
+void addDefaultAnnotators_sys(QDumper& dumper)
+{
+    dumper.addAnnotator(new Symbian::QAnnotatorWidget);
+    dumper.addAnnotator(new Symbian::QAnnotatorControl);
+    dumper.addAnnotator(new Symbian::QAnnotatorWindow);
+}
+
+void addDefaultAnnotators_sys(QVisitor& visitor)
+{
+    visitor.addAnnotator(new Symbian::QAnnotatorWidget);
+    visitor.addAnnotator(new Symbian::QAnnotatorControl);
+    visitor.addAnnotator(new Symbian::QAnnotatorWindow);
+}
+
+} // namespace ObjectDump
+
+QT_END_NAMESPACE
+
+
diff --git a/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump_symbian.h b/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump_symbian.h
new file mode 100644
index 0000000..563c862
--- /dev/null
+++ b/src/3rdparty/phonon/mmf/mmfphonondebug/objectdump_symbian.h
@@ -0,0 +1,66 @@
+/*  This file is part of the KDE project.
+
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+This library is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 or 3 of the License.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef OBJECTDUMP_SYMBIAN_H
+#define OBJECTDUMP_SYMBIAN_H
+
+#include "objectdump.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace ObjectDump
+{
+namespace Symbian
+{
+
+/**
+ * Annotator which returns Symbian-specific widget information
+ */
+class QAnnotatorWidget : public QAnnotator
+{
+    Q_OBJECT
+public:
+    QList<QByteArray> annotation(const QObject& object);
+};
+
+/**
+ * Annotator which returns control information
+ */
+class QAnnotatorControl : public QAnnotator
+{
+    Q_OBJECT
+public:
+    QList<QByteArray> annotation(const QObject& object);
+};
+
+/**
+ * Annotator which returns window information
+ */
+class QAnnotatorWindow : public QAnnotator
+{
+    Q_OBJECT
+public:
+    QList<QByteArray> annotation(const QObject& object);
+};
+
+} // namespace Symbian
+} // namespace ObjectDump
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/3rdparty/phonon/mmf/mmfphonondebug/objecttree.cpp b/src/3rdparty/phonon/mmf/mmfphonondebug/objecttree.cpp
new file mode 100644
index 0000000..bc61435
--- /dev/null
+++ b/src/3rdparty/phonon/mmf/mmfphonondebug/objecttree.cpp
@@ -0,0 +1,102 @@
+/*  This file is part of the KDE project.
+
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+This library is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 or 3 of the License.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include <QTextStream>
+#include <QWidget>
+#include "objecttree.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace ObjectTree
+{
+
+DepthFirstConstIterator::DepthFirstConstIterator()
+    :   m_pointee(0)
+{
+
+}
+
+DepthFirstConstIterator::DepthFirstConstIterator
+    (const QObject& root)
+    :   m_pointee(&root)
+{
+
+}
+
+DepthFirstConstIterator&
+    DepthFirstConstIterator::operator++()
+{
+    const QObjectList& children = m_pointee->children();
+
+    if (children.count() == 0) {
+        backtrack();
+    }
+    else {
+        m_history.push(0);
+        m_pointee = children.first();
+    }
+
+    return *this;
+}
+
+void DepthFirstConstIterator::backtrack()
+{
+    if (m_history.count()) {
+        const int index = m_history.top();
+        m_history.pop();
+
+        const QObjectList& siblings = m_pointee->parent()->children();
+        if (siblings.count() > index + 1) {
+            m_history.push(index + 1);
+            m_pointee = siblings[index + 1];
+        }
+        else {
+            m_pointee = m_pointee->parent();
+            backtrack();
+        }
+    }
+    else {
+        // Reached end of search
+        m_pointee = 0;
+    }
+}
+
+
+
+AncestorConstIterator::AncestorConstIterator()
+{
+
+}
+
+AncestorConstIterator::AncestorConstIterator(const QObject& leaf)
+{
+    m_ancestors.push(&leaf);
+    QObject* ancestor = leaf.parent();
+    while(ancestor)
+    {
+        m_ancestors.push(ancestor);
+        ancestor = ancestor->parent();
+    }
+}
+
+} // namespace ObjectTree
+
+QT_END_NAMESPACE
+
+
+
diff --git a/src/3rdparty/phonon/mmf/mmfphonondebug/objecttree.h b/src/3rdparty/phonon/mmf/mmfphonondebug/objecttree.h
new file mode 100644
index 0000000..98bdf14
--- /dev/null
+++ b/src/3rdparty/phonon/mmf/mmfphonondebug/objecttree.h
@@ -0,0 +1,117 @@
+/*  This file is part of the KDE project.
+
+Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+This library is free software: you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation, either version 2.1 or 3 of the License.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef OBJECTTREE_H
+#define OBJECTTREE_H
+
+#include "objectdump_global.h"
+
+#include <QObject>
+#include <QStack>
+
+QT_BEGIN_NAMESPACE
+
+namespace ObjectTree
+{
+
+/**
+ * Depth-first iterator for QObject tree
+ */
+class OBJECTDUMP_EXPORT DepthFirstConstIterator
+{
+public:
+    DepthFirstConstIterator();
+    DepthFirstConstIterator(const QObject& root);
+
+    DepthFirstConstIterator& operator++();
+
+    inline bool operator==(const DepthFirstConstIterator& other) const
+    { return other.m_pointee == m_pointee; }
+
+    inline bool operator!=(const DepthFirstConstIterator& other) const
+    { return other.m_pointee != m_pointee; }
+
+    inline const QObject* operator->() const { return m_pointee; }
+    inline const QObject& operator*() const { return *m_pointee; }
+
+private:
+    void backtrack();
+
+private:
+    const QObject* m_pointee;
+    QStack<int> m_history;
+};
+
+/**
+ * Ancestor iterator for QObject tree
+ */
+class OBJECTDUMP_EXPORT AncestorConstIterator
+{
+public:
+    AncestorConstIterator();
+    AncestorConstIterator(const QObject& root);
+
+    inline AncestorConstIterator& operator++()
+    { m_ancestors.pop(); return *this; }
+
+    inline bool operator==(const AncestorConstIterator& other) const
+    { return other.m_ancestors == m_ancestors; }
+
+    inline bool operator!=(const AncestorConstIterator& other) const
+    { return other.m_ancestors != m_ancestors; }
+
+    inline const QObject* operator->() const { return m_ancestors.top(); }
+    inline const QObject& operator*() const { return *m_ancestors.top(); }
+
+private:
+    QStack<const QObject*> m_ancestors;
+
+};
+
+/**
+ * Generic algorithm for visiting nodes in an object tree.  Nodes in the
+ * tree are visited in a const context, therefore they are not modified
+ * by this algorithm.
+ *
+ * Visitor must provide functions with the following signatures:
+ *
+ *      Called before visit begins
+ *          void visitPrepare()
+ *
+ *      Called on each node visited
+ *          void visitNode(const QObject& object)
+ *
+ *      Called when visit is complete
+ *          void visitComplete()
+ */
+template <class Iterator, class Visitor>
+void visit(Iterator begin, Iterator end, Visitor& visitor)
+{
+    visitor.visitPrepare();
+
+    for ( ; begin != end; ++begin)
+        visitor.visitNode(*begin);
+
+    visitor.visitComplete();
+}
+
+} // namespace ObjectTree
+
+QT_END_NAMESPACE
+
+#endif // OBJECTTREE_H
diff --git a/src/3rdparty/phonon/mmf/objectdump.cpp b/src/3rdparty/phonon/mmf/objectdump.cpp
deleted file mode 100644
index 3d10be4..0000000
--- a/src/3rdparty/phonon/mmf/objectdump.cpp
+++ /dev/null
@@ -1,525 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include <QByteArray>
-#include <QDebug>
-#include <QHash>
-#include <QTextStream>
-#include <QWidget>
-
-#include "objectdump.h"
-#include "objecttree.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace ObjectDump
-{
-
-//-----------------------------------------------------------------------------
-// QObjectAnnotator
-//-----------------------------------------------------------------------------
-
-QAnnotator::~QAnnotator()
-{
-
-}
-
-
-//-----------------------------------------------------------------------------
-// Annotators
-//-----------------------------------------------------------------------------
-
-QList<QByteArray> QAnnotatorBasic::annotation(const QObject& object)
-{
-    QList<QByteArray> result;
-
-    QByteArray array;
-    QTextStream stream(&array);
-
-    stream << '[' << &object << ']';
-    stream << ' ';
-    stream << object.metaObject()->className();
-
-    if (object.objectName() != "")
-        stream << " \"" << object.objectName() << '"';
-
-    if (object.isWidgetType())
-        stream << " isWidget";
-
-    stream.flush();
-    result.append(array);
-    return result;
-}
-
-QList<QByteArray> QAnnotatorWidget::annotation(const QObject& object)
-{
-    QList<QByteArray> result;
-
-    const QWidget* widget = qobject_cast<const QWidget*>(&object);
-    if (widget) {
-
-        QByteArray array;
-        QTextStream stream(&array);
-
-        stream << "widget: ";
-
-        if (widget->isVisible())
-            stream << "visible ";
-        else
-            stream << "invisible ";
-
-        stream << widget->x() << ',' << widget->y() << ' ';
-        stream << widget->size().width() << 'x'<< widget->size().height() << ' ';
-
-        stream << "hint " << widget->sizeHint().width() << 'x' << widget->sizeHint().height();
-
-        stream.flush();
-        result.append(array);
-    }
-
-    return result;
-}
-
-
-//-----------------------------------------------------------------------------
-// Base class for QDumperPrivate, QVisitorPrivate
-//-----------------------------------------------------------------------------
-
-class QDumperBase
-{
-public:
-    QDumperBase();
-    ~QDumperBase();
-
-    void setPrefix(const QString& prefix);
-    void addAnnotator(QAnnotator* annotator);
-
-protected:
-    QByteArray m_prefix;
-    QList<QAnnotator*> m_annotators;
-
-};
-
-QDumperBase::QDumperBase()
-{
-
-}
-
-QDumperBase::~QDumperBase()
-{
-    QAnnotator* annotator;
-    foreach(annotator, m_annotators)
-        delete annotator;
-}
-
-void QDumperBase::setPrefix(const QString& prefix)
-{
-    m_prefix = prefix.count()
-        ? (prefix + " ").toAscii()
-        : prefix.toAscii();
-}
-
-void QDumperBase::addAnnotator(QAnnotator* annotator)
-{
-    // Protect against an exception occurring during QList::append
-    QScopedPointer<QAnnotator> holder(annotator);
-    m_annotators.append(annotator);
-    holder.take();
-}
-
-
-//-----------------------------------------------------------------------------
-// QDumper
-//-----------------------------------------------------------------------------
-
-class QDumperPrivate : public QDumperBase
-{
-public:
-    QDumperPrivate();
-    ~QDumperPrivate();
-
-    void dumpObject(const QObject& object);
-
-};
-
-
-QDumperPrivate::QDumperPrivate()
-{
-
-}
-
-QDumperPrivate::~QDumperPrivate()
-{
-
-}
-
-void QDumperPrivate::dumpObject(const QObject& object)
-{
-    QAnnotator* annotator;
-    foreach(annotator, m_annotators) {
-
-        const QList<QByteArray> annotations = annotator->annotation(object);
-        QByteArray annotation;
-        foreach(annotation, annotations) {
-            QByteArray buffer(m_prefix);
-            buffer.append(annotation);
-            qDebug() << buffer.constData();
-        }
-    }
-}
-
-
-QDumper::QDumper()
-    : d_ptr(new QDumperPrivate)
-{
-
-}
-
-QDumper::~QDumper()
-{
-
-}
-
-void QDumper::setPrefix(const QString& prefix)
-{
-    d_func()->setPrefix(prefix);
-}
-
-void QDumper::addAnnotator(QAnnotator* annotator)
-{
-    d_func()->addAnnotator(annotator);
-}
-
-void QDumper::dumpObject(const QObject& object)
-{
-    d_func()->dumpObject(object);
-}
-
-
-//-----------------------------------------------------------------------------
-// QVisitor
-//-----------------------------------------------------------------------------
-
-class QVisitorPrivate : public QDumperBase
-{
-public:
-    QVisitorPrivate();
-    ~QVisitorPrivate();
-
-    void setIndent(unsigned indent);
-
-    void visitNode(const QObject& object);
-    void visitComplete();
-
-private:
-    class Node
-    {
-    public:
-        Node();
-        ~Node();
-
-        QList<QByteArray>   m_annotation;
-        QList<Node*>        m_children;
-
-        typedef QList<Node*>::const_iterator child_iterator;
-    };
-
-private:
-    Node* findNode(const QObject* object) const;
-    QByteArray branchBuffer(const QList<bool>& branches, bool isNodeLine, bool isLastChild) const;
-    void dumpRecursive(const Node& node, QList<bool> branches, bool isLastChild);
-    void dumpNode(const Node& node, const QList<bool>& branches, bool isLastChild);
-
-private:
-    unsigned m_indent;
-
-    QScopedPointer<Node> m_root;
-
-    // Hash table used to associate internal nodes with QObjects
-    typedef QHash<const QObject*, Node*> Hash;
-    Hash m_hash;
-};
-
-static const unsigned DefaultIndent = 2;
-
-QVisitorPrivate::QVisitorPrivate()
-    :   m_indent(DefaultIndent)
-{
-
-}
-
-QVisitorPrivate::~QVisitorPrivate()
-{
-
-}
-
-void QVisitorPrivate::setIndent(unsigned indent)
-{
-    m_indent = indent;
-}
-
-// Builds up a mirror of the object tree, rooted in m_root, with each node
-// storing annotations generated by
-void QVisitorPrivate::visitNode(const QObject& object)
-{
-    QObject* const objectParent = object.parent();
-    Node* const nodeParent = objectParent ? findNode(objectParent) : 0;
-
-    // Create a new node and store in scoped pointer for exception safety
-    Node* node = new Node;
-    QScopedPointer<Node> nodePtr(node);
-
-    // Associate node with QObject
-    m_hash.insert(&object, node);
-
-    // Insert node into internal tree
-    if (nodeParent)
-    {
-        nodeParent->m_children.append(nodePtr.take());
-    }
-    else
-    {
-        Q_ASSERT(m_root.isNull());
-        m_root.reset(nodePtr.take());
-    }
-
-    // Generate and store annotations
-    QAnnotator* annotator;
-    foreach(annotator, m_annotators)
-        node->m_annotation.append( annotator->annotation(object) );
-}
-
-void QVisitorPrivate::visitComplete()
-{
-    QList<bool> branches;
-    static const bool isLastChild = true;
-    dumpRecursive(*m_root, branches, isLastChild);
-    m_root.reset(0);
-}
-
-QVisitorPrivate::Node* QVisitorPrivate::findNode(const QObject* object) const
-{
-    Hash::const_iterator i = m_hash.find(object);
-    return (m_hash.end() == i) ? 0 : *i;
-}
-
-QByteArray QVisitorPrivate::branchBuffer
-    (const QList<bool>& branches, bool isNodeLine, bool isLastChild) const
-{
-    const int depth = branches.count();
-
-    const QByteArray indent(m_indent, ' ');
-    const QByteArray horiz(m_indent, '-');
-
-    QByteArray buffer;
-    QTextStream stream(&buffer);
-
-    for (int i=0; i<depth-1; ++i) {
-        if (branches[i])
-            stream << '|';
-        else
-            stream << ' ';
-        stream << indent;
-    }
-
-    if (depth) {
-        if (isNodeLine)
-            stream << '+' << horiz;
-        else {
-            if (!isLastChild)
-                stream << '|';
-            else
-                stream << ' ';
-            stream << indent;
-        }
-    }
-
-    stream.flush();
-    buffer.push_front(m_prefix);
-
-    return buffer;
-}
-
-void QVisitorPrivate::dumpRecursive
-    (const Node& node, QList<bool> branches, bool isLastChild)
-{
-    dumpNode(node, branches, isLastChild);
-
-    // Recurse down tree
-    const Node::child_iterator begin = node.m_children.begin();
-    const Node::child_iterator end = node.m_children.end();
-    for (Node::child_iterator i = begin; end != i; ++i) {
-
-        isLastChild = (end == i + 1);
-
-        if (begin == i)
-            branches.push_back(!isLastChild);
-        else
-            branches.back() = !isLastChild;
-
-        static const bool isNodeLine = false;
-        const QByteArray buffer = branchBuffer(branches, isNodeLine, false);
-        qDebug() << buffer.constData();
-
-        dumpRecursive(**i, branches, isLastChild);
-    }
-}
-
-void QVisitorPrivate::dumpNode
-    (const Node& node, const QList<bool>& branches, bool isLastChild)
-{
-    const QList<QByteArray>::const_iterator
-        begin = node.m_annotation.begin(), end = node.m_annotation.end();
-
-    if (begin == end) {
-        // No annotations - just dump the object pointer
-        const bool isNodeLine = true;
-        QByteArray buffer = branchBuffer(branches, isNodeLine, isLastChild);
-        qDebug() << 0; // TODO
-    }
-    else {
-        // Dump annotations
-        for (QList<QByteArray>::const_iterator i = begin; end != i; ++i) {
-            const bool isNodeLine = (begin == i);
-            QByteArray buffer = branchBuffer(branches, isNodeLine, isLastChild);
-            buffer.append(*i);
-            qDebug() << buffer.constData();
-        }
-    }
-}
-
-
-// QVisitorPrivate::Node
-
-QVisitorPrivate::Node::Node()
-{
-
-}
-
-QVisitorPrivate::Node::~Node()
-{
-    Node* child;
-    foreach(child, m_children)
-        delete child;
-}
-
-
-// QVisitor
-
-QVisitor::QVisitor()
-    : d_ptr(new QVisitorPrivate)
-{
-
-}
-
-QVisitor::~QVisitor()
-{
-
-}
-
-void QVisitor::setPrefix(const QString& prefix)
-{
-    d_func()->setPrefix(prefix);
-}
-
-void QVisitor::setIndent(unsigned indent)
-{
-    d_func()->setIndent(indent);
-}
-
-void QVisitor::addAnnotator(QAnnotator* annotator)
-{
-    d_func()->addAnnotator(annotator);
-}
-
-void QVisitor::visitPrepare()
-{
-    // Do nothing
-}
-
-void QVisitor::visitNode(const QObject& object)
-{
-    d_func()->visitNode(object);
-}
-
-void QVisitor::visitComplete()
-{
-    d_func()->visitComplete();
-}
-
-
-//-----------------------------------------------------------------------------
-// Utility functions
-//-----------------------------------------------------------------------------
-
-void addDefaultAnnotators_sys(QDumper& visitor);
-void addDefaultAnnotators_sys(QVisitor& visitor);
-
-void addDefaultAnnotators(QDumper& dumper)
-{
-    dumper.addAnnotator(new QAnnotatorBasic);
-    dumper.addAnnotator(new QAnnotatorWidget);
-
-    // Add platform-specific annotators
-    addDefaultAnnotators_sys(dumper);
-}
-
-void addDefaultAnnotators(QVisitor& visitor)
-{
-    visitor.addAnnotator(new QAnnotatorBasic);
-    visitor.addAnnotator(new QAnnotatorWidget);
-
-    // Add platform-specific annotators
-    addDefaultAnnotators_sys(visitor);
-}
-
-void dumpTreeFromRoot(const QObject& root, QVisitor& visitor)
-{
-    // Set up iteration range
-    ObjectTree::DepthFirstConstIterator begin(root), end;
-
-    // Invoke generic visitor algorithm
-    ObjectTree::visit(begin, end, visitor);
-}
-
-void dumpTreeFromLeaf(const QObject& leaf, QVisitor& visitor)
-{
-    // Walk up to root
-    const QObject* root = &leaf;
-    while(root->parent())
-    {
-        root = root->parent();
-    }
-
-    dumpTreeFromRoot(*root, visitor);
-}
-
-void dumpAncestors(const QObject& leaf, QVisitor& visitor)
-{
-    // Set up iteration range
-    ObjectTree::AncestorConstIterator begin(leaf), end;
-
-    // Invoke generic visitor algorithm
-    ObjectTree::visit(begin, end, visitor);
-}
-
-
-} // namespace ObjectDump
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/objectdump.h b/src/3rdparty/phonon/mmf/objectdump.h
deleted file mode 100644
index 86aeaba..0000000
--- a/src/3rdparty/phonon/mmf/objectdump.h
+++ /dev/null
@@ -1,164 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef OBJECTDUMP_H
-#define OBJECTDUMP_H
-
-#include <QObject>
-#include <QList>
-#include <QByteArray>
-#include <QScopedPointer>
-
-QT_BEGIN_NAMESPACE
-
-namespace ObjectDump
-{
-
-/**
- * Abstract base for annotator classes invoked by QVisitor.
- */
-class QAnnotator : public QObject
-{
-    Q_OBJECT
-public:
-    virtual ~QAnnotator();
-    virtual QList<QByteArray> annotation(const QObject& object) = 0;
-};
-
-/**
- * Annotator which replicates QObject::dumpObjectTree functionality.
- */
-class QAnnotatorBasic : public QAnnotator
-{
-    Q_OBJECT
-public:
-    QList<QByteArray> annotation(const QObject& object);
-};
-
-/**
- * Annotator which returns widget information.
- */
-class QAnnotatorWidget : public QAnnotator
-{
-    Q_OBJECT
-public:
-    QList<QByteArray> annotation(const QObject& object);
-};
-
-
-class QDumperPrivate;
-
-/**
- * Class used to dump information about individual QObjects.
- */
-class QDumper : public QObject
-{
-    Q_OBJECT
-    Q_DECLARE_PRIVATE(QDumper)
-
-public:
-    QDumper();
-    ~QDumper();
-
-    /**
-     * Specify a prefix, to be printed on each line of output.
-     */
-    void setPrefix(const QString& prefix);
-
-    /**
-     * Takes ownership of annotator.
-     */
-    void addAnnotator(QAnnotator* annotator);
-
-    /**
-     * Invoke each annotator on the object and write to debug output.
-     */
-    void dumpObject(const QObject& object);
-
-private:
-    QScopedPointer<QDumperPrivate> d_ptr;
-
-};
-
-
-class QVisitorPrivate;
-
-/**
- * Visitor class which dumps information about nodes in the object tree.
- */
-class QVisitor : public QObject
-{
-    Q_OBJECT
-    Q_DECLARE_PRIVATE(QVisitor)
-
-public:
-    QVisitor();
-    ~QVisitor();
-
-    /**
-     * Specify a prefix, to be printed on each line of output.
-     */
-    void setPrefix(const QString& prefix);
-
-    /**
-     * Set number of spaces by which each level of the tree is indented.
-     */
-    void setIndent(unsigned indent);
-
-    /**
-     * Called by the visitor algorithm before starting the visit.
-     */
-    void visitPrepare();
-
-    /**
-     * Called by the visitor algorithm as each node is visited.
-     */
-    void visitNode(const QObject& object);
-
-    /**
-     * Called by the visitor algorithm when the visit is complete.
-     */
-    void visitComplete();
-
-    /**
-     * Takes ownership of annotator.
-     */
-    void addAnnotator(QAnnotator* annotator);
-
-private:
-    QScopedPointer<QVisitorPrivate> d_ptr;
-
-};
-
-
-//-----------------------------------------------------------------------------
-// Utility functions
-//-----------------------------------------------------------------------------
-
-void addDefaultAnnotators(QDumper& dumper);
-void addDefaultAnnotators(QVisitor& visitor);
-
-void dumpTreeFromRoot(const QObject& root, QVisitor& visitor);
-void dumpTreeFromLeaf(const QObject& leaf, QVisitor& visitor);
-void dumpAncestors(const QObject& leaf, QVisitor& visitor);
-
-} // namespace ObjectDump
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/3rdparty/phonon/mmf/objectdump_symbian.cpp b/src/3rdparty/phonon/mmf/objectdump_symbian.cpp
deleted file mode 100644
index d325658..0000000
--- a/src/3rdparty/phonon/mmf/objectdump_symbian.cpp
+++ /dev/null
@@ -1,159 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include <QTextStream>
-#include <QWidget>
-#include <coecntrl.h>
-#include "objectdump_symbian.h"
-
-#include <QtGui/private/qwidget_p.h> // to access QWExtra
-
-QT_BEGIN_NAMESPACE
-
-namespace ObjectDump
-{
-namespace Symbian
-{
-
-QList<QByteArray> QAnnotatorWidget::annotation(const QObject& object)
-{
-    QList<QByteArray> result;
-
-    const QWidget* widget = qobject_cast<const QWidget*>(&object);
-    if (widget) {
-
-        const QWExtra* extra = qt_widget_private(const_cast<QWidget *>(widget))->extraData();
-
-        if (extra) {
-
-            QByteArray array;
-            QTextStream stream(&array);
-
-            stream << "widget (Symbian): ";
-            stream << "activated " << extra->activated << ' ';
-            stream << "disableBlit " << extra->disableBlit << ' ';
-
-            stream.flush();
-            result.append(array);
-        }
-    }
-
-    return result;
-}
-
-QList<QByteArray> QAnnotatorControl::annotation(const QObject& object)
-{
-    QList<QByteArray> result;
-
-    const QWidget* widget = qobject_cast<const QWidget*>(&object);
-    if (widget) {
-
-        const CCoeControl* control = widget->effectiveWinId();
-        if (control) {
-
-            QByteArray array;
-            QTextStream stream(&array);
-
-            stream << "control: " << control << ' ';
-            stream << "parent " << control->Parent() << ' ';
-
-            if (control->IsVisible())
-                stream << "visible ";
-            else
-                stream << "invisible ";
-
-            stream << control->Position().iX << ',' << control->Position().iY << ' ';
-            stream << control->Size().iWidth << 'x' << control->Size().iHeight;
-
-            if (control->OwnsWindow())
-                stream << " ownsWindow ";
-
-            stream.flush();
-            result.append(array);
-        }
-    }
-
-    return result;
-}
-
-QList<QByteArray> QAnnotatorWindow::annotation(const QObject& object)
-{
-    QList<QByteArray> result;
-
-    const QWidget* widget = qobject_cast<const QWidget*>(&object);
-    if (widget) {
-
-        const CCoeControl* control = widget->effectiveWinId();
-        RDrawableWindow *window = 0;
-
-        if (control && (window = control->DrawableWindow())) {
-
-            QByteArray array;
-            QTextStream stream(&array);
-
-            stream << "window: ";
-
-            // Server-side address of CWsWindow object
-            // This is useful for correlation with the window tree dumped by the window
-            // server (see RWsSession::LogCommand).
-            // Cast to a void pointer so that log output is in hexadecimal format.
-            stream << "srv " << reinterpret_cast<const void*>(window->WsHandle()) << ' ';
-
-            stream << "group " << window->WindowGroupId() << ' ';
-
-            // Client-side handle to the parent window.
-            // Cast to a void pointer so that log output is in hexadecimal format.
-            stream << "parent " << reinterpret_cast<const void*>(window->Parent()) << ' ';
-
-            stream << window->Position().iX << ',' << window->Position().iY << ' ';
-            stream << '(' << window->AbsPosition().iX << ',' << window->AbsPosition().iY << ") ";
-            stream << window->Size().iWidth << 'x' << window->Size().iHeight << ' ';
-
-            const TDisplayMode displayMode = window->DisplayMode();
-            stream << "mode " << displayMode << ' ';
-
-            stream << "ord " << window->OrdinalPosition();
-
-            stream.flush();
-            result.append(array);
-        }
-    }
-
-    return result;
-}
-
-} // namespace Symbian
-
-void addDefaultAnnotators_sys(QDumper& dumper)
-{
-    dumper.addAnnotator(new Symbian::QAnnotatorWidget);
-    dumper.addAnnotator(new Symbian::QAnnotatorControl);
-    dumper.addAnnotator(new Symbian::QAnnotatorWindow);
-}
-
-void addDefaultAnnotators_sys(QVisitor& visitor)
-{
-    visitor.addAnnotator(new Symbian::QAnnotatorWidget);
-    visitor.addAnnotator(new Symbian::QAnnotatorControl);
-    visitor.addAnnotator(new Symbian::QAnnotatorWindow);
-}
-
-} // namespace ObjectDump
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/objectdump_symbian.h b/src/3rdparty/phonon/mmf/objectdump_symbian.h
deleted file mode 100644
index 563c862..0000000
--- a/src/3rdparty/phonon/mmf/objectdump_symbian.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef OBJECTDUMP_SYMBIAN_H
-#define OBJECTDUMP_SYMBIAN_H
-
-#include "objectdump.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace ObjectDump
-{
-namespace Symbian
-{
-
-/**
- * Annotator which returns Symbian-specific widget information
- */
-class QAnnotatorWidget : public QAnnotator
-{
-    Q_OBJECT
-public:
-    QList<QByteArray> annotation(const QObject& object);
-};
-
-/**
- * Annotator which returns control information
- */
-class QAnnotatorControl : public QAnnotator
-{
-    Q_OBJECT
-public:
-    QList<QByteArray> annotation(const QObject& object);
-};
-
-/**
- * Annotator which returns window information
- */
-class QAnnotatorWindow : public QAnnotator
-{
-    Q_OBJECT
-public:
-    QList<QByteArray> annotation(const QObject& object);
-};
-
-} // namespace Symbian
-} // namespace ObjectDump
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/3rdparty/phonon/mmf/objecttree.cpp b/src/3rdparty/phonon/mmf/objecttree.cpp
deleted file mode 100644
index 06b0ced..0000000
--- a/src/3rdparty/phonon/mmf/objecttree.cpp
+++ /dev/null
@@ -1,100 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#include <QTextStream>
-#include <QWidget>
-#include "objecttree.h"
-
-QT_BEGIN_NAMESPACE
-
-namespace ObjectTree
-{
-
-DepthFirstConstIterator::DepthFirstConstIterator()
-    :   m_pointee(0)
-{
-
-}
-
-DepthFirstConstIterator::DepthFirstConstIterator
-    (const QObject& root)
-    :   m_pointee(&root)
-{
-
-}
-
-DepthFirstConstIterator&
-    DepthFirstConstIterator::operator++()
-{
-    const QObjectList& children = m_pointee->children();
-
-    if (children.count() == 0) {
-        backtrack();
-    }
-    else {
-        m_history.push(0);
-        m_pointee = children.first();
-    }
-
-    return *this;
-}
-
-void DepthFirstConstIterator::backtrack()
-{
-    if (m_history.count()) {
-        const int index = m_history.top();
-        m_history.pop();
-
-        const QObjectList& siblings = m_pointee->parent()->children();
-        if (siblings.count() > index + 1) {
-            m_history.push(index + 1);
-            m_pointee = siblings[index + 1];
-        }
-        else {
-            m_pointee = m_pointee->parent();
-            backtrack();
-        }
-    }
-    else {
-        // Reached end of search
-        m_pointee = 0;
-    }
-}
-
-
-
-AncestorConstIterator::AncestorConstIterator()
-{
-
-}
-
-AncestorConstIterator::AncestorConstIterator(const QObject& leaf)
-{
-    m_ancestors.push(&leaf);
-    QObject* ancestor = leaf.parent();
-    while(ancestor)
-    {
-        m_ancestors.push(ancestor);
-        ancestor = ancestor->parent();
-    }
-}
-
-} // namespace ObjectTree
-
-QT_END_NAMESPACE
-
diff --git a/src/3rdparty/phonon/mmf/objecttree.h b/src/3rdparty/phonon/mmf/objecttree.h
deleted file mode 100644
index 96adb6f..0000000
--- a/src/3rdparty/phonon/mmf/objecttree.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/*  This file is part of the KDE project.
-
-Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
-
-This library is free software: you can redistribute it and/or modify
-it under the terms of the GNU Lesser General Public License as published by
-the Free Software Foundation, either version 2.1 or 3 of the License.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public License
-along with this library.  If not, see <http://www.gnu.org/licenses/>.
-
-*/
-
-#ifndef OBJECTTREE_H
-#define OBJECTTREE_H
-
-#include <QObject>
-#include <QStack>
-
-QT_BEGIN_NAMESPACE
-
-namespace ObjectTree
-{
-
-/**
- * Depth-first iterator for QObject tree
- */
-class DepthFirstConstIterator
-{
-public:
-    DepthFirstConstIterator();
-    DepthFirstConstIterator(const QObject& root);
-
-    DepthFirstConstIterator& operator++();
-
-    inline bool operator==(const DepthFirstConstIterator& other) const
-    { return other.m_pointee == m_pointee; }
-
-    inline bool operator!=(const DepthFirstConstIterator& other) const
-    { return other.m_pointee != m_pointee; }
-
-    inline const QObject* operator->() const { return m_pointee; }
-    inline const QObject& operator*() const { return *m_pointee; }
-
-private:
-    void backtrack();
-
-private:
-    const QObject* m_pointee;
-    QStack<int> m_history;
-};
-
-/**
- * Ancestor iterator for QObject tree
- */
-class AncestorConstIterator
-{
-public:
-    AncestorConstIterator();
-    AncestorConstIterator(const QObject& root);
-
-    inline AncestorConstIterator& operator++()
-    { m_ancestors.pop(); return *this; }
-
-    inline bool operator==(const AncestorConstIterator& other) const
-    { return other.m_ancestors == m_ancestors; }
-
-    inline bool operator!=(const AncestorConstIterator& other) const
-    { return other.m_ancestors != m_ancestors; }
-
-    inline const QObject* operator->() const { return m_ancestors.top(); }
-    inline const QObject& operator*() const { return *m_ancestors.top(); }
-
-private:
-    QStack<const QObject*> m_ancestors;
-
-};
-
-/**
- * Generic algorithm for visiting nodes in an object tree.  Nodes in the
- * tree are visited in a const context, therefore they are not modified
- * by this algorithm.
- *
- * Visitor must provide functions with the following signatures:
- *
- *      Called before visit begins
- *          void visitPrepare()
- *
- *      Called on each node visited
- *          void visitNode(const QObject& object)
- *
- *      Called when visit is complete
- *          void visitComplete()
- */
-template <class Iterator, class Visitor>
-void visit(Iterator begin, Iterator end, Visitor& visitor)
-{
-    visitor.visitPrepare();
-
-    for ( ; begin != end; ++begin)
-        visitor.visitNode(*begin);
-
-    visitor.visitComplete();
-}
-
-} // namespace ObjectTree
-
-QT_END_NAMESPACE
-
-#endif // OBJECTTREE_H
diff --git a/src/3rdparty/phonon/mmf/utils.cpp b/src/3rdparty/phonon/mmf/utils.cpp
index d728fcf..58d1ece 100644
--- a/src/3rdparty/phonon/mmf/utils.cpp
+++ b/src/3rdparty/phonon/mmf/utils.cpp
@@ -24,24 +24,16 @@ QT_BEGIN_NAMESPACE
 using namespace Phonon;
 using namespace Phonon::MMF;
 
-/*! \namespace Phonon::MMF::Utils
+/*! \namespace MMF::Utils
   \internal
 */
 
-/*! \class Phonon::MMF::TTraceContext
+/*! \class MMF::TTraceContext
   \internal
 */
 
-/*! \enum Phonon::MMF::PanicCode
- \internal
-*/
-
-/*! \enum Phonon::MMF::TTraceCategory
- \internal
-*/
-
-/*! \enum Phonon::MMF::MediaType
- \internal
+/*! \class MMF::Utils
+  \internal
 */
 
 _LIT(PanicCategory, "Phonon::MMF");
diff --git a/src/3rdparty/phonon/phonon/CMakeLists.txt b/src/3rdparty/phonon/phonon/CMakeLists.txt
index 11d7913..8ce1914 100644
--- a/src/3rdparty/phonon/phonon/CMakeLists.txt
+++ b/src/3rdparty/phonon/phonon/CMakeLists.txt
@@ -8,6 +8,22 @@ endif (PHONON_BUILD_EXAMPLES)
 
 add_subdirectory(experimental)
 
+set(PULSEAUDIO_MINIMUM_VERSION "0.9.21")
+macro_optional_find_package(PulseAudio)
+macro_log_feature(PULSEAUDIO_FOUND "PulseAudio" "A cross-platform, networked sound server." "http://www.pulseaudio.org" FALSE "" "Allows audio playback via the PulseAudio soundserver when it is running")
+macro_optional_find_package(GLIB2)
+macro_log_feature(GLIB2_FOUND "GLib2" "GLib 2 is required to compile the pulseaudio for Phonon" "http://www.gtk.org/download/" FALSE)
+
+if (GLIB2_FOUND AND PULSEAUDIO_FOUND)
+   add_definitions(-DHAVE_PULSEAUDIO)
+   include_directories(${GLIB2_INCLUDE_DIR} ${PULSEAUDIO_INCLUDE_DIR})
+else(GLIB2_FOUND AND PULSEAUDIO_FOUND)
+   set(PULSEAUDIO_INCLUDE_DIR "")
+   set(PULSEAUDIO_LIBRARY "")
+   set(PULSEAUDIO_MAINLOOP_LIBRARY "")
+endif(GLIB2_FOUND AND PULSEAUDIO_FOUND)
+
+
 set(phonon_LIB_SRCS
    objectdescription.cpp
    objectdescriptionmodel.cpp
@@ -35,9 +51,12 @@ set(phonon_LIB_SRCS
    videowidget.cpp
    videoplayer.cpp
    seekslider.cpp
+   swiftslider.cpp
    volumeslider.cpp
    effectwidget.cpp
    iodevicestream.cpp
+   audiodataoutput.cpp
+   pulsesupport.cpp
    )
 
 if (QT_QTDBUS_FOUND)
@@ -50,6 +69,10 @@ endif (QT_QTDBUS_FOUND)
 add_definitions(-DPHONON_LIBRARY_PATH="${PLUGIN_INSTALL_DIR}/plugins")
 automoc4_add_library(phonon SHARED ${phonon_LIB_SRCS})
 target_link_libraries(phonon ${QT_QTCORE_LIBRARY} ${QT_QTGUI_LIBRARY})
+if (GLIB2_FOUND AND PULSEAUDIO_FOUND)
+target_link_libraries(phonon ${GLIB2_LIBRARIES} ${GOBJECT_LIBRARIES} ${PULSEAUDIO_LIBRARY} ${PULSEAUDIO_MAINLOOP_LIBRARY})
+endif (GLIB2_FOUND AND PULSEAUDIO_FOUND)
+
 if (QT_QTDBUS_FOUND)
   target_link_libraries(phonon ${QT_QTDBUS_LIBRARY})
 endif (QT_QTDBUS_FOUND)
@@ -99,6 +122,10 @@ install(FILES
    volumeslider.h
    effectwidget.h
    platformplugin.h
+   audiodataoutput.h
+   audiodataoutputinterface.h
+   globalconfig.h
+   pulsesupport_p.h
    DESTINATION ${INCLUDE_INSTALL_DIR}/phonon COMPONENT Devel)
 
 install(FILES org.kde.Phonon.AudioOutput.xml  DESTINATION  ${DBUS_INTERFACES_INSTALL_DIR})
diff --git a/src/3rdparty/phonon/phonon/abstractmediastream.cpp b/src/3rdparty/phonon/phonon/abstractmediastream.cpp
index f4a7db6..26e6fd0 100644
--- a/src/3rdparty/phonon/phonon/abstractmediastream.cpp
+++ b/src/3rdparty/phonon/phonon/abstractmediastream.cpp
@@ -49,6 +49,7 @@ AbstractMediaStream::AbstractMediaStream(AbstractMediaStreamPrivate &dd, QObject
 
 AbstractMediaStream::~AbstractMediaStream()
 {
+    delete d_ptr;
 }
 
 qint64 AbstractMediaStream::streamSize() const
diff --git a/src/3rdparty/phonon/phonon/abstractmediastream.h b/src/3rdparty/phonon/phonon/abstractmediastream.h
index 87fa140..5d5bce8 100644
--- a/src/3rdparty/phonon/phonon/abstractmediastream.h
+++ b/src/3rdparty/phonon/phonon/abstractmediastream.h
@@ -214,7 +214,7 @@ class PHONON_EXPORT AbstractMediaStream : public QObject
         virtual void seekStream(qint64 offset);
 
         AbstractMediaStream(AbstractMediaStreamPrivate &dd, QObject *parent);
-        QScopedPointer<AbstractMediaStreamPrivate> d_ptr;
+        AbstractMediaStreamPrivate *d_ptr;
 };
 
 } // namespace Phonon
diff --git a/src/3rdparty/phonon/phonon/abstractmediastream_p.h b/src/3rdparty/phonon/phonon/abstractmediastream_p.h
index a676716..e4c2be9 100644
--- a/src/3rdparty/phonon/phonon/abstractmediastream_p.h
+++ b/src/3rdparty/phonon/phonon/abstractmediastream_p.h
@@ -45,7 +45,6 @@ class PHONON_EXPORT AbstractMediaStreamPrivate : private MediaNodeDestructionHan
     public:
         void setStreamInterface(StreamInterface *);
         void setMediaObjectPrivate(MediaObjectPrivate *);
-        ~AbstractMediaStreamPrivate();
 
     protected:
         AbstractMediaStreamPrivate()
@@ -57,6 +56,7 @@ class PHONON_EXPORT AbstractMediaStreamPrivate : private MediaNodeDestructionHan
             errorType(NoError)
         {
         }
+        ~AbstractMediaStreamPrivate();
 
         virtual void setStreamSize(qint64 newSize);
         virtual void setStreamSeekable(bool s);
diff --git a/src/3rdparty/phonon/phonon/audiodataoutput.cpp b/src/3rdparty/phonon/phonon/audiodataoutput.cpp
new file mode 100644
index 0000000..58870c2
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/audiodataoutput.cpp
@@ -0,0 +1,67 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2005 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "audiodataoutput.h"
+#include "audiodataoutput_p.h"
+#include "factory_p.h"
+
+#define PHONON_CLASSNAME AudioDataOutput
+
+namespace Phonon
+{
+
+PHONON_HEIR_IMPL(AbstractAudioOutput)
+
+PHONON_GETTER(int, dataSize, d->dataSize)
+PHONON_GETTER(int, sampleRate, -1)
+PHONON_SETTER(setDataSize, dataSize, int)
+
+bool AudioDataOutputPrivate::aboutToDeleteBackendObject()
+{
+    Q_ASSERT(m_backendObject);
+    pBACKEND_GET(int, dataSize, "dataSize");
+
+    return AbstractAudioOutputPrivate::aboutToDeleteBackendObject();
+}
+
+void AudioDataOutputPrivate::setupBackendObject()
+{
+    Q_Q(AudioDataOutput);
+    Q_ASSERT(m_backendObject);
+    AbstractAudioOutputPrivate::setupBackendObject();
+
+    // set up attributes
+    pBACKEND_CALL1("setDataSize", int, dataSize);
+
+    qRegisterMetaType<QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > >("QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> >");
+
+    QObject::connect(m_backendObject,
+            SIGNAL(dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > &)),
+            q, SIGNAL(dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > &)));
+    QObject::connect(m_backendObject, SIGNAL(endOfMedia(int)), q, SIGNAL(endOfMedia(int)));
+}
+
+} // namespace Phonon
+
+
+#undef PHONON_CLASSNAME
+// vim: sw=4 ts=4 tw=80
diff --git a/src/3rdparty/phonon/phonon/audiodataoutput.h b/src/3rdparty/phonon/phonon/audiodataoutput.h
new file mode 100644
index 0000000..fefd68e
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/audiodataoutput.h
@@ -0,0 +1,135 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2005-2006 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+#ifndef Phonon_AUDIODATAOUTPUT_H
+#define Phonon_AUDIODATAOUTPUT_H
+
+#include "phonon_export.h"
+#include "abstractaudiooutput.h"
+#include "phonondefs.h"
+
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+template<typename T> class QVector;
+template<typename Key, typename T> class QMap;
+#endif
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+    class AudioDataOutputPrivate;
+
+    /**
+     * \short This class gives you the audio data (for visualizations).
+     *
+     * This class implements a special AbstractAudioOutput that gives your
+     * application the audio data. Don't expect realtime performance. But
+     * the latencies should be low enough to use the audio data for
+     * visualizations. You can also use the audio data for further processing
+     * (e.g. encoding and saving to a file).
+     *
+     * \author Matthias Kretz <kretz@kde.org>
+     */
+    class PHONON_EXPORT AudioDataOutput : public AbstractAudioOutput
+    {
+        Q_OBJECT
+        K_DECLARE_PRIVATE(AudioDataOutput)
+        Q_ENUMS(Channel)
+        Q_PROPERTY(int dataSize READ dataSize WRITE setDataSize)
+        PHONON_HEIR(AudioDataOutput)
+        public:
+            /**
+             * Specifies the channel the audio data belongs to.
+             */
+            enum Channel
+            {
+                LeftChannel,
+                RightChannel,
+                CenterChannel,
+                LeftSurroundChannel,
+                RightSurroundChannel,
+                SubwooferChannel
+            };
+
+            /**
+             * Returns the currently used number of samples passed through
+             * the signal.
+             *
+             * \see setDataSize
+             */
+            int dataSize() const;
+
+            /**
+             * Returns the sample rate in Hz. Common sample rates are 44100 Hz
+             * and 48000 Hz. AudioDataOutput will not do any sample rate
+             * conversion for you. If you need to convert the sample rate you
+             * might want to take a look at libsamplerate. For visualizations it
+             * is often enough to do simple interpolation or even drop/duplicate
+             * samples.
+             *
+             * \return The sample rate as reported by the backend. If the
+             * backend is unavailable -1 is returned.
+             */
+            int sampleRate() const;
+
+        public Q_SLOTS:
+            /**
+             * Sets the number of samples to be passed in one signal emission.
+             *
+             * Defaults to 512 samples per emitted signal.
+             *
+             * \param size the number of samples
+             */
+            void setDataSize(int size);
+
+        Q_SIGNALS:
+            /**
+             * Emitted whenever another dataSize number of samples are ready.
+             *
+             * \param data A mapping of Channel to a vector holding the audio data.
+             */
+            void dataReady(const QMap<Phonon::AudioDataOutput::Channel, QVector<qint16> > &data);
+
+
+            /**
+             * This signal is emitted before the last dataReady signal of a
+             * media is emitted.
+             *
+             * If, for example, the playback of a media file has finished and the
+             * last audio data of that file is going to be passed with the next
+             * dataReady signal, and only the 28 first samples of the data
+             * vector are from that media file endOfMedia will be emitted right
+             * before dataReady with \p remainingSamples = 28.
+             *
+             * \param remainingSamples The number of samples in the next
+             * dataReady vector that belong to the media that was playing to
+             * this point.
+             */
+            void endOfMedia(int remainingSamples);
+    };
+} // namespace Phonon
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+// vim: sw=4 ts=4 tw=80
+#endif // Phonon_AUDIODATAOUTPUT_H
diff --git a/src/3rdparty/phonon/phonon/audiodataoutput_p.h b/src/3rdparty/phonon/phonon/audiodataoutput_p.h
new file mode 100644
index 0000000..91103a9
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/audiodataoutput_p.h
@@ -0,0 +1,48 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef AUDIODATAOUTPUT_P_H
+#define AUDIODATAOUTPUT_P_H
+
+#include "audiodataoutput.h"
+#include "abstractaudiooutput_p.h"
+
+namespace Phonon
+{
+
+class AudioDataOutputPrivate : public AbstractAudioOutputPrivate
+{
+    Q_DECLARE_PUBLIC(AudioDataOutput)
+    PHONON_PRIVATECLASS
+    protected:
+        AudioDataOutputPrivate()
+            : dataSize(512)
+        {
+        }
+
+        int dataSize;
+};
+
+} // namespace Phonon
+
+#endif // AUDIODATAOUTPUT_P_H
+// vim: sw=4 ts=4 tw=80
diff --git a/src/3rdparty/phonon/phonon/audiodataoutputinterface.h b/src/3rdparty/phonon/phonon/audiodataoutputinterface.h
new file mode 100644
index 0000000..bc1aad0
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/audiodataoutputinterface.h
@@ -0,0 +1,44 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2008 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef PHONON_AUDIODATAOUTPUTINTERFACE_H
+#define PHONON_AUDIODATAOUTPUTINTERFACE_H
+
+namespace Phonon
+{
+
+class AudioDataOutput;
+
+class AudioDataOutputInterface
+{
+    public:
+        virtual ~AudioDataOutputInterface() {}
+
+        virtual AudioDataOutput *frontendObject() const = 0;
+        virtual void setFrontendObject(AudioDataOutput *) = 0;
+};
+
+} // namespace Phonon
+
+Q_DECLARE_INTERFACE(Phonon::AudioDataOutputInterface, "0AudioDataOutputInterface.phonon.kde.org")
+
+#endif // PHONON_AUDIODATAOUTPUTINTERFACE_H
diff --git a/src/3rdparty/phonon/phonon/audiooutput.cpp b/src/3rdparty/phonon/phonon/audiooutput.cpp
index 3d03dc4..89b24bd 100644
--- a/src/3rdparty/phonon/phonon/audiooutput.cpp
+++ b/src/3rdparty/phonon/phonon/audiooutput.cpp
@@ -24,10 +24,11 @@
 #include "factory_p.h"
 #include "objectdescription.h"
 #include "audiooutputadaptor_p.h"
-#include "globalconfig_p.h"
+#include "globalconfig.h"
 #include "audiooutputinterface.h"
 #include "phononnamespace_p.h"
 #include "platform_p.h"
+#include "pulsesupport.h"
 
 #include <QtCore/qmath.h>
 
@@ -42,8 +43,12 @@ QT_BEGIN_NAMESPACE
 namespace Phonon
 {
 
-static inline bool callSetOutputDevice(MediaNodePrivate *const d, int index)
+static inline bool callSetOutputDevice(AudioOutputPrivate *const d, int index)
 {
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive())
+        return pulse->setOutputDevice(d->getStreamUuid(), index);
+
     Iface<IFACES2> iface(d);
     if (iface) {
         return iface->setOutputDevice(AudioOutputDevice::fromIndex(index));
@@ -51,8 +56,12 @@ static inline bool callSetOutputDevice(MediaNodePrivate *const d, int index)
     return Iface<IFACES0>::cast(d)->setOutputDevice(index);
 }
 
-static inline bool callSetOutputDevice(MediaNodePrivate *const d, const AudioOutputDevice &dev)
+static inline bool callSetOutputDevice(AudioOutputPrivate *const d, const AudioOutputDevice &dev)
 {
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive())
+        return pulse->setOutputDevice(d->getStreamUuid(), dev.index());
+
     Iface<IFACES2> iface(d);
     if (iface) {
         return iface->setOutputDevice(dev);
@@ -89,6 +98,8 @@ void AudioOutputPrivate::init(Phonon::Category c)
 #endif
 
     category = c;
+    streamUuid = QUuid::createUuid().toString();
+    PulseSupport::getInstance()->setStreamPropList(category, streamUuid);
 
     // select hardware device according to the category
     device = AudioOutputDevice::fromIndex(GlobalConfig().audioOutputDeviceFor(category, GlobalConfig::AdvancedDevicesFromSettings | GlobalConfig::HideUnavailableDevices));
@@ -98,7 +109,10 @@ void AudioOutputPrivate::init(Phonon::Category c)
     q->connect(Factory::sender(), SIGNAL(availableAudioOutputDevicesChanged()), SLOT(_k_deviceListChanged()));
 }
 
-
+QString AudioOutputPrivate::getStreamUuid()
+{
+    return streamUuid;
+}
 
 void AudioOutputPrivate::createBackendObject()
 {
@@ -234,7 +248,7 @@ bool AudioOutput::setOutputDevice(const AudioOutputDevice &newAudioOutputDevice)
         d->device = newAudioOutputDevice;
     }
     if (k_ptr->backendObject()) {
-        return callSetOutputDevice(k_ptr, d->device.index());
+        return callSetOutputDevice(d, d->device.index());
     }
     return true;
 }
@@ -266,8 +280,8 @@ void AudioOutputPrivate::setupBackendObject()
         if (deviceList.isEmpty()) {
             return;
         }
-        for (int i = 0; i < deviceList.count(); ++i) {
-            const AudioOutputDevice &dev = AudioOutputDevice::fromIndex(deviceList.at(i));
+        foreach (int devIndex, deviceList) {
+            const AudioOutputDevice &dev = AudioOutputDevice::fromIndex(devIndex);
             if (callSetOutputDevice(this, dev)) {
                 handleAutomaticDeviceChange(dev, AudioOutputPrivate::FallbackChange);
                 return; // found one that works
@@ -307,9 +321,8 @@ void AudioOutputPrivate::_k_audioDeviceFailed()
     pDebug() << Q_FUNC_INFO;
     // outputDeviceIndex identifies a failing device
     // fall back in the preference list of output devices
-    const QList<int> deviceList = GlobalConfig().audioOutputDeviceListFor(category, GlobalConfig::AdvancedDevicesFromSettings | GlobalConfig::HideUnavailableDevices);
-    for (int i = 0; i < deviceList.count(); ++i) {
-        const int devIndex = deviceList.at(i);
+    QList<int> deviceList = GlobalConfig().audioOutputDeviceListFor(category, GlobalConfig::AdvancedDevicesFromSettings | GlobalConfig::HideUnavailableDevices);
+    foreach (int devIndex, deviceList) {
         // if it's the same device as the one that failed, ignore it
         if (device.index() != devIndex) {
             const AudioOutputDevice &info = AudioOutputDevice::fromIndex(devIndex);
@@ -329,10 +342,9 @@ void AudioOutputPrivate::_k_deviceListChanged()
 {
     pDebug() << Q_FUNC_INFO;
     // let's see if there's a usable device higher in the preference list
-    const QList<int> deviceList = GlobalConfig().audioOutputDeviceListFor(category, GlobalConfig::AdvancedDevicesFromSettings);
+    QList<int> deviceList = GlobalConfig().audioOutputDeviceListFor(category, GlobalConfig::AdvancedDevicesFromSettings);
     DeviceChangeType changeType = HigherPreferenceChange;
-    for (int i = 0; i < deviceList.count(); ++i) {
-        const int devIndex = deviceList.at(i);
+    foreach (int devIndex, deviceList) {
         const AudioOutputDevice &info = AudioOutputDevice::fromIndex(devIndex);
         if (!info.property("available").toBool()) {
             if (device.index() == devIndex) {
@@ -404,6 +416,7 @@ void AudioOutputPrivate::handleAutomaticDeviceChange(const AudioOutputDevice &de
 
 AudioOutputPrivate::~AudioOutputPrivate()
 {
+    PulseSupport::getInstance()->clearStreamCache(streamUuid);
 #ifndef QT_NO_DBUS
     if (adaptor) {
         emit adaptor->outputDestroyed();
diff --git a/src/3rdparty/phonon/phonon/audiooutput_p.h b/src/3rdparty/phonon/phonon/audiooutput_p.h
index fdee299..0a90c3d 100644
--- a/src/3rdparty/phonon/phonon/audiooutput_p.h
+++ b/src/3rdparty/phonon/phonon/audiooutput_p.h
@@ -46,6 +46,7 @@ class AudioOutputPrivate : public AbstractAudioOutputPrivate
             return 0;
         }
         void init(Phonon::Category c);
+        QString getStreamUuid();
 
 
     protected:
@@ -79,6 +80,7 @@ class AudioOutputPrivate : public AbstractAudioOutputPrivate
         QString name;
         Phonon::AudioOutputDevice device;
         qreal volume;
+        QString streamUuid;
 #ifndef QT_NO_DBUS
         Phonon::AudioOutputAdaptor *adaptor;
 #endif
diff --git a/src/3rdparty/phonon/phonon/backend/Mainpage.dox b/src/3rdparty/phonon/phonon/backend/Mainpage.dox
new file mode 100644
index 0000000..db4cac1
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/backend/Mainpage.dox
@@ -0,0 +1,109 @@
+/** \mainpage Phonon Backend Interface
+
+
+\section phonon_backend_development Backend Development
+If you want to write a new backend for %Phonon this is for you:
+\li \ref phonon_backend_development_page "Phonon Backend Development"
+\li \ref Backend
+
+\authors
+Matthias Kretz \<kretz@kde.org\>
+
+\maintainers
+Matthias Kretz \<kretz@kde.org\>
+
+\licenses
+\lgpl
+
+
+
+
+
+
+
+
+\page phonon_tut1 Phonon Tutorial Part 1: a simple audio player
+
+<p><b>
+\ref index "Overview" |
+Application Example |
+\ref phonon_backend_development_page "Backend Development"
+</b></p>
+
+\includelineno tutorial2.cpp
+
+
+
+
+
+
+
+
+\page phonon_backend_development_page Phonon Backend Development
+
+<p><b>
+\ref index "Overview" |
+\ref phonon_tut1 "Application Example" |
+Backend Development
+</b></p>
+
+The backend is the most important part in %Phonon to provide functionality. This
+document will get you started how backends work, how to start development of a
+new backend and how to understand existing backend code.
+
+\section phonon_backend_introduction Introduction
+
+The first step is to understand how the %Phonon frontend calls the backend: In
+the frontend objects all backend objects are "only" QObjects. But QObject has
+powerful introspection capabilities that %Phonon uses to call methods in the
+backend. If you're interested look at \ref QMetaObject::invokeMethod. In order
+to make sure that a backend is fully operational (there are no abstract classes
+that tell the backend developer what method signatures are wrong or what
+methods are missing) there are two test programs compiled with kdelibs (if
+KDE4_BUILD_TESTS is set in cmake) that inspects the backend.
+
+In short that requires the backend classes to inherit from QObject and to make
+all methods that are to be called from the frontend slots or prefixed with
+Q_INVOKABLE (the latter doesn't work reliable with Qt 4.1.3 at least, so you
+should simply make those methods slots).
+
+\section phonon_backend_classes The Backend Classes
+
+The central class that needs to be implemented is the backend factory class,
+throughout this documentation simply called Backend:
+
+\li \ref phonon_Backend "Backend"
+
+\subsection phonon_mediaproducingclasses The classes producing media data (sources)
+
+\li \ref Phonon::MediaObjectInterface "common methods/signals for media producing classes"
+\li \ref phonon_MediaObject "MediaObject"
+
+\subsection phonon_pathclass The path class
+
+\li \ref phonon_Path "Path"
+
+\subsection phonon_outputclasses The output classes
+\li \ref phonon_AudioDataOutput "AudioDataOutput"
+\li \ref phonon_AudioOutput "AudioOutput"
+\li \ref phonon_VideoDataOutput "VideoDataOutput"
+\li \ref phonon_VideoWidget "VideoWidget"
+
+\subsection phonon_EffectClasses The effect classes
+
+\li \ref phonon_Effect "Effect"
+\li \ref phonon_Visualization "Visualization"
+\li \ref phonon_VolumeFaderEffect "VolumeFaderEffect"
+
+*/
+// DOXYGEN_REFERENCES = phonon
+// DOXYGEN_SET_EXPAND_AS_DEFINED = PHONON_OBJECT PHONON_HEIR PHONON_INTERFACE_GETTER
+// DOXYGEN_SET_HIDE_SCOPE_NAMES = YES
+// DOXYGEN_SET_HIDE_FRIEND_COMPOUNDS = YES
+// DOXYGEN_SET_PROJECT_NAME = Backend
+// DOXYGEN_SET_EXTRACT_ALL = NO
+// DOXYGEN_SET_HIDE_UNDOC_MEMBERS = YES
+// DOXYGEN_SET_SOURCE_BROWSER = NO
+// DOXYGEN_SET_INPUT = @topdir@/phonon/phonon
+// DOXYGEN_SET_FILE_PATTERNS = *interface.h */phonon/backend/Mainpage.dox */backend.dox
+// vim: tw=100 ts=4 sw=4 expandtab filetype=doxygen
diff --git a/src/3rdparty/phonon/phonon/backendcapabilities.cpp b/src/3rdparty/phonon/phonon/backendcapabilities.cpp
index 0bcc76c..654e87c 100644
--- a/src/3rdparty/phonon/phonon/backendcapabilities.cpp
+++ b/src/3rdparty/phonon/phonon/backendcapabilities.cpp
@@ -26,7 +26,7 @@
 #include "phonondefs_p.h"
 #include "backendinterface.h"
 #include "factory_p.h"
-#include "globalconfig_p.h"
+#include "globalconfig.h"
 #include "globalstatic_p.h"
 #include "objectdescription.h"
 
@@ -76,8 +76,8 @@ QList<AudioOutputDevice> BackendCapabilities::availableAudioOutputDevices()
 {
     QList<AudioOutputDevice> ret;
     const QList<int> deviceIndexes = GlobalConfig().audioOutputDeviceListFor(Phonon::NoCategory);
-    for (int i = 0; i < deviceIndexes.count(); ++i) {
-        ret.append(AudioOutputDevice::fromIndex(deviceIndexes.at(i)));
+    foreach (int i, deviceIndexes) {
+        ret.append(AudioOutputDevice::fromIndex(i));
     }
     return ret;
 }
@@ -88,8 +88,8 @@ QList<AudioCaptureDevice> BackendCapabilities::availableAudioCaptureDevices()
 {
     QList<AudioCaptureDevice> ret;
     const QList<int> deviceIndexes = GlobalConfig().audioCaptureDeviceListFor(Phonon::NoCategory);
-    for (int i = 0; i < deviceIndexes.count(); ++i) {
-        ret.append(AudioCaptureDevice::fromIndex(deviceIndexes.at(i)));
+    foreach (int i, deviceIndexes) {
+        ret.append(AudioCaptureDevice::fromIndex(i));
     }
     return ret;
 }
@@ -101,9 +101,9 @@ QList<EffectDescription> BackendCapabilities::availableAudioEffects()
     BackendInterface *backendIface = qobject_cast<BackendInterface *>(Factory::backend());
     QList<EffectDescription> ret;
     if (backendIface) {
-        const QList<int> deviceIndexes = backendIface->objectDescriptionIndexes(Phonon::EffectType);
-        for (int i = 0; i < deviceIndexes.count(); ++i) {
-            ret.append(EffectDescription::fromIndex(deviceIndexes.at(i)));
+        QList<int> deviceIndexes = backendIface->objectDescriptionIndexes(Phonon::EffectType);
+        foreach (int i, deviceIndexes) {
+            ret.append(EffectDescription::fromIndex(i));
         }
     }
     return ret;
diff --git a/src/3rdparty/phonon/phonon/backendcapabilities.h b/src/3rdparty/phonon/phonon/backendcapabilities.h
index 643c8ef..bbe6937 100644
--- a/src/3rdparty/phonon/phonon/backendcapabilities.h
+++ b/src/3rdparty/phonon/phonon/backendcapabilities.h
@@ -15,7 +15,7 @@
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public
+    You should have received a copy of the GNU Lesser General Public 
     License along with this library.  If not, see <http://www.gnu.org/licenses/>.
 
 */
@@ -88,18 +88,19 @@ namespace BackendCapabilities
     };
 
     /**
-     * Use this function to get a QObject pointer to connect to one of the Notifier signals.
+     * Use this function to get a QObject pointer to connect to the capabilitiesChanged signal.
      *
      * \return a pointer to a QObject.
      *
-     * To connect to the signal do the following:
+     * The capabilitiesChanged signal is emitted if the capabilities have changed. This can
+     * happen if the user has requested a backend change.
+     *
+     * To connect to this signal do the following:
      * \code
      * QObject::connect(BackendCapabilities::notifier(), SIGNAL(capabilitiesChanged()), ...
      * \endcode
      *
      * \see Notifier::capabilitiesChanged()
-     * \see Notifier::availableAudioOutputDevicesChanged()
-     * \see Notifier::availableAudioCaptureDevicesChanged()
      */
     PHONON_EXPORT Notifier *notifier();
 
diff --git a/src/3rdparty/phonon/phonon/effect.cpp b/src/3rdparty/phonon/phonon/effect.cpp
index dfcb290..f0ac454 100644
--- a/src/3rdparty/phonon/phonon/effect.cpp
+++ b/src/3rdparty/phonon/phonon/effect.cpp
@@ -107,8 +107,7 @@ bool EffectPrivate::aboutToDeleteBackendObject()
 {
     if (m_backendObject) {
         const QList<EffectParameter> parameters = pINTERFACE_CALL(parameters());
-        for (int i = 0; i < parameters.count(); ++i) {
-            const EffectParameter &p = parameters.at(i);
+        foreach (const EffectParameter &p, parameters) {
             parameterValues[p] = pINTERFACE_CALL(parameterValue(p));
         }
     }
@@ -121,8 +120,7 @@ void EffectPrivate::setupBackendObject()
 
     // set up attributes
     const QList<EffectParameter> parameters = pINTERFACE_CALL(parameters());
-    for (int i = 0; i < parameters.count(); ++i) {
-        const EffectParameter &p = parameters.at(i);
+    foreach (const EffectParameter &p, parameters) {
         pINTERFACE_CALL(setParameterValue(p, parameterValues[p]));
     }
 }
diff --git a/src/3rdparty/phonon/phonon/effectwidget.cpp b/src/3rdparty/phonon/phonon/effectwidget.cpp
index 2334d7f..6738382 100644
--- a/src/3rdparty/phonon/phonon/effectwidget.cpp
+++ b/src/3rdparty/phonon/phonon/effectwidget.cpp
@@ -97,9 +97,7 @@ void EffectWidgetPrivate::autogenerateUi()
     Q_Q(EffectWidget);
     QVBoxLayout *mainLayout = new QVBoxLayout(q);
     mainLayout->setMargin(0);
-    const QList<Phonon::EffectParameter> parameters = effect->parameters();
-    for (int i = 0; i < parameters.count(); ++i) {
-        const EffectParameter &para = parameters.at(i);
+    foreach (const EffectParameter &para, effect->parameters()) {
         QVariant value = effect->parameterValue(para);
         QHBoxLayout *pLayout = new QHBoxLayout;
         mainLayout->addLayout(pLayout);
@@ -119,14 +117,13 @@ void EffectWidgetPrivate::autogenerateUi()
                 control = cb;
                 if (value.type() == QVariant::Int) {
                     //value just defines the item index
-                    for (int i = 0; i < para.possibleValues().count(); ++i) {
-                        cb->addItem(para.possibleValues().at(i).toString());
+                    foreach (const QVariant &item, para.possibleValues()) {
+                        cb->addItem(item.toString());
                     }
                     cb->setCurrentIndex(value.toInt());
                     QObject::connect(cb, SIGNAL(currentIndexChanged(int)), q, SLOT(_k_setIntParameter(int)));
                 } else {
-                    for (int i = 0; i < para.possibleValues().count(); ++i) {
-                        const QVariant &item = para.possibleValues().at(i);
+                    foreach (const QVariant &item, para.possibleValues()) {
                         cb->addItem(item.toString());
                         if (item == value) {
                             cb->setCurrentIndex(cb->count() - 1);
@@ -158,20 +155,18 @@ void EffectWidgetPrivate::autogenerateUi()
                 QObject::connect(sb, SIGNAL(valueChanged(int)), q, SLOT(_k_setIntParameter(int)));
             }
             break;
-        case QMetaType::Float:
         case QVariant::Double:
             {
-                const qreal minValue = para.minimumValue().canConvert(QVariant::Double) ?
-                    para.minimumValue().toReal() : DEFAULT_MIN;
-                const qreal maxValue = para.maximumValue().canConvert(QVariant::Double) ?
-                    para.maximumValue().toReal() : DEFAULT_MAX;
+                const double minValue = (para.minimumValue().type() == QVariant::Double ?
+                    para.minimumValue().toDouble() : DEFAULT_MIN);
+                const double maxValue = (para.maximumValue().type() == QVariant::Double ?
+                    para.maximumValue().toDouble() : DEFAULT_MAX);
 
                 if (minValue == -1. && maxValue == 1.) {
                     //Special case values between -1 and 1.0 to use a slider for improved usability
                     QSlider *slider = new QSlider(Qt::Horizontal, q);
-                    control = slider;
                     slider->setRange(-SLIDER_RANGE, +SLIDER_RANGE);
-                    slider->setValue(int(SLIDER_RANGE * value.toReal()));
+                    slider->setValue(int(SLIDER_RANGE * value.toDouble()));
                     slider->setTickPosition(QSlider::TicksBelow);
                     slider->setTickInterval(TICKINTERVAL);
                     QObject::connect(slider, SIGNAL(valueChanged(int)), q, SLOT(_k_setSliderParameter(int)));
@@ -193,10 +188,10 @@ void EffectWidgetPrivate::autogenerateUi()
             break;
         }
 
-        if (control) {
 #ifndef QT_NO_TOOLTIP
         control->setToolTip(para.description());
 #endif
+        if (control) {
 #ifndef QT_NO_SHORTCUT
             label->setBuddy(control);
 #endif
diff --git a/src/3rdparty/phonon/phonon/factory.cpp b/src/3rdparty/phonon/phonon/factory.cpp
index ab1f44f..b26c4f3 100644
--- a/src/3rdparty/phonon/phonon/factory.cpp
+++ b/src/3rdparty/phonon/phonon/factory.cpp
@@ -111,7 +111,6 @@ void Factory::setBackend(QObject *b)
 
 bool FactoryPrivate::createBackend()
 {
-#ifndef QT_NO_LIBRARY
     Q_ASSERT(m_backendObject == 0);
 #ifndef QT_NO_PHONON_PLATFORMPLUGIN
     PlatformPlugin *f = globalFactory->platformPlugin();
@@ -125,39 +124,15 @@ bool FactoryPrivate::createBackend()
         // could not load a backend through the platform plugin. Falling back to the default
         // (finding the first loadable backend).
         const QLatin1String suffix("/phonon_backend/");
-        const QStringList paths = QCoreApplication::libraryPaths();
-        for (int i = 0; i < paths.count(); ++i) {
-            const QString libPath = paths.at(i) + suffix;
+        foreach (QString libPath, QCoreApplication::libraryPaths()) {
+            libPath += suffix;
             const QDir dir(libPath);
             if (!dir.exists()) {
                 pDebug() << Q_FUNC_INFO << dir.absolutePath() << "does not exist";
                 continue;
             }
-
-			QStringList plugins(dir.entryList(QDir::Files));
-
-#ifdef Q_OS_SYMBIAN
-            /* On Symbian OS we might have two plugins, one which uses Symbian
-             * MMF framework("phonon_mmf"), and one which uses Real Networks's
-             * Helix("hxphonon"). We prefer the latter because it's more
-             * sophisticated, so we make sure the Helix backend is attempted
-             * to be loaded first, and the MMF backend is used for backup. */
-            {
-
-                const int hxphonon = plugins.indexOf(QLatin1String("hxphonon"));
-                if (hxphonon != -1)
-                    plugins.move(hxphonon, 0);
-
-                // Code for debugging the MMF backend.
-                if(hxphonon != -1) {
-                    qDebug() << "Found hxphonon backend and removed it from the lookup list.";
-                    plugins.removeAll(QLatin1String("hxphonon"));
-                }
-            }
-#endif
-
-            for (int i = 0; i < plugins.count(); ++i) {
-                QPluginLoader pluginLoader(libPath + plugins.at(i));
+            foreach (const QString &pluginName, dir.entryList(QDir::Files)) {
+                QPluginLoader pluginLoader(libPath + pluginName);
                 if (!pluginLoader.load()) {
                     pDebug() << Q_FUNC_INFO << "  load failed:"
                              << pluginLoader.errorString();
@@ -187,20 +162,14 @@ bool FactoryPrivate::createBackend()
             SLOT(objectDescriptionChanged(ObjectDescriptionType)));
 
     return true;
-#else //QT_NO_LIBRARY
-    pWarning() << Q_FUNC_INFO << "Trying to use Phonon with QT_NO_LIBRARY defined. "
-                                 "That is currently not supported";
-    return false;
-#endif
 }
 
 FactoryPrivate::FactoryPrivate()
-    :
 #ifndef QT_NO_PHONON_PLATFORMPLUGIN
-    m_platformPlugin(0),
-    m_noPlatformPlugin(false),
+    : m_platformPlugin(0),
+    m_noPlatformPlugin(false)
 #endif //QT_NO_PHONON_PLATFORMPLUGIN
-    m_backendObject(0)
+    , m_backendObject(0)
 {
     // Add the post routine to make sure that all other global statics (especially the ones from Qt)
     // are still available. If the FactoryPrivate dtor is called too late many bad things can happen
@@ -214,8 +183,14 @@ FactoryPrivate::FactoryPrivate()
 
 FactoryPrivate::~FactoryPrivate()
 {
-    for (int i = 0; i < mediaNodePrivateList.count(); ++i) {
-        mediaNodePrivateList.at(i)->deleteBackendObject();
+    foreach (QObject *o, objects) {
+        MediaObject *m = qobject_cast<MediaObject *>(o);
+        if (m) {
+            m->stop();
+        }
+    }
+    foreach (MediaNodePrivate *bp, mediaNodePrivateList) {
+        bp->deleteBackendObject();
     }
     if (objects.size() > 0) {
         pError() << "The backend objects are not deleted as was requested.";
@@ -283,8 +258,8 @@ void Factory::deregisterFrontendObject(MediaNodePrivate *bp)
 void FactoryPrivate::phononBackendChanged()
 {
     if (m_backendObject) {
-        for (int i = 0; i < mediaNodePrivateList.count(); ++i) {
-            mediaNodePrivateList.at(i)->deleteBackendObject();
+        foreach (MediaNodePrivate *bp, mediaNodePrivateList) {
+            bp->deleteBackendObject();
         }
         if (objects.size() > 0) {
             pDebug() << "WARNING: we were asked to change the backend but the application did\n"
@@ -293,8 +268,8 @@ void FactoryPrivate::phononBackendChanged()
                 "backendswitching possible.";
             // in case there were objects deleted give 'em a chance to recreate
             // them now
-            for (int i = 0; i < mediaNodePrivateList.count(); ++i) {
-                mediaNodePrivateList.at(i)->createBackendObject();
+            foreach (MediaNodePrivate *bp, mediaNodePrivateList) {
+                bp->createBackendObject();
             }
             return;
         }
@@ -302,8 +277,8 @@ void FactoryPrivate::phononBackendChanged()
         m_backendObject = 0;
     }
     createBackend();
-    for (int i = 0; i < mediaNodePrivateList.count(); ++i) {
-        mediaNodePrivateList.at(i)->createBackendObject();
+    foreach (MediaNodePrivate *bp, mediaNodePrivateList) {
+        bp->createBackendObject();
     }
     emit backendChanged();
 }
@@ -350,6 +325,7 @@ FACTORY_IMPL(AudioOutput)
 #ifndef QT_NO_PHONON_VIDEO
 FACTORY_IMPL(VideoWidget)
 #endif //QT_NO_PHONON_VIDEO
+FACTORY_IMPL(AudioDataOutput)
 
 #undef FACTORY_IMPL
 
@@ -387,17 +363,15 @@ PlatformPlugin *FactoryPrivate::platformPlugin()
              QStringList())
             );
     dir.setFilter(QDir::Files);
-    const QStringList libPaths = QCoreApplication::libraryPaths();
     forever {
-        for (int i = 0; i < libPaths.count(); ++i) {
-            const QString libPath = libPaths.at(i) + suffix;
+        foreach (QString libPath, QCoreApplication::libraryPaths()) {
+            libPath += suffix;
             dir.setPath(libPath);
             if (!dir.exists()) {
                 continue;
             }
-            const QStringList files = dir.entryList(QDir::Files);
-            for (int i = 0; i < files.count(); ++i) {
-                QPluginLoader pluginLoader(libPath + files.at(i));
+            foreach (const QString &pluginName, dir.entryList()) {
+                QPluginLoader pluginLoader(libPath + pluginName);
                 if (!pluginLoader.load()) {
                     pDebug() << Q_FUNC_INFO << "  platform plugin load failed:"
                         << pluginLoader.errorString();
@@ -449,7 +423,6 @@ QObject *Factory::backend(bool createWhenNull)
     return globalFactory->m_backendObject;
 }
 
-#ifndef QT_NO_PROPERTIES
 #define GET_STRING_PROPERTY(name) \
 QString Factory::name() \
 { \
@@ -465,7 +438,7 @@ GET_STRING_PROPERTY(backendComment)
 GET_STRING_PROPERTY(backendVersion)
 GET_STRING_PROPERTY(backendIcon)
 GET_STRING_PROPERTY(backendWebsite)
-#endif //QT_NO_PROPERTIES
+
 QObject *Factory::registerQObject(QObject *o)
 {
     if (o) {
diff --git a/src/3rdparty/phonon/phonon/factory_p.h b/src/3rdparty/phonon/phonon/factory_p.h
index dee2b56..41b8c5b 100644
--- a/src/3rdparty/phonon/phonon/factory_p.h
+++ b/src/3rdparty/phonon/phonon/factory_p.h
@@ -122,6 +122,13 @@ namespace Factory
 #endif //QT_NO_PHONON_VIDEO
 
     /**
+    * Create a new backend object for a AudioDataOutput.
+    *
+    * \return a pointer to the AudioDataOutput the backend provides.
+    */
+    PHONON_EXPORT QObject *createAudioDataOutput(QObject *parent = 0);
+
+    /**
      * \return a pointer to the backend interface.
      */
     PHONON_EXPORT QObject *backend(bool createWhenNull = true);
diff --git a/src/3rdparty/phonon/phonon/globalconfig.cpp b/src/3rdparty/phonon/phonon/globalconfig.cpp
index 6e6263a..44bf49a 100644
--- a/src/3rdparty/phonon/phonon/globalconfig.cpp
+++ b/src/3rdparty/phonon/phonon/globalconfig.cpp
@@ -20,6 +20,7 @@
 
 */
 
+#include "globalconfig.h"
 #include "globalconfig_p.h"
 
 #include "factory_p.h"
@@ -29,6 +30,7 @@
 #include "backendinterface.h"
 #include "qsettingsgroup_p.h"
 #include "phononnamespace_p.h"
+#include "pulsesupport.h"
 
 #include <QtCore/QList>
 #include <QtCore/QVariant>
@@ -38,15 +40,18 @@ QT_BEGIN_NAMESPACE
 namespace Phonon
 {
 
+GlobalConfigPrivate::GlobalConfigPrivate() : config(QLatin1String("kde.org"), QLatin1String("libphonon"))
+{
+}
+
 GlobalConfig::GlobalConfig()
-#ifndef QT_NO_SETTINGS
-    : m_config(QLatin1String("kde.org"), QLatin1String("libphonon"))
-#endif //QT_NO_SETTINGS
+    : k_ptr(new GlobalConfigPrivate)
 {
 }
 
 GlobalConfig::~GlobalConfig()
 {
+    delete k_ptr;
 }
 
 enum WhatToFilter {
@@ -85,9 +90,12 @@ static void filter(ObjectDescriptionType type, BackendInterface *backendIface, Q
     }
 }
 
-#ifndef QT_NO_PHONON_SETTINGSGROUP
-static QList<int> listSortedByConfig(const QSettingsGroup &backendConfig, Phonon::Category category, QList<int> &defaultList)
+static QList<int> sortDevicesByCategoryPriority(const GlobalConfig *config, const QSettingsGroup *backendConfig, ObjectDescriptionType type, Phonon::Category category, QList<int> &defaultList)
 {
+    Q_ASSERT(config);
+    Q_ASSERT(backendConfig);
+    Q_ASSERT(type == AudioOutputDeviceType || type == AudioCaptureDeviceType);
+
     if (defaultList.size() <= 1) {
         // nothing to sort
         return defaultList;
@@ -104,20 +112,26 @@ static QList<int> listSortedByConfig(const QSettingsGroup &backendConfig, Phonon
         }
     }
 
-    QString categoryKey = QLatin1String("Category_") + QString::number(static_cast<int>(category));
-    if (!backendConfig.hasKey(categoryKey)) {
-        // no list in config for the given category
-        categoryKey = QLatin1String("Category_") + QString::number(static_cast<int>(Phonon::NoCategory));
-        if (!backendConfig.hasKey(categoryKey)) {
-            // no list in config for NoCategory
-            return defaultList;
+    QList<int> deviceList;
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive()) {
+        deviceList = pulse->objectIndexesByCategory(type, category);
+    } else {
+        QString categoryKey = QLatin1String("Category_") + QString::number(static_cast<int>(category));
+        if (!backendConfig->hasKey(categoryKey)) {
+            // no list in config for the given category
+            categoryKey = QLatin1String("Category_") + QString::number(static_cast<int>(Phonon::NoCategory));
+            if (!backendConfig->hasKey(categoryKey)) {
+                // no list in config for NoCategory
+                return defaultList;
+            }
         }
-    }
 
-    //Now the list from m_config
-    QList<int> deviceList = backendConfig.value(categoryKey, QList<int>());
+        //Now the list from d->config
+        deviceList = backendConfig->value(categoryKey, QList<int>());
+    }
 
-    //if there are devices in m_config that the backend doesn't report, remove them from the list
+    //if there are devices in d->config that the backend doesn't report, remove them from the list
     QMutableListIterator<int> i(deviceList);
     while (i.hasNext()) {
         if (0 == defaultList.removeAll(i.next())) {
@@ -125,49 +139,176 @@ static QList<int> listSortedByConfig(const QSettingsGroup &backendConfig, Phonon
         }
     }
 
-    //if the backend reports more devices that are not in m_config append them to the list
+    //if the backend reports more devices that are not in d->config append them to the list
     deviceList += defaultList;
 
     return deviceList;
 }
-#endif //QT_NO_PHONON_SETTINGSGROUP
 
-#ifndef QT_NO_PHONON_SETTINGSGROUP
-QList<int> GlobalConfig::audioOutputDeviceListFor(Phonon::Category category, int override) const
+bool GlobalConfig::hideAdvancedDevices() const
 {
+    K_D(const GlobalConfig);
     //The devices need to be stored independently for every backend
-    const QSettingsGroup backendConfig(&m_config, QLatin1String("AudioOutputDevice")); // + Factory::identifier());
-    const QSettingsGroup generalGroup(&m_config, QLatin1String("General"));
-    const bool hideAdvancedDevices = ((override & AdvancedDevicesFromSettings)
-            ? generalGroup.value(QLatin1String("HideAdvancedDevices"), true)
+    const QSettingsGroup generalGroup(&d->config, QLatin1String("General"));
+    return generalGroup.value(QLatin1String("HideAdvancedDevices"), true);
+}
+
+void GlobalConfig::setHideAdvancedDevices(bool hide)
+{
+    K_D(GlobalConfig);
+    QSettingsGroup generalGroup(&d->config, QLatin1String("General"));
+    generalGroup.setValue(QLatin1String("HideAdvancedDevices"), hide);
+}
+
+static bool isHiddenAudioOutputDevice(const GlobalConfig *config, int i)
+{
+    Q_ASSERT(config);
+
+    if (!config->hideAdvancedDevices())
+        return false;
+
+    AudioOutputDevice ad = AudioOutputDevice::fromIndex(i);
+    const QVariant var = ad.property("isAdvanced");
+    return (var.isValid() && var.toBool());
+}
+
+#ifndef QT_NO_PHONON_AUDIOCAPTURE
+static bool isHiddenAudioCaptureDevice(const GlobalConfig *config, int i)
+{
+    Q_ASSERT(config);
+
+    if (!config->hideAdvancedDevices())
+        return false;
+
+    AudioCaptureDevice ad = AudioCaptureDevice::fromIndex(i);
+    const QVariant var = ad.property("isAdvanced");
+    return (var.isValid() && var.toBool());
+}
+#endif
+
+static QList<int> reindexList(const GlobalConfig *config, Phonon::Category category, QList<int>newOrder, bool output)
+{
+    Q_ASSERT(config);
+#ifdef QT_NO_PHONON_AUDIOCAPTURE
+    Q_ASSERT(output);
+#endif
+
+    /*QString sb;
+    sb = QString("(Size %1)").arg(currentList.size());
+    foreach (int i, currentList)
+    sb += QString("%1, ").arg(i);
+    fprintf(stderr, "=== Reindex Current: %s\n", sb.toUtf8().constData());
+    sb = QString("(Size %1)").arg(newOrder.size());
+    foreach (int i, newOrder)
+    sb += QString("%1, ").arg(i);
+    fprintf(stderr, "=== Reindex Before : %s\n", sb.toUtf8().constData());*/
+
+    QList<int> currentList;
+    if (output)
+        currentList = config->audioOutputDeviceListFor(category, GlobalConfig::ShowUnavailableDevices|GlobalConfig::ShowAdvancedDevices);
+#ifndef QT_NO_PHONON_AUDIOCAPTURE
+    else
+        currentList = config->audioCaptureDeviceListFor(category, GlobalConfig::ShowUnavailableDevices|GlobalConfig::ShowAdvancedDevices);
+#endif
+
+    QList<int> newList;
+
+    foreach (int i, newOrder) {
+        int found = currentList.indexOf(i);
+        if (found < 0) {
+            // It's not in the list, so something is odd (e.g. client error). Ignore it.
+            continue;
+        }
+
+        // Iterate through the list from this point onward. If there are hidden devices
+        // immediately following, take them too.
+        newList.append(currentList.takeAt(found));
+        while (found < currentList.size()) {
+            bool hidden = true;
+            if (output)
+                hidden = isHiddenAudioOutputDevice(config, currentList.at(found));
+#ifndef QT_NO_PHONON_AUDIOCAPTURE
+            else
+                hidden = isHiddenAudioCaptureDevice(config, currentList.at(found));
+#endif
+
+            if (!hidden)
+                break;
+            newList.append(currentList.takeAt(found));
+        }
+    }
+
+    // If there are any devices left in.. just tack them on the end.
+    if (currentList.size() > 0)
+        newList += currentList;
+
+    /*sb = QString("(Size %1)").arg(newList.size());
+    foreach (int i, newList)
+    sb += QString("%1, ").arg(i);
+    fprintf(stderr, "=== Reindex After  : %s\n", sb.toUtf8().constData());*/
+    return newList;
+}
+
+
+void GlobalConfig::setAudioOutputDeviceListFor(Phonon::Category category, QList<int> order)
+{
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive()) {
+        pulse->setOutputDevicePriorityForCategory(category, order);
+        return;
+    }
+
+    K_D(GlobalConfig);
+    QSettingsGroup backendConfig(&d->config, QLatin1String("AudioOutputDevice")); // + Factory::identifier());
+
+    order = reindexList(this, category, order, true);
+
+    const QList<int> noCategoryOrder = audioOutputDeviceListFor(Phonon::NoCategory, ShowUnavailableDevices|ShowAdvancedDevices);
+    if (category != Phonon::NoCategory && order == noCategoryOrder) {
+        backendConfig.removeEntry(QLatin1String("Category_") + QString::number(category));
+    } else {
+        backendConfig.setValue(QLatin1String("Category_") + QString::number(category), order);
+    }
+}
+
+QList<int> GlobalConfig::audioOutputDeviceListFor(Phonon::Category category, int override) const
+{
+    K_D(const GlobalConfig);
+
+    const bool hide = ((override & AdvancedDevicesFromSettings)
+            ? hideAdvancedDevices()
             : static_cast<bool>(override & HideAdvancedDevices));
 
     QList<int> defaultList;
+    BackendInterface *backendIface = qobject_cast<BackendInterface *>(Factory::backend());
+
 #ifndef QT_NO_PHONON_PLATFORMPLUGIN
-    if (PlatformPlugin *platformPlugin = Factory::platformPlugin()) {
-        // the platform plugin lists the audio devices for the platform
-        // this list already is in default order (as defined by the platform plugin)
-        defaultList = platformPlugin->objectDescriptionIndexes(Phonon::AudioOutputDeviceType);
-        if (hideAdvancedDevices) {
-            QMutableListIterator<int> it(defaultList);
-            while (it.hasNext()) {
-                AudioOutputDevice objDesc = AudioOutputDevice::fromIndex(it.next());
-                const QVariant var = objDesc.property("isAdvanced");
-                if (var.isValid() && var.toBool()) {
-                    it.remove();
+    if (!backendIface || !PulseSupport::getInstance()->isActive()) {
+        if (PlatformPlugin *platformPlugin = Factory::platformPlugin()) {
+            // the platform plugin lists the audio devices for the platform
+            // this list already is in default order (as defined by the platform plugin)
+            defaultList = platformPlugin->objectDescriptionIndexes(Phonon::AudioOutputDeviceType);
+            if (hide) {
+                QMutableListIterator<int> it(defaultList);
+                while (it.hasNext()) {
+                    AudioOutputDevice objDesc = AudioOutputDevice::fromIndex(it.next());
+                    const QVariant var = objDesc.property("isAdvanced");
+                    if (var.isValid() && var.toBool()) {
+                        it.remove();
+                    }
                 }
             }
         }
     }
 #endif //QT_NO_PHONON_PLATFORMPLUGIN
 
-    // lookup the available devices directly from the backend (mostly for virtual devices)
-    if (BackendInterface *backendIface = qobject_cast<BackendInterface *>(Factory::backend())) {
+    // lookup the available devices directly from the backend
+    if (backendIface) {
         // this list already is in default order (as defined by the backend)
         QList<int> list = backendIface->objectDescriptionIndexes(Phonon::AudioOutputDeviceType);
-        if (hideAdvancedDevices || !defaultList.isEmpty() || (override & HideUnavailableDevices)) {
+        if (hide || !defaultList.isEmpty() || (override & HideUnavailableDevices)) {
             filter(AudioOutputDeviceType, backendIface, &list,
-                    (hideAdvancedDevices ? FilterAdvancedDevices : 0)
+                    (hide ? FilterAdvancedDevices : 0)
                     // the platform plugin already provided the hardware devices
                     | (defaultList.isEmpty() ? 0 : FilterHardwareDevices)
                     | ((override & HideUnavailableDevices) ? FilterUnavailableDevices : 0)
@@ -176,9 +317,10 @@ QList<int> GlobalConfig::audioOutputDeviceListFor(Phonon::Category category, int
         defaultList += list;
     }
 
-    return listSortedByConfig(backendConfig, category, defaultList);
+    const QSettingsGroup backendConfig(&d->config, QLatin1String("AudioOutputDevice")); // + Factory::identifier());
+    return sortDevicesByCategoryPriority(this, &backendConfig, AudioOutputDeviceType, category, defaultList);
 }
-#endif //QT_NO_SETTINGSGROUPS
+
 int GlobalConfig::audioOutputDeviceFor(Phonon::Category category, int override) const
 {
     QList<int> ret = audioOutputDeviceListFor(category, override);
@@ -188,42 +330,65 @@ int GlobalConfig::audioOutputDeviceFor(Phonon::Category category, int override)
 }
 
 #ifndef QT_NO_PHONON_AUDIOCAPTURE
+void GlobalConfig::setAudioCaptureDeviceListFor(Phonon::Category category, QList<int> order)
+{
+    PulseSupport *pulse = PulseSupport::getInstance();
+    if (pulse->isActive()) {
+        pulse->setCaptureDevicePriorityForCategory(category, order);
+        return;
+    }
+
+    K_D(GlobalConfig);
+    QSettingsGroup backendConfig(&d->config, QLatin1String("AudioCaptureDevice")); // + Factory::identifier());
+
+    order = reindexList(this, category, order, false);
+
+    const QList<int> noCategoryOrder = audioCaptureDeviceListFor(Phonon::NoCategory, ShowUnavailableDevices|ShowAdvancedDevices);
+    if (category != Phonon::NoCategory && order == noCategoryOrder) {
+        backendConfig.removeEntry(QLatin1String("Category_") + QString::number(category));
+    } else {
+        backendConfig.setValue(QLatin1String("Category_") + QString::number(category), order);
+    }
+}
+
 QList<int> GlobalConfig::audioCaptureDeviceListFor(Phonon::Category category, int override) const
 {
-#ifndef QT_NO_PHONON_SETTINGSGROUP
-    //The devices need to be stored independently for every backend
-    const QSettingsGroup backendConfig(&m_config, QLatin1String("AudioCaptureDevice")); // + Factory::identifier());
-    const QSettingsGroup generalGroup(&m_config, QLatin1String("General"));
-    const bool hideAdvancedDevices = ((override & AdvancedDevicesFromSettings)
-            ? generalGroup.value(QLatin1String("HideAdvancedDevices"), true)
+    K_D(const GlobalConfig);
+
+    const bool hide = ((override & AdvancedDevicesFromSettings)
+            ? hideAdvancedDevices()
             : static_cast<bool>(override & HideAdvancedDevices));
 
     QList<int> defaultList;
+    BackendInterface *backendIface = qobject_cast<BackendInterface *>(Factory::backend());
+
 #ifndef QT_NO_PHONON_PLATFORMPLUGIN
-    if (PlatformPlugin *platformPlugin = Factory::platformPlugin()) {
-        // the platform plugin lists the audio devices for the platform
-        // this list already is in default order (as defined by the platform plugin)
-        defaultList = platformPlugin->objectDescriptionIndexes(Phonon::AudioCaptureDeviceType);
-        if (hideAdvancedDevices) {
-            QMutableListIterator<int> it(defaultList);
-            while (it.hasNext()) {
-                AudioCaptureDevice objDesc = AudioCaptureDevice::fromIndex(it.next());
-                const QVariant var = objDesc.property("isAdvanced");
-                if (var.isValid() && var.toBool()) {
-                    it.remove();
+    if (!backendIface || !PulseSupport::getInstance()->isActive()) {
+        if (PlatformPlugin *platformPlugin = Factory::platformPlugin()) {
+            // the platform plugin lists the audio devices for the platform
+            // this list already is in default order (as defined by the platform plugin)
+            defaultList = platformPlugin->objectDescriptionIndexes(Phonon::AudioCaptureDeviceType);
+            if (hide) {
+                QMutableListIterator<int> it(defaultList);
+                while (it.hasNext()) {
+                    AudioCaptureDevice objDesc = AudioCaptureDevice::fromIndex(it.next());
+                    const QVariant var = objDesc.property("isAdvanced");
+                    if (var.isValid() && var.toBool()) {
+                        it.remove();
+                    }
                 }
             }
         }
     }
 #endif //QT_NO_PHONON_PLATFORMPLUGIN
 
-    // lookup the available devices directly from the backend (mostly for virtual devices)
-    if (BackendInterface *backendIface = qobject_cast<BackendInterface *>(Factory::backend())) {
+    // lookup the available devices directly from the backend
+    if (backendIface) {
         // this list already is in default order (as defined by the backend)
         QList<int> list = backendIface->objectDescriptionIndexes(Phonon::AudioCaptureDeviceType);
-        if (hideAdvancedDevices || !defaultList.isEmpty() || (override & HideUnavailableDevices)) {
+        if (hide || !defaultList.isEmpty() || (override & HideUnavailableDevices)) {
             filter(AudioCaptureDeviceType, backendIface, &list,
-                    (hideAdvancedDevices ? FilterAdvancedDevices : 0)
+                    (hide ? FilterAdvancedDevices : 0)
                     // the platform plugin already provided the hardware devices
                     | (defaultList.isEmpty() ? 0 : FilterHardwareDevices)
                     | ((override & HideUnavailableDevices) ? FilterUnavailableDevices : 0)
@@ -232,10 +397,8 @@ QList<int> GlobalConfig::audioCaptureDeviceListFor(Phonon::Category category, in
         defaultList += list;
     }
 
-    return listSortedByConfig(backendConfig, category, defaultList);
-#else //QT_NO_SETTINGSGROUP
-    return QList<int>();
-#endif //QT_NO_SETTINGSGROUP
+    const QSettingsGroup backendConfig(&d->config, QLatin1String("AudioCaptureDevice")); // + Factory::identifier());
+    return sortDevicesByCategoryPriority(this, &backendConfig, AudioCaptureDeviceType, category, defaultList);
 }
 
 int GlobalConfig::audioCaptureDeviceFor(Phonon::Category category, int override) const
diff --git a/src/3rdparty/phonon/phonon/globalconfig.h b/src/3rdparty/phonon/phonon/globalconfig.h
new file mode 100644
index 0000000..5233c7b
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/globalconfig.h
@@ -0,0 +1,71 @@
+/*  This file is part of the KDE project
+Copyright (C) 2006-2008 Matthias Kretz <kretz@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public 
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef PHONON_GLOBALCONFIG_H
+#define PHONON_GLOBALCONFIG_H
+
+#include "phonon_export.h"
+#include "phononnamespace.h"
+#include "phonondefs.h"
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+    class GlobalConfigPrivate;
+
+    class PHONON_EXPORT GlobalConfig
+    {
+        K_DECLARE_PRIVATE(GlobalConfig)
+    public:
+        GlobalConfig();
+        virtual ~GlobalConfig();
+
+        enum DevicesToHideFlag {
+            ShowUnavailableDevices = 0,
+            ShowAdvancedDevices = 0,
+            HideAdvancedDevices = 1,
+            AdvancedDevicesFromSettings = 2,
+            HideUnavailableDevices = 4
+        };
+        bool hideAdvancedDevices() const;
+        void setHideAdvancedDevices(bool hide = true);
+        void setAudioOutputDeviceListFor(Phonon::Category category, QList<int> order);
+        QList<int> audioOutputDeviceListFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
+        int audioOutputDeviceFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
+
+#ifndef QT_NO_PHONON_AUDIOCAPTURE
+        void setAudioCaptureDeviceListFor(Phonon::Category category, QList<int> order);
+        QList<int> audioCaptureDeviceListFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
+        int audioCaptureDeviceFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
+#endif //QT_NO_PHONON_AUDIOCAPTURE
+
+    protected:
+        GlobalConfigPrivate *const k_ptr;
+    };
+} // namespace Phonon
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // PHONON_GLOBALCONFIG_H
diff --git a/src/3rdparty/phonon/phonon/globalconfig_p.h b/src/3rdparty/phonon/phonon/globalconfig_p.h
index ec70b6f..090ca6b 100644
--- a/src/3rdparty/phonon/phonon/globalconfig_p.h
+++ b/src/3rdparty/phonon/phonon/globalconfig_p.h
@@ -26,40 +26,19 @@ Copyright (C) 2006-2008 Matthias Kretz <kretz@kde.org>
 #include <QtCore/QSettings>
 
 #include "phonon_export.h"
-#include "phononnamespace.h"
 
 QT_BEGIN_HEADER
 QT_BEGIN_NAMESPACE
 
 namespace Phonon
 {
-    class PHONON_EXPORT GlobalConfig
+    class GlobalConfigPrivate
     {
-    public:
-        GlobalConfig();
-        virtual ~GlobalConfig();
+        public:
+            GlobalConfigPrivate();
+            virtual ~GlobalConfigPrivate() {}
 
-        enum DevicesToHideFlag {
-            ShowUnavailableDevices = 0,
-            ShowAdvancedDevices = 0,
-            HideAdvancedDevices = 1,
-            AdvancedDevicesFromSettings = 2,
-            HideUnavailableDevices = 4
-        };
-#ifndef QT_NO_PHONON_SETTINGSGROUP
-        QList<int> audioOutputDeviceListFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
-#endif //QT_NO_PHONON_SETTINGSGROUP
-        int audioOutputDeviceFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
-
-#ifndef QT_NO_PHONON_AUDIOCAPTURE
-        QList<int> audioCaptureDeviceListFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
-        int audioCaptureDeviceFor(Phonon::Category category, int override = AdvancedDevicesFromSettings) const;
-#endif //QT_NO_PHONON_AUDIOCAPTURE
-
-    protected:
-#ifndef QT_NO_SETTINGS
-        QSettings m_config;
-#endif //QT_NO_SETTINGS
+            QSettings config;
     };
 } // namespace Phonon
 
diff --git a/src/3rdparty/phonon/phonon/medianode.cpp b/src/3rdparty/phonon/phonon/medianode.cpp
index bc1caed..f855766 100644
--- a/src/3rdparty/phonon/phonon/medianode.cpp
+++ b/src/3rdparty/phonon/phonon/medianode.cpp
@@ -67,8 +67,8 @@ bool MediaNode::isValid() const
 
     MediaNodePrivate::~MediaNodePrivate()
     {
-        for (int i = 0 ; i < handlers.count(); ++i) {
-            handlers.at(i)->phononObjectDestroyed(this);
+        foreach (MediaNodeDestructionHandler *handler, handlers) {
+            handler->phononObjectDestroyed(this);
         }
         Factory::deregisterFrontendObject(this);
         delete m_backendObject;
diff --git a/src/3rdparty/phonon/phonon/mediaobject.cpp b/src/3rdparty/phonon/phonon/mediaobject.cpp
index 13d303c..0801bd7 100644
--- a/src/3rdparty/phonon/phonon/mediaobject.cpp
+++ b/src/3rdparty/phonon/phonon/mediaobject.cpp
@@ -300,15 +300,15 @@ void MediaObject::enqueue(const MediaSource &source)
 
 void MediaObject::enqueue(const QList<MediaSource> &sources)
 {
-    for (int i = 0; i < sources.count(); ++i) {
-        enqueue(sources.at(i));
+    foreach (const MediaSource &m, sources) {
+        enqueue(m);
     }
 }
 
 void MediaObject::enqueue(const QList<QUrl> &urls)
 {
-    for (int i = 0; i < urls.count(); ++i) {
-        enqueue(urls.at(i));
+    foreach (const QUrl &url, urls) {
+        enqueue(url);
     }
 }
 
@@ -502,8 +502,8 @@ void MediaObjectPrivate::setupBackendObject()
     }
 
 #ifndef QT_NO_PHONON_MEDIACONTROLLER
-    for (int i = 0 ; i < interfaceList.count(); ++i) {
-        interfaceList.at(i)->_backendObjectChanged();
+    foreach (FrontendInterfacePrivate *f, interfaceList) {
+        f->_backendObjectChanged();
     }
 #endif //QT_NO_PHONON_MEDIACONTROLLER
 
diff --git a/src/3rdparty/phonon/phonon/mediaobject.h b/src/3rdparty/phonon/phonon/mediaobject.h
index ade966a..c1fa3c6 100644
--- a/src/3rdparty/phonon/phonon/mediaobject.h
+++ b/src/3rdparty/phonon/phonon/mediaobject.h
@@ -15,7 +15,7 @@
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     Lesser General Public License for more details.
 
-    You should have received a copy of the GNU Lesser General Public
+    You should have received a copy of the GNU Lesser General Public 
     License along with this library.  If not, see <http://www.gnu.org/licenses/>.
 
 */
@@ -198,18 +198,18 @@ namespace Phonon
              * Check whether the current media may be seeked.
              *
              * \warning This information cannot be known immediately. It is best
-             * to also listen to the seekableChanged signal.
+             * to also listen to the hasVideoChanged signal.
              *
              * \code
-             *   connect(media, SIGNAL(seekableChanged(bool)), seekableChanged(bool));
+             *   connect(media, SIGNAL(hasVideoChanged(bool)), hasVideoChanged(bool));
              *   media->setCurrentSource("somevideo.avi");
-             *   media->isSeekable(); // returns false;
+             *   media->hasVideo(); // returns false;
              * }
              *
-             * void seekableChanged(bool b)
+             * void hasVideoChanged(bool b)
              * {
              *   // b == true
-             *   media->isSeekable(); // returns true;
+             *   media->hasVideo(); // returns true;
              * }
              * \endcode
              *
@@ -301,7 +301,7 @@ namespace Phonon
             void setCurrentSource(const MediaSource &source);
 
             /**
-             * Returns the queued media sources. This list does not include
+             * Returns the queued media sources. This does list does not include
              * the current source (returned by currentSource).
              */
             QList<MediaSource> queue() const;
@@ -456,6 +456,8 @@ namespace Phonon
         Q_SIGNALS:
             /**
              * Emitted when the state of the MediaObject has changed.
+             * In case you're not interested in the old state you can also
+             * connect to a slot that only has one State argument.
              *
              * @param newstate The state the Player is in now.
              * @param oldstate The state the Player was in before.
@@ -585,7 +587,7 @@ namespace Phonon
             /**
              * This signal is emitted as soon as the total time of the media file is
              * known or has changed. For most non-local media data the total
-             * time of the media can only be known after some time. Initially the
+             * time of the media can only be known after some time. At that time the
              * totalTime function can not return useful information. You have
              * to wait for this signal to know the real total time.
              *
diff --git a/src/3rdparty/phonon/phonon/mediasource.cpp b/src/3rdparty/phonon/phonon/mediasource.cpp
index be22dc3..c8db1e6 100644
--- a/src/3rdparty/phonon/phonon/mediasource.cpp
+++ b/src/3rdparty/phonon/phonon/mediasource.cpp
@@ -140,12 +140,8 @@ MediaSourcePrivate::~MediaSourcePrivate()
 {
 #ifndef QT_NO_PHONON_ABSTRACTMEDIASTREAM
     if (autoDelete) {
-        //here we use deleteLater because this object
-        //might be destroyed from another thread
-        if (stream)
-            stream->deleteLater();
-        if (ioDevice)
-            ioDevice->deleteLater();
+        delete stream;
+        delete ioDevice;
     }
 #endif //QT_NO_PHONON_ABSTRACTMEDIASTREAM
 }
diff --git a/src/3rdparty/phonon/phonon/objectdescription.cpp b/src/3rdparty/phonon/phonon/objectdescription.cpp
index e058b89..4afd9dd 100644
--- a/src/3rdparty/phonon/phonon/objectdescription.cpp
+++ b/src/3rdparty/phonon/phonon/objectdescription.cpp
@@ -29,6 +29,7 @@
 #include <QtCore/QStringList>
 #include "backendinterface.h"
 #include "platformplugin.h"
+#include "pulsesupport.h"
 
 QT_BEGIN_NAMESPACE
 
@@ -108,22 +109,24 @@ bool ObjectDescriptionData::isValid() const
 
 ObjectDescriptionData *ObjectDescriptionData::fromIndex(ObjectDescriptionType type, int index)
 {
+    BackendInterface *iface = qobject_cast<BackendInterface *>(Factory::backend());
+
     // prefer to get the ObjectDescriptionData from the platform plugin for audio devices
 #ifndef QT_NO_PHONON_PLATFORMPLUGIN
-    if (type == AudioOutputDeviceType || type == AudioCaptureDeviceType) {
-        PlatformPlugin *platformPlugin = Factory::platformPlugin();
-        if (platformPlugin) {
-            QList<int> indexes = platformPlugin->objectDescriptionIndexes(type);
-            if (indexes.contains(index)) {
-                QHash<QByteArray, QVariant> properties = platformPlugin->objectDescriptionProperties(type, index);
-                return new ObjectDescriptionData(index, properties);
+    if (!iface || !PulseSupport::getInstance()->isActive()) {
+        if (type == AudioOutputDeviceType || type == AudioCaptureDeviceType) {
+            PlatformPlugin *platformPlugin = Factory::platformPlugin();
+            if (platformPlugin) {
+                QList<int> indexes = platformPlugin->objectDescriptionIndexes(type);
+                if (indexes.contains(index)) {
+                    QHash<QByteArray, QVariant> properties = platformPlugin->objectDescriptionProperties(type, index);
+                    return new ObjectDescriptionData(index, properties);
+                }
             }
         }
     }
 #endif //QT_NO_PHONON_PLATFORMPLUGIN
 
-    QObject *b = Factory::backend();
-    BackendInterface *iface = qobject_cast<BackendInterface *>(b);
     if (iface) {
         QList<int> indexes = iface->objectDescriptionIndexes(type);
         if (indexes.contains(index)) {
diff --git a/src/3rdparty/phonon/phonon/objectdescriptionmodel.cpp b/src/3rdparty/phonon/phonon/objectdescriptionmodel.cpp
index 7237e91..3d48a46 100644
--- a/src/3rdparty/phonon/phonon/objectdescriptionmodel.cpp
+++ b/src/3rdparty/phonon/phonon/objectdescriptionmodel.cpp
@@ -67,8 +67,6 @@ static const char qt_meta_stringdata_Phonon__ObjectDescriptionModel_Visualizatio
 namespace Phonon
 {
 
-#if !defined(Q_CC_MINGW) || __MINGW32_MAJOR_VERSION >= 4
-
 template<> const QMetaObject ObjectDescriptionModel<AudioOutputDeviceType>::staticMetaObject = {
     { &QAbstractListModel::staticMetaObject, qt_meta_stringdata_Phonon__ObjectDescriptionModel_AudioOutputDeviceType,
       qt_meta_data_Phonon__ObjectDescriptionModel, 0 }
@@ -139,7 +137,6 @@ int ObjectDescriptionModel<type>::qt_metacall(QMetaObject::Call _c, int _id, voi
     return QAbstractListModel::qt_metacall(_c, _id, _a);
 }
 */
-#endif
 
 int ObjectDescriptionModelData::rowCount(const QModelIndex &parent) const
 {
@@ -321,8 +318,8 @@ bool ObjectDescriptionModelData::dropMimeData(ObjectDescriptionType type, const
         }
     }
     d->model->beginInsertRows(QModelIndex(), row, row + toInsert.size() - 1);
-    for (int i = 0 ; i < toInsert.count(); ++i) {
-        d->data.insert(row, toInsert.at(i));
+    foreach (const QExplicitlySharedDataPointer<ObjectDescriptionData> &obj, toInsert) {
+        d->data.insert(row, obj);
     }
     d->model->endInsertRows();
     return true;
@@ -365,8 +362,7 @@ QStringList ObjectDescriptionModelData::mimeTypes(ObjectDescriptionType type) co
     return QStringList(QLatin1String("application/x-phonon-objectdescription") + QString::number(static_cast<int>(type)));
 }
 
-#if !defined(Q_CC_MINGW) || __MINGW32_MAJOR_VERSION >= 4
-#if !defined(Q_CC_MSVC) || _MSC_VER > 1300 || defined(Q_CC_INTEL)
+#if !defined(Q_CC_MSVC) || _MSC_VER > 1300 || defined(Q_CC_INTEL) || defined(Q_CC_MINGW)
 #define INSTANTIATE_META_FUNCTIONS(type) \
 template const QMetaObject *ObjectDescriptionModel<type>::metaObject() const; \
 template void *ObjectDescriptionModel<type>::qt_metacast(const char *)
@@ -384,7 +380,6 @@ INSTANTIATE_META_FUNCTIONS(VideoCodecType);
 INSTANTIATE_META_FUNCTIONS(ContainerFormatType);
 INSTANTIATE_META_FUNCTIONS(VisualizationType);
 */
-#endif //Q_CC_MINGW
 } // namespace Phonon
 
 #endif //QT_NO_PHONON_OBJECTDESCRIPTIONMODEL
diff --git a/src/3rdparty/phonon/phonon/objectdescriptionmodel.h b/src/3rdparty/phonon/phonon/objectdescriptionmodel.h
index 96187c3..495225e 100644
--- a/src/3rdparty/phonon/phonon/objectdescriptionmodel.h
+++ b/src/3rdparty/phonon/phonon/objectdescriptionmodel.h
@@ -35,6 +35,18 @@ QT_BEGIN_NAMESPACE
 
 #ifndef QT_NO_PHONON_OBJECTDESCRIPTIONMODEL
 
+/* MinGW 3.4.x gives an ICE when trying to instantiate one of the
+   ObjectDescriptionModel<foo> classes because it can't handle
+   half exported classes correct. gcc 4.3.x has a fix for this but
+   we currently there's no official gcc 4.3 on windows available.
+   Because of this we need this little hack
+ */
+#if defined(Q_CC_MINGW)
+#define PHONON_EXPORT_ODM
+#else
+#define PHONON_EXPORT_ODM  PHONON_EXPORT
+#endif
+
 namespace Phonon
 {
     class ObjectDescriptionModelDataPrivate;
@@ -139,21 +151,6 @@ namespace Phonon
             ObjectDescriptionModelDataPrivate *const d;
     };
 
-/* Required to ensure template class vtables are exported on both symbian
-and existing builds. */
-#if defined(Q_OS_SYMBIAN) && defined(Q_CC_RVCT)
-// RVCT compiler (2.2.686) requires the export declaration to be on the class to export vtables
-// MWC compiler works both ways
-// GCCE compiler is unknown (it can't compile QtCore yet)
-#define PHONON_TEMPLATE_CLASS_EXPORT PHONON_EXPORT
-#define PHONON_TEMPLATE_CLASS_MEMBER_EXPORT
-#else
-// Windows builds (at least) do not support export declaration on templated class
-// But if you export a member function, the vtable is implicitly exported
-#define PHONON_TEMPLATE_CLASS_EXPORT
-#define PHONON_TEMPLATE_CLASS_MEMBER_EXPORT PHONON_EXPORT
-#endif
-
     /** \class ObjectDescriptionModel objectdescriptionmodel.h Phonon/ObjectDescriptionModel
      * \short The ObjectDescriptionModel class provides a model from
      * a list of ObjectDescription objects.
@@ -190,26 +187,17 @@ and existing builds. */
      * \author Matthias Kretz <kretz@kde.org>
      */
     template<ObjectDescriptionType type>
-    class PHONON_TEMPLATE_CLASS_EXPORT ObjectDescriptionModel : public QAbstractListModel
+    class ObjectDescriptionModel : public QAbstractListModel
     {
         public:
             Q_OBJECT_CHECK
-
-/* MinGW 3.4.x gives an ICE when trying to instantiate one of the
-   ObjectDescriptionModel<foo> classes because it can't handle
-   half exported classes correct. gcc 4.3.x has a fix for this but
-   we currently there's no official gcc 4.3 on windows available.
-   Because of this we need this little hack
- */
-#if !defined(Q_CC_MINGW) || __MINGW32_MAJOR_VERSION >= 4
             /** \internal */
-            static PHONON_TEMPLATE_CLASS_MEMBER_EXPORT const QMetaObject staticMetaObject;
+            static PHONON_EXPORT const QMetaObject staticMetaObject;
             /** \internal */
-            PHONON_TEMPLATE_CLASS_MEMBER_EXPORT const QMetaObject *metaObject() const;
+            PHONON_EXPORT_ODM const QMetaObject *metaObject() const;
             /** \internal */
-            PHONON_TEMPLATE_CLASS_MEMBER_EXPORT void *qt_metacast(const char *_clname);
+            PHONON_EXPORT_ODM void *qt_metacast(const char *_clname);
             //int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
-#endif
 
             /**
              * Returns the number of rows in the model. This value corresponds
@@ -307,8 +295,8 @@ and existing builds. */
              */
             inline void setModelData(const QList<ObjectDescription<type> > &data) { //krazy:exclude=inline
                 QList<QExplicitlySharedDataPointer<ObjectDescriptionData> > list;
-                for (int i = 0; i < data.count(); ++i) {
-                    list += data.at(i).d;
+                Q_FOREACH (const ObjectDescription<type> &desc, data) {
+                    list << desc.d;
                 }
                 d->setModelData(list);
             }
@@ -322,8 +310,8 @@ and existing builds. */
             inline QList<ObjectDescription<type> > modelData() const { //krazy:exclude=inline
                 QList<ObjectDescription<type> > ret;
                 QList<QExplicitlySharedDataPointer<ObjectDescriptionData> > list = d->modelData();
-                for (int i = 0; i < list.count(); ++i) {
-                    ret << ObjectDescription<type>(list.at(i));
+                Q_FOREACH (const QExplicitlySharedDataPointer<ObjectDescriptionData> &data, list) {
+                    ret << ObjectDescription<type>(data);
                 }
                 return ret;
             }
diff --git a/src/3rdparty/phonon/phonon/path.cpp b/src/3rdparty/phonon/phonon/path.cpp
index 51c33b2..b225697 100644
--- a/src/3rdparty/phonon/phonon/path.cpp
+++ b/src/3rdparty/phonon/phonon/path.cpp
@@ -58,8 +58,8 @@ class ConnectionTransaction
 PathPrivate::~PathPrivate()
 {
 #ifndef QT_NO_PHONON_EFFECT
-    for (int i = 0; i < effects.count(); ++i) {
-        effects.at(i)->k_ptr->removeDestructionHandler(this);
+    foreach (Effect *e, effects) {
+        e->k_ptr->removeDestructionHandler(this);
     }
     delete effectsParent;
 #endif
@@ -233,8 +233,8 @@ bool Path::disconnect()
     if (d->sourceNode)
         list << d->sourceNode->k_ptr->backendObject();
 #ifndef QT_NO_PHONON_EFFECT
-    for (int i = 0; i < d->effects.count(); ++i) {
-        list << d->effects.at(i)->k_ptr->backendObject();
+    foreach(Effect *e, d->effects) {
+        list << e->k_ptr->backendObject();
     }
 #endif
     if (d->sinkNode) {
@@ -260,8 +260,8 @@ bool Path::disconnect()
         d->sourceNode = 0;
 
 #ifndef QT_NO_PHONON_EFFECT
-        for (int i = 0; i < d->effects.count(); ++i) {
-            d->effects.at(i)->k_ptr->removeDestructionHandler(d.data());
+        foreach(Effect *e, d->effects) {
+            e->k_ptr->removeDestructionHandler(d.data());
         }
         d->effects.clear();
 #endif 
@@ -292,13 +292,11 @@ MediaNode *Path::sink() const
 bool PathPrivate::executeTransaction( const QList<QObjectPair> &disconnections, const QList<QObjectPair> &connections)
 {
     QSet<QObject*> nodesForTransaction;
-    for (int i = 0; i < disconnections.count(); ++i) {
-        const QObjectPair &pair = disconnections.at(i);
+    foreach(const QObjectPair &pair, disconnections) {
         nodesForTransaction << pair.first;
         nodesForTransaction << pair.second;
     }
-    for (int i = 0; i < connections.count(); ++i) {
-        const QObjectPair &pair = connections.at(i);
+    foreach(const QObjectPair &pair, connections) {
         nodesForTransaction << pair.first;
         nodesForTransaction << pair.second;
     }
@@ -310,8 +308,8 @@ bool PathPrivate::executeTransaction( const QList<QObjectPair> &disconnections,
     if (!transaction)
         return false;
 
-    QList<QObjectPair>::const_iterator it = disconnections.constBegin();
-    for(;it != disconnections.constEnd();++it) {
+    QList<QObjectPair>::const_iterator it = disconnections.begin();
+    for(;it != disconnections.end();++it) {
         const QObjectPair &pair = *it;
         if (!backend->disconnectNodes(pair.first, pair.second)) {
 
@@ -327,8 +325,8 @@ bool PathPrivate::executeTransaction( const QList<QObjectPair> &disconnections,
         }
     }
 
-    for(it = connections.constBegin(); it != connections.constEnd(); ++it) {
-        const QObjectPair pair = *it;
+    for(it = connections.begin(); it != connections.end();++it) {
+        const QObjectPair &pair = *it;
         if (!backend->connectNodes(pair.first, pair.second)) {
             //Error: a connection failed
             QList<QObjectPair>::const_iterator it2 = connections.begin();
@@ -340,8 +338,7 @@ bool PathPrivate::executeTransaction( const QList<QObjectPair> &disconnections,
             }
 
             //and now let's reconnect the nodes that were disconnected: rollback
-            for (int i = 0; i < disconnections.count(); ++i) {
-                const QObjectPair &pair = disconnections.at(i);
+            foreach(const QObjectPair &pair, disconnections) {
                 bool success = backend->connectNodes(pair.first, pair.second);
                 Q_ASSERT(success); //a failure here means it is impossible to reestablish the connection
                 Q_UNUSED(success);
@@ -420,8 +417,7 @@ void PathPrivate::phononObjectDestroyed(MediaNodePrivate *mediaNodePrivate)
         sinkNode = 0;
     } else {
 #ifndef QT_NO_PHONON_EFFECT
-        for (int i = 0; i < effects.count(); ++i) {
-            Effect *e = effects.at(i);
+        foreach (Effect *e, effects) {
             if (e->k_ptr == mediaNodePrivate) {
                 removeEffect(e);
             }
diff --git a/src/3rdparty/phonon/phonon/phonondefs.h b/src/3rdparty/phonon/phonon/phonondefs.h
index 15a1815..765eb1c 100644
--- a/src/3rdparty/phonon/phonon/phonondefs.h
+++ b/src/3rdparty/phonon/phonon/phonondefs.h
@@ -29,6 +29,11 @@
 QT_BEGIN_HEADER
 QT_BEGIN_NAMESPACE
 
+#ifdef PHONON_BACKEND_VERSION_4_4
+# ifndef PHONON_BACKEND_VERSION_4_3
+#  define PHONON_BACKEND_VERSION_4_3
+# endif
+#endif
 #ifdef PHONON_BACKEND_VERSION_4_3
 # ifndef PHONON_BACKEND_VERSION_4_2
 #  define PHONON_BACKEND_VERSION_4_2
diff --git a/src/3rdparty/phonon/phonon/phononnamespace.h b/src/3rdparty/phonon/phonon/phononnamespace.h
index ec42d51..2492ee6 100644
--- a/src/3rdparty/phonon/phonon/phononnamespace.h
+++ b/src/3rdparty/phonon/phonon/phononnamespace.h
@@ -6,7 +6,7 @@
     License as published by the Free Software Foundation; either
     version 2.1 of the License, or (at your option) version 3, or any
     later version accepted by the membership of KDE e.V. (or its
-    successor approved by the membership of KDE e.V.), Nokia Corporation 
+    successor approved by the membership of KDE e.V.), Trolltech ASA 
     (or its successors, if any) and the KDE Free Qt Foundation, which shall
     act as a proxy defined in Section 6 of version 3 of the license.
 
diff --git a/src/3rdparty/phonon/phonon/pulsesupport.cpp b/src/3rdparty/phonon/phonon/pulsesupport.cpp
new file mode 100644
index 0000000..997df9a
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/pulsesupport.cpp
@@ -0,0 +1,966 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2009 Colin Guthrie <cguthrie@mandriva.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include <QtCore/QtGlobal>
+#include <QtCore/QEventLoop>
+#include <QtCore/QDebug>
+#include <QtCore/QStringList>
+
+#ifdef HAVE_PULSEAUDIO
+#include <glib.h>
+#include <pulse/pulseaudio.h>
+#include <pulse/xmalloc.h>
+#include <pulse/glib-mainloop.h>
+#include <pulse/ext-device-manager.h>
+#endif // HAVE_PULSEAUDIO
+
+#include "pulsesupport.h"
+
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+
+static PulseSupport* s_instance = NULL;
+
+#ifdef HAVE_PULSEAUDIO
+/***
+* Prints a conditional debug message based on the current debug level
+* If obj is provided, classname and objectname will be printed as well
+*
+* see debugLevel()
+*/
+
+static int debugLevel() {
+    static int level = -1;
+    if (level < 1) {
+        level = 0;
+        QString pulseenv = qgetenv("PHONON_PULSEAUDIO_DEBUG");
+        int l = pulseenv.toInt();
+        if (l > 0)
+            level = (l > 2 ? 2 : l);
+    }
+    return level;
+}
+
+static void logMessage(const QString &message, int priority = 2, QObject *obj=0);
+static void logMessage(const QString &message, int priority, QObject *obj)
+{
+    if (debugLevel() > 0) {
+        QString output;
+        if (obj) {
+            // Strip away namespace from className
+            QString className(obj->metaObject()->className());
+            int nameLength = className.length() - className.lastIndexOf(':') - 1;
+            className = className.right(nameLength);
+            output.sprintf("%s %s (%s %p)", message.toLatin1().constData(), 
+                           obj->objectName().toLatin1().constData(), 
+                           className.toLatin1().constData(), obj);
+        }
+        else {
+            output = message;
+        }
+        if (priority <= debugLevel()) {
+            qDebug() << QString("PulseSupport(%1): %2").arg(priority).arg(output);
+        }
+    }
+}
+
+
+class AudioDevice
+{
+    public:
+        inline
+        AudioDevice(QString name, QString desc, QString icon, uint32_t index)
+        : pulseName(name), pulseIndex(index)
+        {
+            properties["name"] = desc;
+            properties["description"] = ""; // We don't have descriptions (well we do, but we use them as the name!)
+            properties["icon"] = icon;
+            properties["available"] = (index != PA_INVALID_INDEX);
+            properties["isAdvanced"] = false; // Nothing is advanced!
+        }
+
+        // Needed for QMap
+        inline AudioDevice() {}
+
+        QString pulseName;
+        uint32_t pulseIndex;
+        QHash<QByteArray, QVariant> properties;
+};
+bool operator!=(const AudioDevice &a, const AudioDevice &b)
+{
+    return !(a.pulseName == b.pulseName && a.properties == b.properties);
+}
+
+class PulseUserData
+{
+    public:
+        inline 
+        PulseUserData()
+        {
+        }
+
+        QMap<QString, AudioDevice> newOutputDevices;
+        QMap<Phonon::Category, QMap<int, int> > newOutputDevicePriorities; // prio, device
+
+        QMap<QString, AudioDevice> newCaptureDevices;
+        QMap<Phonon::Category, QMap<int, int> > newCaptureDevicePriorities; // prio, device
+};
+
+static QMap<QString, Phonon::Category> s_roleCategoryMap;
+
+static bool s_pulseActive = false;
+
+static pa_glib_mainloop *s_mainloop = NULL;
+static pa_context *s_context = NULL;
+static QEventLoop *s_connectionEventloop = NULL;
+
+
+
+static int s_deviceIndexCounter = 0;
+
+static QMap<QString, int> s_outputDeviceIndexes;
+static QMap<int, AudioDevice> s_outputDevices;
+static QMap<Phonon::Category, QMap<int, int> > s_outputDevicePriorities; // prio, device
+static QMap<QString, uint32_t> s_outputStreamIndexMap;
+static QMap<QString, int> s_outputStreamMoveQueue;
+
+static QMap<QString, int> s_captureDeviceIndexes;
+static QMap<int, AudioDevice> s_captureDevices;
+static QMap<Phonon::Category, QMap<int, int> > s_captureDevicePriorities; // prio, device
+static QMap<QString, uint32_t> s_captureStreamIndexMap;
+static QMap<QString, int> s_captureStreamMoveQueue;
+
+
+static void ext_device_manager_subscribe_cb(pa_context *, void *);
+static void ext_device_manager_read_cb(pa_context *c, const pa_ext_device_manager_info *info, int eol, void *userdata) {
+    Q_ASSERT(c);
+    Q_ASSERT(userdata);
+
+    // If this is our first iteration, set things up properly
+    if (s_connectionEventloop) {
+        s_connectionEventloop->exit(0);
+        s_connectionEventloop = NULL;
+        s_pulseActive = true;
+
+        pa_operation *o;
+        pa_ext_device_manager_set_subscribe_cb(c, ext_device_manager_subscribe_cb, NULL);
+        if ((o = pa_ext_device_manager_subscribe(c, 1, NULL, NULL)))
+            pa_operation_unref(o);
+    }
+
+    if (eol < 0) {
+        logMessage(QString("Failed to initialize device manager extension: %1").arg(pa_strerror(pa_context_errno(c))));
+        // OK so we don't have the device manager extension, but we can show a single device and fake it.
+        int index;
+        s_outputDeviceIndexes.clear();
+        s_outputDevices.clear();
+        s_outputDevicePriorities.clear();
+        index = s_deviceIndexCounter++;
+        s_outputDeviceIndexes.insert("sink:default", index);
+        s_outputDevices.insert(index, AudioDevice("sink:default", QObject::tr("PulseAudio Sound Server").toUtf8(), "audio-backend-pulseaudio", 0));
+        for (int i = Phonon::NoCategory; i <= Phonon::LastCategory; ++i) {
+            Phonon::Category cat = static_cast<Phonon::Category>(i);
+            s_outputDevicePriorities[cat].insert(0, index);
+        }
+
+        s_captureDeviceIndexes.clear();
+        s_captureDevices.clear();
+        s_captureDevicePriorities.clear();
+        index = s_deviceIndexCounter++;
+        s_captureDeviceIndexes.insert("source:default", index);
+        s_captureDevices.insert(index, AudioDevice("source:default", QObject::tr("PulseAudio Sound Server").toUtf8(), "audio-backend-pulseaudio", 0));
+        for (int i = Phonon::NoCategory; i <= Phonon::LastCategory; ++i) {
+            Phonon::Category cat = static_cast<Phonon::Category>(i);
+            s_captureDevicePriorities[cat].insert(0, index);
+        }
+
+        return;
+    }
+
+    PulseUserData *u = reinterpret_cast<PulseUserData*>(userdata);
+    if (eol) {
+        // We're done reading the data, so order it by priority and copy it into the
+        // static variables where it can then be accessed by those classes that need it.
+
+        QMap<QString, AudioDevice>::iterator newdev_it;
+
+        // Check for new output devices or things changing about known output devices.
+        bool output_changed = false;
+        for (newdev_it = u->newOutputDevices.begin(); newdev_it != u->newOutputDevices.end(); ++newdev_it) {
+            QString name = newdev_it.key();
+
+            // The name + index map is always written when a new device is added.
+            Q_ASSERT(s_outputDeviceIndexes.contains(name));
+
+            int index = s_outputDeviceIndexes[name];
+            if (!s_outputDevices.contains(index)) {
+                // This is a totally new device
+                output_changed = true;
+                logMessage(QString("Brand New Output Device Found."));
+                s_outputDevices.insert(index, *newdev_it);
+            } else  if (s_outputDevices[index] != *newdev_it) {
+                // We have this device already, but is it different?
+                output_changed = true;
+                logMessage(QString("Change to Existing Output Device (may be Added/Removed or something else)"));
+                s_outputDevices.remove(index);
+                s_outputDevices.insert(index, *newdev_it);
+            }
+        }
+        // Go through the output devices we know about and see if any are no longer mentioned in the list.
+        QMutableMapIterator<QString, int> output_existing_it(s_outputDeviceIndexes);
+        while (output_existing_it.hasNext()) {
+            output_existing_it.next();
+            if (!u->newOutputDevices.contains(output_existing_it.key())) {
+                output_changed = true;
+                logMessage(QString("Output Device Completely Removed"));
+                s_outputDevices.remove(output_existing_it.value());
+                output_existing_it.remove();
+            }
+        }
+
+        // Check for new capture devices or things changing about known capture devices.
+        bool capture_changed = false;
+        for (newdev_it = u->newCaptureDevices.begin(); newdev_it != u->newCaptureDevices.end(); ++newdev_it) {
+            QString name = newdev_it.key();
+
+            // The name + index map is always written when a new device is added.
+            Q_ASSERT(s_captureDeviceIndexes.contains(name));
+
+            int index = s_captureDeviceIndexes[name];
+            if (!s_captureDevices.contains(index)) {
+                // This is a totally new device
+                capture_changed = true;
+                logMessage(QString("Brand New Capture Device Found."));
+                s_captureDevices.insert(index, *newdev_it);
+            } else  if (s_captureDevices[index] != *newdev_it) {
+                // We have this device already, but is it different?
+                capture_changed = true;
+                logMessage(QString("Change to Existing Capture Device (may be Added/Removed or something else)"));
+                s_captureDevices.remove(index);
+                s_captureDevices.insert(index, *newdev_it);
+            }
+        }
+        // Go through the capture devices we know about and see if any are no longer mentioned in the list.
+        QMutableMapIterator<QString, int> capture_existing_it(s_captureDeviceIndexes);
+        while (capture_existing_it.hasNext()) {
+            capture_existing_it.next();
+            if (!u->newCaptureDevices.contains(capture_existing_it.key())) {
+                capture_changed = true;
+                logMessage(QString("Capture Device Completely Removed"));
+                s_captureDevices.remove(capture_existing_it.value());
+                capture_existing_it.remove();
+            }
+        }
+
+        // Just copy accross the new priority lists as we know they are valid
+        if (s_outputDevicePriorities != u->newOutputDevicePriorities) {
+            output_changed = true;
+            s_outputDevicePriorities = u->newOutputDevicePriorities;
+        }
+        if (s_captureDevicePriorities != u->newCaptureDevicePriorities) {
+            capture_changed = true;
+            s_captureDevicePriorities = u->newCaptureDevicePriorities;
+        }
+
+        if (s_instance) {
+            if (output_changed)
+                s_instance->emitObjectDescriptionChanged(AudioOutputDeviceType);
+            if (capture_changed)
+                s_instance->emitObjectDescriptionChanged(AudioCaptureDeviceType);
+        }
+
+        // We can free the user data as we will not be called again.
+        delete u;
+
+        // Some debug
+        logMessage(QString("Output Device Priority List:"));
+        for (int i = Phonon::NoCategory; i <= Phonon::LastCategory; ++i) {
+            Phonon::Category cat = static_cast<Phonon::Category>(i);
+            if (s_outputDevicePriorities.contains(cat)) {
+                logMessage(QString("  Phonon Category %1").arg(cat));
+                int count = 0;
+                foreach (int j, s_outputDevicePriorities[cat]) {
+                    QHash<QByteArray, QVariant> &props = s_outputDevices[j].properties;
+                    logMessage(QString("    %1. %2 (Available: %3)").arg(++count).arg(props["name"].toString()).arg(props["available"].toBool()));
+                }
+            }
+        }
+        logMessage(QString("Capture Device Priority List:"));
+        for (int i = Phonon::NoCategory; i <= Phonon::LastCategory; ++i) {
+            Phonon::Category cat = static_cast<Phonon::Category>(i);
+            if (s_captureDevicePriorities.contains(cat)) {
+                logMessage(QString("  Phonon Category %1").arg(cat));
+                int count = 0;
+                foreach (int j, s_captureDevicePriorities[cat]) {
+                    QHash<QByteArray, QVariant> &props = s_captureDevices[j].properties;
+                    logMessage(QString("    %1. %2 (Available: %3)").arg(++count).arg(props["name"].toString()).arg(props["available"].toBool()));
+                }
+            }
+        }
+    }
+
+    if (!info)
+        return;
+
+    Q_ASSERT(info->name);
+    Q_ASSERT(info->description);
+    Q_ASSERT(info->icon);
+
+    // QString wrapper
+    QString name(info->name);
+    int index;
+    QMap<Phonon::Category, QMap<int, int> > *new_prio_map_cats; // prio, device
+    QMap<QString, AudioDevice> *new_devices;
+
+    if (name.startsWith("sink:")) {
+        new_devices = &u->newOutputDevices;
+        new_prio_map_cats = &u->newOutputDevicePriorities;
+
+        if (s_outputDeviceIndexes.contains(name))
+            index = s_outputDeviceIndexes[name];
+        else
+            index = s_outputDeviceIndexes[name] = s_deviceIndexCounter++;
+    } else if (name.startsWith("source:")) {
+        new_devices = &u->newCaptureDevices;
+        new_prio_map_cats = &u->newCaptureDevicePriorities;
+
+        if (s_captureDeviceIndexes.contains(name))
+            index = s_captureDeviceIndexes[name];
+        else
+            index = s_captureDeviceIndexes[name] = s_deviceIndexCounter++;
+    } else {
+        // This indicates a bug in pulseaudio.
+        return;
+    }
+
+    // Add the new device itself.
+    new_devices->insert(name, AudioDevice(name, info->description, info->icon, info->index));
+
+    // For each role in the priority, map it to a phonon category and store the order.
+    for (uint32_t i = 0; i < info->n_role_priorities; ++i) {
+        pa_ext_device_manager_role_priority_info* role_prio = &info->role_priorities[i];
+        Q_ASSERT(role_prio->role);
+
+        if (s_roleCategoryMap.contains(role_prio->role)) {
+            Phonon::Category cat = s_roleCategoryMap[role_prio->role];
+
+            (*new_prio_map_cats)[cat].insert(role_prio->priority, index);
+        }
+    }
+}
+
+static void set_output_device(QString streamUuid)
+{
+    // If we only have one device, bail. This will be true if we are not using module-device-manager
+    if (s_outputDevices.size() < 2)
+        return;
+
+    if (!s_outputStreamMoveQueue.contains(streamUuid))
+        return;
+
+    if (!s_outputStreamIndexMap.contains(streamUuid))
+        return;
+
+    if (s_outputStreamIndexMap[streamUuid] == PA_INVALID_INDEX)
+        return;
+
+    int device = s_outputStreamMoveQueue[streamUuid];
+    if (!s_outputDevices.contains(device))
+        return;
+
+    // We don't remove the uuid from the s_captureStreamMoveQueue
+    // as an application may reuse the phonon AudioOutput object
+
+    uint32_t pulse_device_index = s_outputDevices[device].pulseIndex;
+    uint32_t pulse_stream_index = s_outputStreamIndexMap[streamUuid];
+
+    const QVariant var = s_outputDevices[device].properties["name"];
+    logMessage(QString("Moving Pulse Sink Input %1 to '%2' (Pulse Sink %3)").arg(pulse_stream_index).arg(var.toString()).arg(pulse_device_index));
+
+    /// @todo Find a way to move the stream without saving it... We don't want to pollute the stream restore db.
+    pa_operation* o;
+    if (!(o = pa_context_move_sink_input_by_index(s_context, pulse_stream_index, pulse_device_index, NULL, NULL))) {
+        logMessage(QString("pa_context_move_sink_input_by_index() failed"));
+        return;
+    }
+    pa_operation_unref(o);
+}
+
+static void set_capture_device(QString streamUuid)
+{
+    // If we only have one device, bail. This will be true if we are not using module-device-manager
+    if (s_captureDevices.size() < 2)
+        return;
+
+    if (!s_captureStreamMoveQueue.contains(streamUuid))
+        return;
+
+    if (!s_captureStreamIndexMap.contains(streamUuid))
+        return;
+
+    if (s_captureStreamIndexMap[streamUuid] == PA_INVALID_INDEX)
+        return;
+
+    int device = s_captureStreamMoveQueue[streamUuid];
+    if (!s_captureDevices.contains(device))
+        return;
+
+    // We don't remove the uuid from the s_captureStreamMoveQueue
+    // as an application may reuse the phonon AudioCapture object (when it exists!)
+
+    uint32_t pulse_device_index = s_captureDevices[device].pulseIndex;
+    uint32_t pulse_stream_index = s_captureStreamIndexMap[streamUuid];
+
+    const QVariant var = s_captureDevices[device].properties["name"];
+    logMessage(QString("Moving Pulse Source Output %1 to '%2' (Pulse Sink %3)").arg(pulse_stream_index).arg(var.toString()).arg(pulse_device_index));
+
+    /// @todo Find a way to move the stream without saving it... We don't want to pollute the stream restore db.
+    pa_operation* o;
+    if (!(o = pa_context_move_source_output_by_index(s_context, pulse_stream_index, pulse_device_index, NULL, NULL))) {
+        logMessage(QString("pa_context_move_source_output_by_index() failed"));
+        return;
+    }
+    pa_operation_unref(o);
+}
+
+void sink_input_cb(pa_context *c, const pa_sink_input_info *i, int eol, void *userdata) {
+    Q_UNUSED(userdata);
+    Q_ASSERT(c);
+
+    if (eol < 0) {
+        if (pa_context_errno(c) == PA_ERR_NOENTITY)
+            return;
+
+        logMessage(QString("Sink input callback failure"));
+        return;
+    }
+
+    if (eol > 0)
+        return;
+
+    Q_ASSERT(i);
+
+    // loop through (*i) and extract phonon->streamindex...
+    const char *t;
+    if ((t = pa_proplist_gets(i->proplist, "phonon.streamid"))) {
+        logMessage(QString("Found PulseAudio stream index %1 for Phonon Output Stream %2").arg(i->index).arg(t));
+        s_outputStreamIndexMap[QString(t)] = i->index;
+        // Process any pending moves...
+        set_output_device(QString(t));
+    }
+}
+
+void source_output_cb(pa_context *c, const pa_source_output_info *i, int eol, void *userdata) {
+    Q_UNUSED(userdata);
+    Q_ASSERT(c);
+
+    if (eol < 0) {
+        if (pa_context_errno(c) == PA_ERR_NOENTITY)
+            return;
+
+        logMessage(QString("Source output callback failure"));
+        return;
+    }
+
+    if (eol > 0)
+        return;
+
+    Q_ASSERT(i);
+
+    // loop through (*i) and extract phonon->streamindex...
+    const char *t;
+    if ((t = pa_proplist_gets(i->proplist, "phonon.streamid"))) {
+        logMessage(QString("Found PulseAudio stream index %1 for Phonon Capture Stream %2").arg(i->index).arg(t));
+        s_captureStreamIndexMap[QString(t)] = i->index;
+        // Process any pending moves...
+        set_capture_device(QString(t));
+    }
+}
+
+static void subscribe_cb(pa_context *c, pa_subscription_event_type_t t, uint32_t index, void *userdata) {
+    Q_UNUSED(userdata);
+
+    switch (t & PA_SUBSCRIPTION_EVENT_FACILITY_MASK) {
+        case PA_SUBSCRIPTION_EVENT_SINK_INPUT:
+            if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                QString phononid = s_outputStreamIndexMap.key(index);
+                if (!phononid.isEmpty()) {
+                    if (s_outputStreamIndexMap.contains(phononid)) {
+                        logMessage(QString("Phonon Output Stream %1 is gone at the PA end. Marking it as invalid in our cache as we may reuse it.").arg(phononid));
+                        s_outputStreamIndexMap[phononid] = PA_INVALID_INDEX;
+                    } else {
+                        logMessage(QString("Removing Phonon Output Stream %1 (it's gone!)").arg(phononid));
+                        s_outputStreamIndexMap.remove(phononid);
+                        s_outputStreamMoveQueue.remove(phononid);
+                    }
+                }
+            } else {
+                pa_operation *o;
+                if (!(o = pa_context_get_sink_input_info(c, index, sink_input_cb, NULL))) {
+                    logMessage(QString("pa_context_get_sink_input_info() failed"));
+                    return;
+                }
+                pa_operation_unref(o);
+            }
+            break;
+
+        case PA_SUBSCRIPTION_EVENT_SOURCE_OUTPUT:
+            if ((t & PA_SUBSCRIPTION_EVENT_TYPE_MASK) == PA_SUBSCRIPTION_EVENT_REMOVE) {
+                QString phononid = s_captureStreamIndexMap.key(index);
+                if (!phononid.isEmpty()) {
+                    if (s_captureStreamIndexMap.contains(phononid)) {
+                        logMessage(QString("Phonon Capture Stream %1 is gone at the PA end. Marking it as invalid in our cache as we may reuse it.").arg(phononid));
+                        s_captureStreamIndexMap[phononid] = PA_INVALID_INDEX;
+                    } else {
+                        logMessage(QString("Removing Phonon Capture Stream %1 (it's gone!)").arg(phononid));
+                        s_captureStreamIndexMap.remove(phononid);
+                        s_captureStreamMoveQueue.remove(phononid);
+                    }
+                }
+            } else {
+                pa_operation *o;
+                if (!(o = pa_context_get_source_output_info(c, index, source_output_cb, NULL))) {
+                    logMessage(QString("pa_context_get_sink_input_info() failed"));
+                    return;
+                }
+                pa_operation_unref(o);
+            }
+            break;
+    }
+}
+
+
+static void ext_device_manager_subscribe_cb(pa_context *c, void *) {
+    Q_ASSERT(c);
+
+    pa_operation *o;
+    PulseUserData *u = new PulseUserData; /** @todo Make some object to receive the info... */
+    if (!(o = pa_ext_device_manager_read(c, ext_device_manager_read_cb, u))) {
+        // We need to deal with failure on first iteration
+        if (s_connectionEventloop) {
+            s_connectionEventloop->exit(0);
+            s_connectionEventloop = NULL;
+        }
+        logMessage(QString("pa_ext_device_manager_read() failed"));
+        return;
+    }
+    pa_operation_unref(o);
+
+
+    // Register for the stream changes...
+    pa_context_set_subscribe_callback(c, subscribe_cb, NULL);
+
+    if (!(o = pa_context_subscribe(c, (pa_subscription_mask_t)
+                                   (PA_SUBSCRIPTION_MASK_SINK_INPUT|
+                                    PA_SUBSCRIPTION_MASK_SOURCE_OUTPUT), NULL, NULL))) {
+        logMessage(QString("pa_context_subscribe() failed"));
+        return;
+    }
+    pa_operation_unref(o);
+}
+
+static void context_state_callback(pa_context *c, void *)
+{
+    Q_ASSERT(c);
+
+    switch (pa_context_get_state(c)) {
+        case PA_CONTEXT_UNCONNECTED:
+        case PA_CONTEXT_CONNECTING:
+        case PA_CONTEXT_AUTHORIZING:
+        case PA_CONTEXT_SETTING_NAME:
+            break;
+
+        case PA_CONTEXT_READY:
+            // Attempt to load things up
+            ext_device_manager_subscribe_cb(c, NULL);
+            break;
+
+        case PA_CONTEXT_FAILED:
+            s_pulseActive = false;
+            if (s_connectionEventloop) {
+                s_connectionEventloop->exit(0);
+                s_connectionEventloop = NULL;
+            }
+            break;
+
+        case PA_CONTEXT_TERMINATED:
+        default:
+            s_pulseActive = false;
+            /// @todo Deal with reconnection...
+            break;
+    }
+}
+#endif // HAVE_PULSEAUDIO
+
+
+PulseSupport* PulseSupport::getInstance()
+{
+    if (NULL == s_instance) {
+        s_instance = new PulseSupport();
+    }
+    return s_instance;
+}
+
+void PulseSupport::shutdown()
+{
+    if (NULL != s_instance) {
+        delete s_instance;
+        s_instance = NULL;
+    }
+}
+
+PulseSupport::PulseSupport()
+ : QObject()
+{
+#ifdef HAVE_PULSEAUDIO
+    // Initialise our map (is there a better way to do this?)
+    s_roleCategoryMap["none"] = Phonon::NoCategory;
+    s_roleCategoryMap["video"] = Phonon::VideoCategory;
+    s_roleCategoryMap["music"] = Phonon::MusicCategory;
+    s_roleCategoryMap["game"] = Phonon::GameCategory;
+    s_roleCategoryMap["event"] = Phonon::NotificationCategory;
+    s_roleCategoryMap["phone"] = Phonon::CommunicationCategory;
+    //s_roleCategoryMap["animation"]; // No Mapping
+    //s_roleCategoryMap["production"]; // No Mapping
+    s_roleCategoryMap["a11y"] = Phonon::AccessibilityCategory;
+
+    // To allow for easy debugging, give an easy way to disable this pulseaudio check
+    QString pulseenv = qgetenv("PHONON_PULSEAUDIO_DISABLE");
+    if (pulseenv.toInt())
+        return;
+
+    s_mainloop = pa_glib_mainloop_new(NULL);
+    Q_ASSERT(s_mainloop);
+    pa_mainloop_api *api = pa_glib_mainloop_get_api(s_mainloop);
+
+    // We create a simple event loop to allow the glib loop
+    // to iterate until we've connected or not to the server.
+    s_connectionEventloop = new QEventLoop;
+
+    // XXX I don't want to show up in the client list. All I want to know is the list of sources
+    // and sinks...
+    s_context = pa_context_new(api, "libphonon");
+    // (cg) Convert to PA_CONTEXT_NOFLAGS when PulseAudio 0.9.19 is required
+    if (pa_context_connect(s_context, NULL, static_cast<pa_context_flags_t>(0), 0) >= 0) {
+        pa_context_set_state_callback(s_context, &context_state_callback, s_connectionEventloop);
+        // Now we block until we connect or otherwise...
+        s_connectionEventloop->exec();
+    }
+#endif
+}
+
+PulseSupport::~PulseSupport()
+{
+#ifdef HAVE_PULSEAUDIO
+    if (s_context) {
+        pa_context_disconnect(s_context);
+        s_context = NULL;
+    }
+
+    if (s_mainloop) {
+        pa_glib_mainloop_free(s_mainloop);
+        s_mainloop = NULL;
+    }
+
+    if (s_connectionEventloop) {
+        delete s_connectionEventloop;
+        s_connectionEventloop = NULL;
+    }
+#endif
+}
+
+bool PulseSupport::isActive()
+{
+#ifdef HAVE_PULSEAUDIO
+    return s_pulseActive;
+#else
+    return false;
+#endif
+}
+
+void PulseSupport::disable()
+{
+#ifdef HAVE_PULSEAUDIO
+    s_pulseActive = false;
+#endif
+}
+
+QList<int> PulseSupport::objectDescriptionIndexes(ObjectDescriptionType type) const
+{
+    QList<int> list;
+
+    if (type != AudioOutputDeviceType && type != AudioCaptureDeviceType)
+        return list;
+
+#ifdef HAVE_PULSEAUDIO
+    if (s_pulseActive) {
+        switch (type) {
+
+            case AudioOutputDeviceType: {
+                QMap<QString, int>::iterator it;
+                for (it = s_outputDeviceIndexes.begin(); it != s_outputDeviceIndexes.end(); ++it) {
+                    list.append(*it);
+                }
+                break;
+            }
+            case AudioCaptureDeviceType: {
+                QMap<QString, int>::iterator it;
+                for (it = s_captureDeviceIndexes.begin(); it != s_captureDeviceIndexes.end(); ++it) {
+                    list.append(*it);
+                }
+                break;
+            }
+            default:
+                break;
+        }
+    }
+#endif
+
+    return list;
+}
+
+QHash<QByteArray, QVariant> PulseSupport::objectDescriptionProperties(ObjectDescriptionType type, int index) const
+{
+    QHash<QByteArray, QVariant> ret;
+
+    if (type != AudioOutputDeviceType && type != AudioCaptureDeviceType)
+        return ret;
+
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(index);
+#else
+    if (s_pulseActive) {
+        switch (type) {
+
+            case AudioOutputDeviceType:
+                Q_ASSERT(s_outputDevices.contains(index));
+                ret = s_outputDevices[index].properties;
+                break;
+
+            case AudioCaptureDeviceType:
+                Q_ASSERT(s_captureDevices.contains(index));
+                ret = s_captureDevices[index].properties;
+                break;
+
+            default:
+                break;
+        }
+    }
+#endif
+
+    return ret;
+}
+
+QList<int> PulseSupport::objectIndexesByCategory(ObjectDescriptionType type, Category category) const
+{
+    QList<int> ret;
+
+    if (type != AudioOutputDeviceType && type != AudioCaptureDeviceType)
+        return ret;
+
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(category);
+#else
+    if (s_pulseActive) {
+        switch (type) {
+
+            case AudioOutputDeviceType:
+                if (s_outputDevicePriorities.contains(category))
+                    ret = s_outputDevicePriorities[category].values();
+                break;
+
+            case AudioCaptureDeviceType:
+                if (s_captureDevicePriorities.contains(category))
+                    ret = s_captureDevicePriorities[category].values();
+                break;
+
+            default:
+                break;
+        }
+    }
+#endif
+
+    return ret;
+}
+
+#ifdef HAVE_PULSEAUDIO
+static void setDevicePriority(Category category, QStringList list)
+{
+    QString role = s_roleCategoryMap.key(category);
+    if (role.isEmpty())
+        return;
+
+    logMessage(QString("Reindexing %1: %2").arg(role).arg(list.join(", ")));
+
+    char **devices;
+    devices = pa_xnew(char *, list.size()+1);
+    int i = 0;
+    foreach (QString str, list) {
+        devices[i++] = pa_xstrdup(str.toUtf8().constData());
+    }
+    devices[list.size()] = NULL;
+
+    pa_operation *o;
+    if (!(o = pa_ext_device_manager_reorder_devices_for_role(s_context, role.toUtf8().constData(), (const char**)devices, NULL, NULL)))
+        logMessage(QString("pa_ext_device_manager_reorder_devices_for_role() failed"));
+    else
+        pa_operation_unref(o);
+
+    for (i = 0; i < list.size(); ++i)
+        pa_xfree(devices[i]);
+    pa_xfree(devices);
+}
+#endif
+
+void PulseSupport::setOutputDevicePriorityForCategory(Category category, QList<int> order)
+{
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(category);
+    Q_UNUSED(order);
+#else
+    QStringList list;
+    QList<int>::iterator it;
+
+    for (it = order.begin(); it != order.end(); ++it) {
+        if (s_outputDevices.contains(*it)) {
+            list << s_outputDeviceIndexes.key(*it);
+        }
+    }
+    setDevicePriority(category, list);
+#endif
+}
+
+void PulseSupport::setCaptureDevicePriorityForCategory(Category category, QList<int> order)
+{
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(category);
+    Q_UNUSED(order);
+#else
+    QStringList list;
+    QList<int>::iterator it;
+
+    for (it = order.begin(); it != order.end(); ++it) {
+        if (s_captureDevices.contains(*it)) {
+            list << s_captureDeviceIndexes.key(*it);
+        }
+    }
+    setDevicePriority(category, list);
+#endif
+}
+
+void PulseSupport::setStreamPropList(Category category, QString streamUuid)
+{
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(category);
+    Q_UNUSED(streamUuid);
+#else
+    QString role = s_roleCategoryMap.key(category);
+    if (role.isEmpty())
+        return;
+
+    logMessage(QString("Setting role to %1 for streamindex %2").arg(role).arg(streamUuid));
+    setenv("PULSE_PROP_media.role", role.toLatin1().constData(), 1);
+    setenv("PULSE_PROP_phonon.streamid", streamUuid.toLatin1().constData(), 1);
+#endif
+}
+
+void PulseSupport::emitObjectDescriptionChanged(ObjectDescriptionType type)
+{
+    emit objectDescriptionChanged(type);
+}
+
+bool PulseSupport::setOutputDevice(QString streamUuid, int device) {
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(streamUuid);
+    Q_UNUSED(device);
+    return false;
+#else
+    if (s_outputDevices.size() < 2)
+        return true;
+
+    if (!s_outputDevices.contains(device)) {
+        logMessage(QString("Attempting to set Output Device for invalid device id %1.").arg(device));
+        return false;
+    }
+    const QVariant var = s_outputDevices[device].properties["name"];
+    logMessage(QString("Attempting to set Output Device to '%1' for Output Stream %2").arg(var.toString()).arg(streamUuid));
+
+    s_outputStreamMoveQueue[streamUuid] = device;
+    // Attempt to look up the pulse stream index.
+    if (s_outputStreamIndexMap.contains(streamUuid) && s_outputStreamIndexMap[streamUuid] != PA_INVALID_INDEX) {
+        logMessage(QString("... Found in map. Moving now"));
+        set_output_device(streamUuid);
+    } else {
+        logMessage(QString("... Not found in map. Saving move for when the stream appears"));
+    }
+    return true;
+#endif
+}
+
+bool PulseSupport::setCaptureDevice(QString streamUuid, int device) {
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(streamUuid);
+    Q_UNUSED(device);
+    return false;
+#else
+    if (s_captureDevices.size() < 2)
+        return true;
+
+    if (!s_captureDevices.contains(device)) {
+        logMessage(QString("Attempting to set Capture Device for invalid device id %1.").arg(device));
+        return false;
+    }
+    const QVariant var = s_captureDevices[device].properties["name"];
+    logMessage(QString("Attempting to set Capture Device to '%1' for Capture Stream %2").arg(var.toString()).arg(streamUuid));
+
+    s_captureStreamMoveQueue[streamUuid] = device;
+    // Attempt to look up the pulse stream index.
+    if (s_captureStreamIndexMap.contains(streamUuid) && s_captureStreamIndexMap[streamUuid] == PA_INVALID_INDEX) {
+        logMessage(QString("... Found in map. Moving now"));
+        set_capture_device(streamUuid);
+    } else {
+        logMessage(QString("... Not found in map. Saving move for when the stream appears"));
+    }
+    return true;
+#endif
+}
+
+void PulseSupport::clearStreamCache(QString streamUuid) {
+#ifndef HAVE_PULSEAUDIO
+    Q_UNUSED(streamUuid);
+    return;
+#else
+    logMessage(QString("Clearing stream cache for stream %1").arg(streamUuid));
+    s_outputStreamIndexMap.remove(streamUuid);
+    s_outputStreamMoveQueue.remove(streamUuid);
+    s_captureStreamIndexMap.remove(streamUuid);
+    s_captureStreamMoveQueue.remove(streamUuid);
+#endif
+}
+
+} // namespace Phonon
+
+QT_END_NAMESPACE
+
+// vim: sw=4 ts=4
diff --git a/src/3rdparty/phonon/phonon/pulsesupport.h b/src/3rdparty/phonon/phonon/pulsesupport.h
new file mode 100644
index 0000000..434b559
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/pulsesupport.h
@@ -0,0 +1,74 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2009 Colin Guthrie <cguthrie@mandriva.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation 
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public 
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef PHONON_PULSESUPPORT_H
+#define PHONON_PULSESUPPORT_H
+
+#include "phonon_export.h"
+#include "phononnamespace.h"
+#include "objectdescription.h"
+
+#include <QtCore/QtGlobal>
+#include <QtCore/QSet>
+
+QT_BEGIN_HEADER
+QT_BEGIN_NAMESPACE
+
+namespace Phonon
+{
+    class PHONON_EXPORT PulseSupport : public QObject
+    {
+        Q_OBJECT
+        public:
+            static PulseSupport* getInstance();
+            static void shutdown();
+
+            bool isActive();
+            void disable();
+
+            QList<int> objectDescriptionIndexes(ObjectDescriptionType type) const;
+            QHash<QByteArray, QVariant> objectDescriptionProperties(ObjectDescriptionType type, int index) const;
+            QList<int> objectIndexesByCategory(ObjectDescriptionType type, Category category) const;
+
+            void setOutputDevicePriorityForCategory(Category category, QList<int> order);
+            void setCaptureDevicePriorityForCategory(Category category, QList<int> order);
+
+            void setStreamPropList(Category category, QString streamUuid);
+            void emitObjectDescriptionChanged(ObjectDescriptionType);
+
+            bool setOutputDevice(QString streamUuid, int device);
+            bool setCaptureDevice(QString streamUuid, int device);
+            void clearStreamCache(QString streamUuid);
+
+        signals:
+            void objectDescriptionChanged(ObjectDescriptionType);
+        private:
+            PulseSupport();
+            ~PulseSupport();
+    };
+} // namespace Phonon
+
+QT_END_NAMESPACE
+QT_END_HEADER
+
+#endif // PHONON_PULSESUPPORT_H
+  
diff --git a/src/3rdparty/phonon/phonon/qsettingsgroup_p.h b/src/3rdparty/phonon/phonon/qsettingsgroup_p.h
index f28ecaa..ac7ca8d 100644
--- a/src/3rdparty/phonon/phonon/qsettingsgroup_p.h
+++ b/src/3rdparty/phonon/phonon/qsettingsgroup_p.h
@@ -27,8 +27,6 @@
 #include <QtCore/QString>
 #include <QtCore/QVariant>
 
-#ifndef QT_NO_PHONON_SETTINGSGROUP
-
 QT_BEGIN_HEADER
 QT_BEGIN_NAMESPACE
 
@@ -89,6 +87,5 @@ class QSettingsGroup
 
 QT_END_NAMESPACE
 QT_END_HEADER
-#endif //QT_NO_PHONON_SETTINGSGROUP
 
 #endif // PHONON_QSETTINGSGROUP_P_H
diff --git a/src/3rdparty/phonon/phonon/seekslider_p.h b/src/3rdparty/phonon/phonon/seekslider_p.h
index c87a4b0..911ab25 100644
--- a/src/3rdparty/phonon/phonon/seekslider_p.h
+++ b/src/3rdparty/phonon/phonon/seekslider_p.h
@@ -24,8 +24,8 @@
 #define SEEKSLIDER_P_H
 
 #include "seekslider.h"
+#include "swiftslider_p.h"
 #include <QtGui/QBoxLayout>
-#include <QtGui/QSlider>
 #include <QtGui/QLabel>
 #include <QtGui/QPixmap>
 #include <QtGui/QIcon>
@@ -84,7 +84,7 @@ class SeekSliderPrivate
         void _k_currentSourceChanged();
 
         QBoxLayout layout;
-        QSlider slider;
+        SwiftSlider slider;
         QLabel iconLabel;
         QPointer<MediaObject> media;
         bool ticking;
diff --git a/src/3rdparty/phonon/phonon/swiftslider.cpp b/src/3rdparty/phonon/phonon/swiftslider.cpp
new file mode 100644
index 0000000..1e274aa
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/swiftslider.cpp
@@ -0,0 +1,103 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006-2008 Ricardo Villalba <rvm@escomposlinux.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "swiftslider_p.h"
+
+#include <QtGui/QMouseEvent>
+#include <QtGui/QStyle>
+#include <QtGui/QStyleOption>
+
+QT_BEGIN_NAMESPACE
+
+#if !defined(QT_NO_PHONON_SEEKSLIDER) && !defined(QT_NO_PHONON_VOLUMESLIDER)
+
+namespace Phonon
+{
+
+SwiftSlider::SwiftSlider(Qt::Orientation orientation, QWidget * parent)
+	: QSlider(orientation, parent)
+{
+}
+
+SwiftSlider::~SwiftSlider()
+{
+}
+
+// Function copied from qslider.cpp
+inline int SwiftSlider::pick(const QPoint &pt) const
+{
+    return orientation() == Qt::Horizontal ? pt.x() : pt.y();
+}
+
+// Function copied from qslider.cpp and modified to make it compile
+int SwiftSlider::pixelPosToRangeValue(int pos) const
+{
+    QStyleOptionSlider opt;
+    initStyleOption(&opt);
+    QRect gr = style()->subControlRect(QStyle::CC_Slider, &opt, QStyle::SC_SliderGroove, this);
+    QRect sr = style()->subControlRect(QStyle::CC_Slider, &opt, QStyle::SC_SliderHandle, this);
+    int sliderMin, sliderMax, sliderLength;
+
+    if (orientation() == Qt::Horizontal) {
+        sliderLength = sr.width();
+        sliderMin = gr.x();
+        sliderMax = gr.right() - sliderLength + 1;
+    } else {
+        sliderLength = sr.height();
+        sliderMin = gr.y();
+        sliderMax = gr.bottom() - sliderLength + 1;
+    }
+    return QStyle::sliderValueFromPosition(minimum(), maximum(), pos - sliderMin,
+                                           sliderMax - sliderMin, opt.upsideDown);
+}
+
+// Based on code from qslider.cpp
+void SwiftSlider::mousePressEvent(QMouseEvent *event)
+{
+    if (event->button() == Qt::LeftButton) {
+        QStyleOptionSlider opt;
+        initStyleOption(&opt);
+        const QRect sliderRect = style()->subControlRect(QStyle::CC_Slider, &opt, QStyle::SC_SliderHandle, this);
+        const QPoint center = sliderRect.center() - sliderRect.topLeft();
+        // to take half of the slider off for the setSliderPosition call we use the center - topLeft
+
+        if (!sliderRect.contains(event->pos())) {
+            event->accept();
+
+            setSliderPosition(pixelPosToRangeValue(pick(event->pos() - center)));
+            triggerAction(SliderMove);
+            setRepeatAction(SliderNoAction);
+        } else {
+            QSlider::mousePressEvent(event);
+        }
+    } else {
+        QSlider::mousePressEvent(event);
+    }
+}
+
+} // namespace Phonon
+
+#endif //QT_NO_PHONON_VOLUMESLIDER && QT_NO_PHONON_VOLUMESLIDER
+
+QT_END_NAMESPACE
+
+#include "moc_swiftslider_p.cpp"
diff --git a/src/3rdparty/phonon/phonon/swiftslider_p.h b/src/3rdparty/phonon/phonon/swiftslider_p.h
new file mode 100644
index 0000000..f1e9c88
--- /dev/null
+++ b/src/3rdparty/phonon/phonon/swiftslider_p.h
@@ -0,0 +1,68 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2006-2008 Ricardo Villalba <rvm@escomposlinux.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) version 3, or any
+    later version accepted by the membership of KDE e.V. (or its
+    successor approved by the membership of KDE e.V.), Nokia Corporation
+    (or its successors, if any) and the KDE Free Qt Foundation, which shall
+    act as a proxy defined in Section 6 of version 3 of the license.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef SWIFTSLIDER_H
+#define SWIFTSLIDER_H
+
+#include <QtGui/QSlider>
+
+QT_BEGIN_NAMESPACE
+
+#if !defined(QT_NO_PHONON_SEEKSLIDER) && !defined(QT_NO_PHONON_VOLUMESLIDER)
+
+namespace Phonon
+{
+
+/** \class SwiftSlider swiftslider_p.h Phonon/SwiftSlider
+ * \short Modified QSlider that allows sudden/quick moves instead of stepped moves ("Click'n'Go" QSlider)
+ *
+ * This is an internal class used by SeekSlider and VolumeSlider.
+ *
+ * Ricardo Villalba, the original author of MySlider.cpp (from the SMPlayer project)
+ * gave his permission for the inclusion of this code inside Phonon by
+ * switching MySlider.cpp to the LGPLv2.1+ license.
+ * See http://smplayer.svn.sourceforge.net/viewvc/smplayer/smplayer/trunk/src/myslider.cpp?revision=2406&view=markup
+ *
+ * The original discussion about a "Click'n'Go QSlider": http://lists.trolltech.com/qt-interest/2006-11/msg00363.html
+ *
+ * \ingroup PhononWidgets
+ */
+class SwiftSlider : public QSlider
+{
+	Q_OBJECT
+public:
+	SwiftSlider(Qt::Orientation orientation, QWidget * parent);
+	~SwiftSlider();
+
+private:
+	void mousePressEvent(QMouseEvent *event);
+	inline int pick(const QPoint &pt) const;
+	int pixelPosToRangeValue(int pos) const;
+};
+
+} // namespace Phonon
+
+#endif //QT_NO_PHONON_VOLUMESLIDER && QT_NO_PHONON_VOLUMESLIDER
+
+QT_END_NAMESPACE
+
+#endif //SWIFTSLIDER_H
diff --git a/src/3rdparty/phonon/phonon/videowidget.cpp b/src/3rdparty/phonon/phonon/videowidget.cpp
index a9e83a6..4575dfd 100644
--- a/src/3rdparty/phonon/phonon/videowidget.cpp
+++ b/src/3rdparty/phonon/phonon/videowidget.cpp
@@ -28,8 +28,9 @@
 #include "phononnamespace_p.h"
 
 #include <QtGui/QAction>
-
-#define PHONON_INTERFACENAME VideoWidgetInterface
+#define IFACES4 VideoWidgetInterface44
+#define IFACES0 VideoWidgetInterface, IFACES4
+#define PHONON_INTERFACENAME IFACES0
 
 QT_BEGIN_NAMESPACE
 
@@ -48,6 +49,8 @@ VideoWidget::VideoWidget(QWidget *parent)
     setMouseTracking(true);
 }
 
+
+
 VideoWidget::VideoWidget(VideoWidgetPrivate &dd, QWidget *parent)
     : QWidget(parent),
     Phonon::AbstractVideoOutput(dd)
@@ -98,6 +101,15 @@ PHONON_INTERFACE_SETTER(setHue, hue, qreal)
 PHONON_INTERFACE_GETTER(qreal, saturation, d->saturation)
 PHONON_INTERFACE_SETTER(setSaturation, saturation, qreal)
 
+
+QImage VideoWidget::snapshot() const {
+    K_D(const VideoWidget);
+    ConstIface<IFACES4> iface(d);
+    if(iface) return iface->snapshot();
+    return QImage(); // TODO not implemented in VideoInterface
+}
+
+
 void VideoWidget::setFullScreen(bool newFullScreen)
 {
     pDebug() << Q_FUNC_INFO << newFullScreen;
diff --git a/src/3rdparty/phonon/phonon/videowidget.h b/src/3rdparty/phonon/phonon/videowidget.h
index 1d95490..804e61a 100644
--- a/src/3rdparty/phonon/phonon/videowidget.h
+++ b/src/3rdparty/phonon/phonon/videowidget.h
@@ -172,6 +172,7 @@ class AbstractVideoOutput;
             qreal contrast() const;
             qreal hue() const;
             qreal saturation() const;
+            QImage snapshot() const;
 
             //TODO: bar colors property
         public Q_SLOTS:
diff --git a/src/3rdparty/phonon/phonon/videowidgetinterface.h b/src/3rdparty/phonon/phonon/videowidgetinterface.h
index 3e6fd22..0c33956 100644
--- a/src/3rdparty/phonon/phonon/videowidgetinterface.h
+++ b/src/3rdparty/phonon/phonon/videowidgetinterface.h
@@ -53,8 +53,21 @@ class VideoWidgetInterface
 //X        virtual int overlayCapabilities() const = 0;
 //X        virtual bool createOverlay(QWidget *widget, int type) = 0;
 };
+
+class VideoWidgetInterface44 : public VideoWidgetInterface
+{
+    public:
+        virtual QImage snapshot() const = 0;
+};
 }
 
+#ifdef PHONON_BACKEND_VERSION_4_4
+namespace Phonon { typedef VideoWidgetInterface44 VideoWidgetInterfaceLatest; }
+#else
+namespace Phonon { typedef VideoWidgetInterface VideoWidgetInterfaceLatest; }
+#endif
+
+Q_DECLARE_INTERFACE(Phonon::VideoWidgetInterface44, "VideoWidgetInterface44.phonon.kde.org")
 Q_DECLARE_INTERFACE(Phonon::VideoWidgetInterface, "VideoWidgetInterface3.phonon.kde.org")
 
 #endif //QT_NO_PHONON_VIDEO
diff --git a/src/3rdparty/phonon/phonon/volumeslider.cpp b/src/3rdparty/phonon/phonon/volumeslider.cpp
index 00970c1..923f8d0 100644
--- a/src/3rdparty/phonon/phonon/volumeslider.cpp
+++ b/src/3rdparty/phonon/phonon/volumeslider.cpp
@@ -85,7 +85,7 @@ VolumeSlider::~VolumeSlider()
 
 bool VolumeSlider::isMuteVisible() const
 {
-    return !k_ptr->muteButton.isHidden();
+    return k_ptr->muteButton.isVisible();
 }
 
 void VolumeSlider::setMuteVisible(bool visible)
diff --git a/src/3rdparty/phonon/phonon/volumeslider_p.h b/src/3rdparty/phonon/phonon/volumeslider_p.h
index 3827659..623275f 100644
--- a/src/3rdparty/phonon/phonon/volumeslider_p.h
+++ b/src/3rdparty/phonon/phonon/volumeslider_p.h
@@ -24,8 +24,8 @@
 #define VOLUMESLIDER_P_H
 
 #include "volumeslider.h"
+#include "swiftslider_p.h"
 #include <QtGui/QBoxLayout>
-#include <QtGui/QSlider>
 #include <QtGui/QLabel>
 #include <QtGui/QPixmap>
 #include <QtGui/QToolButton>
@@ -83,7 +83,7 @@ class VolumeSliderPrivate
 
     private:
         QBoxLayout layout;
-        QSlider slider;
+        SwiftSlider slider;
         QToolButton muteButton;
         QIcon volumeIcon;
         QIcon mutedIcon;
diff --git a/src/3rdparty/webkit/WebCore/WebCore.pro b/src/3rdparty/webkit/WebCore/WebCore.pro
index 9239089..7d51c2b 100644
--- a/src/3rdparty/webkit/WebCore/WebCore.pro
+++ b/src/3rdparty/webkit/WebCore/WebCore.pro
@@ -50,8 +50,8 @@ unix {
     lessThan(QT_MINOR_VERSION, 4): QMAKE_PKGCONFIG_REQUIRES += QtXml
 }
 
-unix:!mac:*-g++*:QMAKE_CXXFLAGS += -ffunction-sections -fdata-sections 
-unix:!mac:*-g++*:QMAKE_LFLAGS += -Wl,--gc-sections
+unix:!mac:!darwin-*:*-g++*:QMAKE_CXXFLAGS += -ffunction-sections -fdata-sections 
+unix:!mac:!darwin-*:*-g++*:QMAKE_LFLAGS += -Wl,--gc-sections
 
 CONFIG(release):!CONFIG(QTDIR_build) {
     contains(QT_CONFIG, reduce_exports):CONFIG += hide_symbols
diff --git a/src/3rdparty/webkit/WebKit/qt/Api/qwebpage.cpp b/src/3rdparty/webkit/WebKit/qt/Api/qwebpage.cpp
index aedf95a..13736af 100644
--- a/src/3rdparty/webkit/WebKit/qt/Api/qwebpage.cpp
+++ b/src/3rdparty/webkit/WebKit/qt/Api/qwebpage.cpp
@@ -3097,7 +3097,7 @@ QString QWebPage::userAgentForUrl(const QUrl& url) const
     "AIX"
 #elif defined Q_OS_WIN32
     "%2"
-#elif defined Q_OS_DARWIN
+#elif defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #ifdef __i386__ || __x86_64__
     "Intel Mac OS X"
 #else
diff --git a/src/corelib/codecs/codecs.pri b/src/corelib/codecs/codecs.pri
index 17f4d91..7dfec12 100644
--- a/src/corelib/codecs/codecs.pri
+++ b/src/corelib/codecs/codecs.pri
@@ -25,6 +25,7 @@ unix {
         contains(QT_CONFIG,iconv) {
                 HEADERS += codecs/qiconvcodec_p.h
                 SOURCES += codecs/qiconvcodec.cpp
+                LIBS += -liconv
         } else:contains(QT_CONFIG,gnu-libiconv) {
                 HEADERS += codecs/qiconvcodec_p.h
                 SOURCES += codecs/qiconvcodec.cpp
diff --git a/src/corelib/codecs/qiconvcodec.cpp b/src/corelib/codecs/qiconvcodec.cpp
index bbfb6ed..d055919 100644
--- a/src/corelib/codecs/qiconvcodec.cpp
+++ b/src/corelib/codecs/qiconvcodec.cpp
@@ -62,7 +62,7 @@
 #elif defined(Q_OS_AIX)
 #  define NO_BOM
 #  define UTF16 "UCS-2"
-#elif defined(Q_OS_FREEBSD) || defined(Q_OS_MAC)
+#elif defined(Q_OS_FREEBSD) || defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #  define NO_BOM
 #  if Q_BYTE_ORDER == Q_BIG_ENDIAN
 #    define UTF16 "UTF-16BE"
diff --git a/src/corelib/concurrent/qtconcurrentiteratekernel.cpp b/src/corelib/concurrent/qtconcurrentiteratekernel.cpp
index 2d3663b..680e491 100644
--- a/src/corelib/concurrent/qtconcurrentiteratekernel.cpp
+++ b/src/corelib/concurrent/qtconcurrentiteratekernel.cpp
@@ -41,7 +41,7 @@
 
 #include "qtconcurrentiteratekernel.h"
 
-#if defined(Q_OS_MAC)
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #include <mach/mach.h>
 #include <mach/mach_time.h>
 #include <unistd.h>
@@ -64,7 +64,7 @@ enum {
     MedianSize = 7
 };
 
-#if defined(Q_OS_MAC)
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 
 static qint64 getticks()
 {
diff --git a/src/corelib/corelib.pro b/src/corelib/corelib.pro
index 9a15bf1..aaea7ec 100644
--- a/src/corelib/corelib.pro
+++ b/src/corelib/corelib.pro
@@ -18,7 +18,7 @@ include(codecs/codecs.pri)
 include(statemachine/statemachine.pri)
 include(xml/xml.pri)
 
-mac|darwin:LIBS_PRIVATE += -framework ApplicationServices
+mac:LIBS_PRIVATE += -framework ApplicationServices
 
 mac:lib_bundle:DEFINES += QT_NO_DEBUG_PLUGIN_CHECK
 win32:DEFINES-=QT_NO_CAST_TO_ASCII
diff --git a/src/corelib/global/qglobal.cpp b/src/corelib/global/qglobal.cpp
index 541aa2b..4b3123b 100644
--- a/src/corelib/global/qglobal.cpp
+++ b/src/corelib/global/qglobal.cpp
@@ -1259,7 +1259,7 @@ bool qSharedBuild()
     \macro Q_OS_DARWIN
     \relates <QtGlobal>
 
-    Defined on Darwin OS (synonym for Q_OS_MAC).
+    Defined on Darwin OS.
 */
 
 /*!
diff --git a/src/corelib/global/qglobal.h b/src/corelib/global/qglobal.h
index c9ad6e2..5da4bc1 100644
--- a/src/corelib/global/qglobal.h
+++ b/src/corelib/global/qglobal.h
@@ -128,7 +128,7 @@ namespace QT_NAMESPACE {}
 
 #endif /* __cplusplus */
 
-#if defined(Q_OS_MAC) && !defined(Q_CC_INTEL)
+#if ( defined(Q_OS_DARWIN) || defined(Q_OS_MAC) ) && !defined(Q_CC_INTEL)
 #define QT_BEGIN_HEADER extern "C++" {
 #define QT_END_HEADER }
 #define QT_BEGIN_INCLUDE_HEADER }
@@ -143,7 +143,7 @@ namespace QT_NAMESPACE {}
 /*
    The operating system, must be one of: (Q_OS_x)
 
-     DARWIN   - Darwin OS (synonym for Q_OS_MAC)
+     DARWIN   - Darwin OS (pure Darwin or Mac OS X using X11)
      SYMBIAN  - Symbian
      MSDOS    - MS-DOS and Windows
      OS2      - OS/2
@@ -265,12 +265,15 @@ namespace QT_NAMESPACE {}
 #  define Q_OS_WIN
 #endif
 
-#if defined(Q_OS_DARWIN)
+#if defined(Q_OS_DARWIN) && !defined(__USE_WS_X11__)
+#  undef Q_OS_DARWIN
 #  define Q_OS_MAC /* Q_OS_MAC is mostly for compatibility, but also more clear */
 #  define Q_OS_MACX /* Q_OS_MACX is only for compatibility.*/
 #  if defined(Q_OS_DARWIN64)
+#     undef Q_OS_DARWIN64
 #     define Q_OS_MAC64
 #  elif defined(Q_OS_DARWIN32)
+#     undef Q_OS_DARWIN32
 #     define Q_OS_MAC32
 #  endif
 #endif
@@ -294,11 +297,11 @@ namespace QT_NAMESPACE {}
 #  define Q_OS_UNIX
 #endif
 
-#if defined(Q_OS_DARWIN) && !defined(QT_LARGEFILE_SUPPORT)
+#if ( defined(Q_OS_DARWIN) || defined(Q_OS_MAC) ) && !defined(QT_LARGEFILE_SUPPORT)
 #  define QT_LARGEFILE_SUPPORT 64
 #endif
 
-#ifdef Q_OS_DARWIN
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #  ifdef MAC_OS_X_VERSION_MIN_REQUIRED
 #    undef MAC_OS_X_VERSION_MIN_REQUIRED
 #  endif
@@ -485,7 +488,7 @@ namespace QT_NAMESPACE {}
 #    define Q_NO_TEMPLATE_FRIENDS
 #  endif
 /* Apple's GCC 3.1 chokes on our streaming qDebug() */
-#  if defined(Q_OS_DARWIN) && __GNUC__ == 3 && (__GNUC_MINOR__ >= 1 && __GNUC_MINOR__ < 3)
+#  if ( defined(Q_OS_DARWIN) || defined(Q_OS_MAC) ) && __GNUC__ == 3 && (__GNUC_MINOR__ >= 1 && __GNUC_MINOR__ < 3)
 #    define Q_BROKEN_DEBUG_STREAM
 #  endif
 #  if (defined(Q_CC_GNU) || defined(Q_CC_INTEL)) && !defined(QT_MOC_CPP)
@@ -804,7 +807,7 @@ namespace QT_NAMESPACE {}
 #  define Q_WS_PM
 #  error "Qt does not work with OS/2 Presentation Manager or Workplace Shell"
 #elif defined(Q_OS_UNIX)
-#  if defined(Q_OS_MAC) && !defined(__USE_WS_X11__) && !defined(Q_WS_QWS)
+#  if defined(Q_OS_MAC) && !defined(Q_WS_QWS)
 #    define Q_WS_MAC
 #    define Q_WS_MACX
 #    if defined(Q_OS_MAC64)
@@ -1463,7 +1466,7 @@ public:
     static WinVersion windowsVersion();
 
 #endif
-#ifdef Q_OS_MAC
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
     enum MacVersion {
         MV_Unknown = 0x0000,
 
@@ -2076,7 +2079,7 @@ Q_DECLARE_TYPEINFO(qint64, Q_PRIMITIVE_TYPE);
 Q_DECLARE_TYPEINFO(quint64, Q_PRIMITIVE_TYPE);
 Q_DECLARE_TYPEINFO(float, Q_PRIMITIVE_TYPE);
 Q_DECLARE_TYPEINFO(double, Q_PRIMITIVE_TYPE);
-#ifndef Q_OS_DARWIN
+#if !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
 Q_DECLARE_TYPEINFO(long double, Q_PRIMITIVE_TYPE);
 #endif
 
diff --git a/src/corelib/io/qfile.cpp b/src/corelib/io/qfile.cpp
index bcd5dbc..30b6746 100644
--- a/src/corelib/io/qfile.cpp
+++ b/src/corelib/io/qfile.cpp
@@ -62,7 +62,7 @@ static const int QFILE_WRITEBUFFER_SIZE = 16384;
 
 static QByteArray locale_encode(const QString &f)
 {
-#ifndef Q_OS_DARWIN
+#if !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
     return f.toLocal8Bit();
 #else
     // Mac always expects UTF-8... and decomposed...
@@ -72,7 +72,7 @@ static QByteArray locale_encode(const QString &f)
 
 static QString locale_decode(const QByteArray &f)
 {
-#ifndef Q_OS_DARWIN
+#if !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
     return QString::fromLocal8Bit(f);
 #else
     // Mac always gives us UTF-8 and decomposed, we want that composed...
diff --git a/src/corelib/io/qfilesystemwatcher.cpp b/src/corelib/io/qfilesystemwatcher.cpp
index c810f44..7fc7749 100644
--- a/src/corelib/io/qfilesystemwatcher.cpp
+++ b/src/corelib/io/qfilesystemwatcher.cpp
@@ -57,8 +57,8 @@
 #elif defined(Q_OS_LINUX)
 #  include "qfilesystemwatcher_inotify_p.h"
 #  include "qfilesystemwatcher_dnotify_p.h"
-#elif defined(Q_OS_FREEBSD) || defined(Q_OS_MAC)
-#  if (defined Q_OS_MAC) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
+#elif defined(Q_OS_FREEBSD) || defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
+#  if ( (defined Q_OS_DARWIN || defined Q_OS_MAC) ) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
 #  include "qfilesystemwatcher_fsevents_p.h"
 #  endif //MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
 #  include "qfilesystemwatcher_kqueue_p.h"
@@ -247,7 +247,7 @@ QFileSystemWatcherEngine *QFileSystemWatcherPrivate::createNativeEngine()
     if(!eng)
         eng = QDnotifyFileSystemWatcherEngine::create();
     return eng;
-#elif defined(Q_OS_FREEBSD) || defined(Q_OS_MAC)
+#elif defined(Q_OS_FREEBSD) || defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #  if 0 && (defined Q_OS_MAC) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
     if (QSysInfo::MacintoshVersion >= QSysInfo::MV_10_5)
         return QFSEventsFileSystemWatcherEngine::create();
diff --git a/src/corelib/io/qfsfileengine_unix.cpp b/src/corelib/io/qfsfileengine_unix.cpp
index 5fd7834..806058b 100644
--- a/src/corelib/io/qfsfileengine_unix.cpp
+++ b/src/corelib/io/qfsfileengine_unix.cpp
@@ -480,7 +480,7 @@ bool QFSFileEngine::mkdir(const QString &name, bool createParentDirectories) con
         }
         return true;
     }
-#if defined(Q_OS_DARWIN)  // Mac X doesn't support trailing /'s
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC) // Mac X doesn't support trailing /'s
     if (dirName.endsWith(QLatin1Char('/')))
         dirName.chop(1);
 #endif
diff --git a/src/corelib/io/qprocess.cpp b/src/corelib/io/qprocess.cpp
index 7ef590e..7f14d01 100644
--- a/src/corelib/io/qprocess.cpp
+++ b/src/corelib/io/qprocess.cpp
@@ -2165,7 +2165,7 @@ bool QProcess::startDetached(const QString &program)
 }
 
 QT_BEGIN_INCLUDE_NAMESPACE
-#ifdef Q_OS_MAC
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 # include <crt_externs.h>
 # define environ (*_NSGetEnviron())
 #elif defined(Q_OS_WINCE) || defined(Q_OS_SYMBIAN)
diff --git a/src/corelib/io/qprocess_unix.cpp b/src/corelib/io/qprocess_unix.cpp
index 3a2edf8..96956a0 100644
--- a/src/corelib/io/qprocess_unix.cpp
+++ b/src/corelib/io/qprocess_unix.cpp
@@ -471,7 +471,7 @@ static char **_q_dupEnvironment(const QHash<QByteArray, QByteArray> &environment
     // if LD_LIBRARY_PATH exists in the current environment, but
     // not in the environment list passed by the programmer, then
     // copy it over.
-#if defined(Q_OS_MAC)
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
     static const char libraryPath[] = "DYLD_LIBRARY_PATH";
 #else
     static const char libraryPath[] = "LD_LIBRARY_PATH";
@@ -584,7 +584,7 @@ void QProcessPrivate::startProcess()
     // Add every argument to the list
     for (int i = 0; i < arguments.count(); ++i) {
         QString arg = arguments.at(i);
-#ifdef Q_OS_MAC
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
         // Mac OS X uses UTF8 for exec, regardless of the system locale.
         argv[i + 1] = ::strdup(arg.toUtf8().constData());
 #else
@@ -1207,7 +1207,7 @@ bool QProcessPrivate::startDetached(const QString &program, const QStringList &a
 
             char **argv = new char *[arguments.size() + 2];
             for (int i = 0; i < arguments.size(); ++i) {
-#ifdef Q_OS_MAC
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
                 argv[i + 1] = ::strdup(arguments.at(i).toUtf8().constData());
 #else
                 argv[i + 1] = ::strdup(arguments.at(i).toLocal8Bit().constData());
diff --git a/src/corelib/kernel/qcore_unix.cpp b/src/corelib/kernel/qcore_unix.cpp
index b984922..c8122ce 100644
--- a/src/corelib/kernel/qcore_unix.cpp
+++ b/src/corelib/kernel/qcore_unix.cpp
@@ -50,7 +50,7 @@
 
 #include <stdlib.h>
 
-#ifdef Q_OS_MAC
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #include <mach/mach_time.h>
 #endif
 
@@ -64,7 +64,7 @@ QT_BEGIN_NAMESPACE
 
 bool qt_gettime_is_monotonic()
 {
-#if (_POSIX_MONOTONIC_CLOCK-0 > 0) || defined(Q_OS_MAC)
+#if (_POSIX_MONOTONIC_CLOCK-0 > 0) || defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
     return true;
 #else
     static int returnValue = 0;
@@ -86,7 +86,7 @@ bool qt_gettime_is_monotonic()
 timeval qt_gettime()
 {
     timeval tv;
-#if defined(Q_OS_MAC)
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
     static mach_timebase_info_data_t info = {0,0};
     if (info.denom == 0)
         mach_timebase_info(&info);
diff --git a/src/corelib/kernel/qeventdispatcher_unix.cpp b/src/corelib/kernel/qeventdispatcher_unix.cpp
index 8147c22..33b0ad9 100644
--- a/src/corelib/kernel/qeventdispatcher_unix.cpp
+++ b/src/corelib/kernel/qeventdispatcher_unix.cpp
@@ -313,7 +313,7 @@ QTimerInfoList::QTimerInfoList()
 {
     currentTime = qt_gettime();
 
-#if (_POSIX_MONOTONIC_CLOCK-0 <= 0) && !defined(Q_OS_MAC)
+#if (_POSIX_MONOTONIC_CLOCK-0 <= 0) && !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
     if (!qt_gettime_is_monotonic()) {
         // not using monotonic timers, initialize the timeChanged() machinery
         previousTime = currentTime;
@@ -340,7 +340,7 @@ timeval QTimerInfoList::updateCurrentTime()
     return (currentTime = qt_gettime());
 }
 
-#if ((_POSIX_MONOTONIC_CLOCK-0 <= 0) && !defined(Q_OS_MAC)) || defined(QT_BOOTSTRAPPED)
+#if ((_POSIX_MONOTONIC_CLOCK-0 <= 0) && !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)) || defined(QT_BOOTSTRAPPED)
 
 template <>
 timeval qAbs(const timeval &t)
diff --git a/src/corelib/kernel/qeventdispatcher_unix_p.h b/src/corelib/kernel/qeventdispatcher_unix_p.h
index 838c270..26f0759 100644
--- a/src/corelib/kernel/qeventdispatcher_unix_p.h
+++ b/src/corelib/kernel/qeventdispatcher_unix_p.h
@@ -82,7 +82,7 @@ struct QTimerInfo {
 
 class QTimerInfoList : public QList<QTimerInfo*>
 {
-#if ((_POSIX_MONOTONIC_CLOCK-0 <= 0) && !defined(Q_OS_MAC)) || defined(QT_BOOTSTRAPPED)
+#if ((_POSIX_MONOTONIC_CLOCK-0 <= 0) && !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)) || defined(QT_BOOTSTRAPPED)
     timeval previousTime;
     clock_t previousTicks;
     int ticksPerSecond;
diff --git a/src/corelib/kernel/qobject.cpp b/src/corelib/kernel/qobject.cpp
index 9614e7a..77a11d6 100644
--- a/src/corelib/kernel/qobject.cpp
+++ b/src/corelib/kernel/qobject.cpp
@@ -1136,8 +1136,16 @@ void QObject::setObjectName(const QString &name)
 {
     Q_D(QObject);
     d->objectName = name;
+#if defined(Q_WS_X11)
+    d->checkWindowRole();
+#endif
 }
 
+#if defined(Q_WS_X11)
+void QObjectPrivate::checkWindowRole()
+{
+}
+#endif
 
 #ifdef QT3_SUPPORT
 /*! \internal
@@ -1490,7 +1498,7 @@ void QObject::moveToThread(QThread *targetThread)
                  "Cannot move to target thread (%p)\n",
                  d->threadData->thread, currentData->thread, targetData->thread);
 
-#ifdef Q_WS_MAC
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
         qWarning("On Mac OS X, you might be loading two sets of Qt binaries into the same process. "
                  "Check that all plugins are compiled against the right Qt binaries. Export "
                  "DYLD_PRINT_LIBRARIES=1 and check that only one set of binaries are being loaded.");
diff --git a/src/corelib/kernel/qobject_p.h b/src/corelib/kernel/qobject_p.h
index e75f24e..1294fa4 100644
--- a/src/corelib/kernel/qobject_p.h
+++ b/src/corelib/kernel/qobject_p.h
@@ -83,7 +83,9 @@ void Q_CORE_EXPORT qt_register_signal_spy_callbacks(const QSignalSpyCallbackSet
 
 extern QSignalSpyCallbackSet Q_CORE_EXPORT qt_signal_spy_callback_set;
 
-enum { QObjectPrivateVersion = QT_VERSION };
+// add 0x1000000 to mark it as qt-copy version, with possible modifications
+// in some Q*Private class
+enum { QObjectPrivateVersion = QT_VERSION + 0x1000000 };
 
 class Q_CORE_EXPORT QDeclarativeData
 {
@@ -157,6 +159,9 @@ public:
     void sendPendingChildInsertedEvents();
     void removePendingChildInsertedEvents(QObject *child);
 #endif
+#if defined(Q_WS_X11)
+    virtual void checkWindowRole();
+#endif
 
     static Sender *setCurrentSender(QObject *receiver,
                                     Sender *sender);
diff --git a/src/corelib/plugin/qlibrary.cpp b/src/corelib/plugin/qlibrary.cpp
index 1669654..b2e988b 100644
--- a/src/corelib/plugin/qlibrary.cpp
+++ b/src/corelib/plugin/qlibrary.cpp
@@ -556,7 +556,7 @@ bool QLibrary::isLibrary(const QString &fileName)
     if (completeSuffix.isEmpty())
         return false;
     QStringList suffixes = completeSuffix.split(QLatin1Char('.'));
-# if defined(Q_OS_DARWIN)
+# if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 
     // On Mac, libs look like libmylib.1.0.0.dylib
     const QString lastSuffix = suffixes.at(suffixes.count() - 1);
diff --git a/src/corelib/plugin/qlibrary_unix.cpp b/src/corelib/plugin/qlibrary_unix.cpp
index 8f73c91..83a7035 100644
--- a/src/corelib/plugin/qlibrary_unix.cpp
+++ b/src/corelib/plugin/qlibrary_unix.cpp
@@ -143,7 +143,7 @@ bool QLibraryPrivate::load_sys()
             suffixes << QLatin1String(".so");
         }
 #endif
-# ifdef Q_OS_MAC
+# if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
         if (!fullVersion.isEmpty()) {
             suffixes << QString::fromLatin1(".%1.bundle").arg(fullVersion);
             suffixes << QString::fromLatin1(".%1.dylib").arg(fullVersion);
diff --git a/src/corelib/thread/qthread.cpp b/src/corelib/thread/qthread.cpp
index a7c2a16..bde66f3 100644
--- a/src/corelib/thread/qthread.cpp
+++ b/src/corelib/thread/qthread.cpp
@@ -64,7 +64,7 @@
 /*
 #  elif defined(Q_OS_HPUX)
 #   include <sys/pstat.h>
-#  elif defined(Q_OS_FREEBSD) || defined(Q_OS_OPENBSD) || defined(Q_OS_MAC)
+#  elif defined(Q_OS_FREEBSD) || defined(Q_OS_OPENBSD) || defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #   include <sys/sysctl.h>
 #  endif
 #endif
diff --git a/src/corelib/thread/qthread_unix.cpp b/src/corelib/thread/qthread_unix.cpp
index 100a836..5173173 100644
--- a/src/corelib/thread/qthread_unix.cpp
+++ b/src/corelib/thread/qthread_unix.cpp
@@ -657,7 +657,7 @@ void QThread::setPriority(Priority priority)
 
     // copied from start() with a few modifications:
 
-#if defined(Q_OS_DARWIN) || !defined(Q_OS_OPENBSD) && defined(_POSIX_THREAD_PRIORITY_SCHEDULING) && (_POSIX_THREAD_PRIORITY_SCHEDULING-0 >= 0)
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC) || ( !defined(Q_OS_OPENBSD) && defined(_POSIX_THREAD_PRIORITY_SCHEDULING) && (_POSIX_THREAD_PRIORITY_SCHEDULING-0 >= 0) )
     int sched_policy;
     sched_param param;
 
diff --git a/src/corelib/tools/qsharedpointer.cpp b/src/corelib/tools/qsharedpointer.cpp
index c684dc5..5c852f7 100644
--- a/src/corelib/tools/qsharedpointer.cpp
+++ b/src/corelib/tools/qsharedpointer.cpp
@@ -1281,7 +1281,7 @@ QT_END_NAMESPACE
 #  ifdef QT_SHARED_POINTER_BACKTRACE_SUPPORT
 #    if defined(__GLIBC__) && (__GLIBC__ >= 2) && !defined(__UCLIBC__) && !defined(QT_LINUXBASE)
 #      define BACKTRACE_SUPPORTED
-#    elif defined(Q_OS_MACX)
+#    elif defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #      define BACKTRACE_SUPPORTED
 #    endif
 #  endif
diff --git a/src/corelib/xml/qxmlstream.cpp b/src/corelib/xml/qxmlstream.cpp
index c2e2eda..5a5f26c 100644
--- a/src/corelib/xml/qxmlstream.cpp
+++ b/src/corelib/xml/qxmlstream.cpp
@@ -41,7 +41,7 @@
 
 #include "QtCore/qxmlstream.h"
 
-#if defined(QT_BUILD_XML_LIB) && defined(Q_OS_MAC64)
+#if defined(QT_BUILD_XML_LIB) && (defined(Q_OS_DARWIN64) || defined(Q_OS_MAC64))
 // No need to define this in the 64-bit Mac libraries.
 // Since Qt 4.4 and previous weren't supported in 64-bit, there are
 // no QXmlStream* symbols to keep compatibility with
diff --git a/src/corelib/xml/qxmlstream.h b/src/corelib/xml/qxmlstream.h
index 786e1cc..3a6c885 100644
--- a/src/corelib/xml/qxmlstream.h
+++ b/src/corelib/xml/qxmlstream.h
@@ -85,7 +85,7 @@ QT_MODULE(Core)
 // We are taking the optimist scenario here to avoid creating more
 // symbols to be supported.
 
-#if defined(Q_OS_MAC32) || defined(Q_OS_AIX)
+#if defined(Q_OS_DARWIN32) || defined(Q_OS_MAC32) || defined(Q_OS_AIX)
 # if !defined QT_BUILD_XML_LIB
 #  define Q_XMLSTREAM_RENAME_SYMBOLS
 # endif
diff --git a/src/gui/embedded/qlock.cpp b/src/gui/embedded/qlock.cpp
index 170c259..54f43d2 100644
--- a/src/gui/embedded/qlock.cpp
+++ b/src/gui/embedded/qlock.cpp
@@ -86,11 +86,11 @@ QT_END_NAMESPACE
 
 #include <unistd.h>
 #include <sys/types.h>
-#if defined(Q_OS_DARWIN)
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 #   define Q_NO_SEMAPHORE
 #   include <sys/stat.h>
 #   include <sys/file.h>
-#else // Q_OS_DARWIN
+#else // Q_OS_DARWIN || Q_OS_MAC
 #   include <sys/sem.h>
 #   if (defined(__GNU_LIBRARY__) && !defined(_SEM_SEMUN_UNDEFINED) && !defined(QT_LINUXBASE)) \
     || defined(Q_OS_FREEBSD) || defined(Q_OS_OPENBSD) || defined(Q_OS_NETBSD) \
@@ -104,7 +104,7 @@ union semun {
     unsigned short *array;      /* array for GETALL, SETALL */
 };
 #   endif
-#endif // Q_OS_DARWIN
+#endif // Q_OS_DARWIN || Q_OS_MAC
 #include <sys/ipc.h>
 #include <string.h>
 #include <errno.h>
diff --git a/src/gui/embedded/qscreenlinuxfb_qws.cpp b/src/gui/embedded/qscreenlinuxfb_qws.cpp
index f3fd7cb..71417ee 100644
--- a/src/gui/embedded/qscreenlinuxfb_qws.cpp
+++ b/src/gui/embedded/qscreenlinuxfb_qws.cpp
@@ -63,7 +63,7 @@
 
 #include "qwindowsystem_qws.h"
 
-#if !defined(Q_OS_DARWIN) && !defined(Q_OS_FREEBSD)
+#if !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC) && !defined(Q_OS_FREEBSD)
 #include <linux/fb.h>
 
 #ifdef __i386__
diff --git a/src/gui/embedded/qsoundqss_qws.h b/src/gui/embedded/qsoundqss_qws.h
index e8a14df..de4fd63 100644
--- a/src/gui/embedded/qsoundqss_qws.h
+++ b/src/gui/embedded/qsoundqss_qws.h
@@ -60,7 +60,7 @@ QT_MODULE(Gui)
 #define QT_NO_QWS_SOUNDSERVER
 #endif
 
-#ifndef Q_OS_MAC
+#if !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
 
 class QWSSoundServerPrivate;
 
@@ -166,7 +166,7 @@ Q_SIGNALS:
 };
 #endif
 
-#endif // Q_OS_MAC
+#endif // !Q_OS_DARWIN && !Q_OS_MAC
 
 QT_END_NAMESPACE
 
diff --git a/src/gui/embedded/qwindowsystem_qws.cpp b/src/gui/embedded/qwindowsystem_qws.cpp
index 7526b98..41e9127 100644
--- a/src/gui/embedded/qwindowsystem_qws.cpp
+++ b/src/gui/embedded/qwindowsystem_qws.cpp
@@ -94,7 +94,7 @@
 #include <sys/mount.h>
 #endif
 
-#if !defined(QT_NO_SOUND) && !defined(Q_OS_DARWIN)
+#if !defined(QT_NO_SOUND) && !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
 #ifdef QT_USE_OLD_QWS_SOUND
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -1445,7 +1445,7 @@ void QWSServerPrivate::initServer(int flags)
     }
 #endif
 
-#if !defined(QT_NO_SOUND) && !defined(QT_EXTERNAL_SOUND_SERVER) && !defined(Q_OS_DARWIN)
+#if !defined(QT_NO_SOUND) && !defined(QT_EXTERNAL_SOUND_SERVER) && !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
     soundserver = new QWSSoundServer(q);
 #endif
 }
@@ -1977,7 +1977,7 @@ void QWSServerPrivate::doClient(QWSClient *client)
         case QWSCommand::GrabKeyboard:
             invokeGrabKeyboard((QWSGrabKeyboardCommand*)cs->command, cs->client);
             break;
-#if !defined(QT_NO_SOUND) && !defined(Q_OS_DARWIN)
+#if !defined(QT_NO_SOUND) && !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
         case QWSCommand::PlaySound:
             invokePlaySound((QWSPlaySoundCommand*)cs->command, cs->client);
             break;
@@ -3200,7 +3200,7 @@ void QWSServerPrivate::invokeGrabKeyboard(QWSGrabKeyboardCommand *cmd, QWSClient
 #if !defined(QT_NO_SOUND)
 void QWSServerPrivate::invokePlaySound(QWSPlaySoundCommand *cmd, QWSClient *)
 {
-#if !defined(QT_EXTERNAL_SOUND_SERVER) && !defined(Q_OS_DARWIN)
+#if !defined(QT_EXTERNAL_SOUND_SERVER) && !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
     soundserver->playFile( 1, cmd->filename );
 #else
     Q_UNUSED(cmd);
diff --git a/src/gui/kernel/qapplication_qws.cpp b/src/gui/kernel/qapplication_qws.cpp
index 00f24d7..a7cb94a 100644
--- a/src/gui/kernel/qapplication_qws.cpp
+++ b/src/gui/kernel/qapplication_qws.cpp
@@ -116,7 +116,7 @@
 #ifdef QT_NO_QSHM
 #include <sys/ipc.h>
 #include <sys/shm.h>
-#ifndef Q_OS_DARWIN
+#if !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC)
 # include <sys/sem.h>
 #endif
 #include <sys/socket.h>
diff --git a/src/gui/kernel/qeventdispatcher_mac.mm b/src/gui/kernel/qeventdispatcher_mac.mm
index 52d4c6f..defd8ac 100644
--- a/src/gui/kernel/qeventdispatcher_mac.mm
+++ b/src/gui/kernel/qeventdispatcher_mac.mm
@@ -125,7 +125,7 @@ static inline CFRunLoopRef mainRunLoop()
 void QEventDispatcherMacPrivate::activateTimer(CFRunLoopTimerRef, void *info)
 {
     int timerID =
-#ifdef Q_OS_MAC64
+#if defined(Q_OS_DARWIN64) || defined(Q_OS_MAC64)
     qint64(info);
 #else
     int(info);
diff --git a/src/gui/kernel/qkeymapper_mac.cpp b/src/gui/kernel/qkeymapper_mac.cpp
index 15da0b9..2c8a428 100644
--- a/src/gui/kernel/qkeymapper_mac.cpp
+++ b/src/gui/kernel/qkeymapper_mac.cpp
@@ -396,7 +396,7 @@ static Boolean qt_KeyEventComparatorProc(EventRef inEvent, void *data)
 static bool translateKeyEventInternal(EventHandlerCallRef er, EventRef keyEvent, int *qtKey,
                                       QChar *outChar, Qt::KeyboardModifiers *outModifiers, bool *outHandled)
 {
-#if !defined(QT_MAC_USE_COCOA) || defined(Q_OS_MAC64)
+#if !defined(QT_MAC_USE_COCOA) || defined(Q_OS_DARWIN64) || defined(Q_OS_MAC64)
     Q_UNUSED(er);
     Q_UNUSED(outHandled);
 #endif
@@ -421,7 +421,7 @@ static bool translateKeyEventInternal(EventHandlerCallRef er, EventRef keyEvent,
     //get mac mapping
     static UInt32 tmp_unused_state = 0L;
     const UCKeyboardLayout *uchrData = 0;
-#if defined(Q_OS_MAC32)
+#if defined(Q_OS_DARWIN32) || defined(Q_OS_MAC32)
     KeyboardLayoutRef keyLayoutRef = 0;
     KLGetCurrentKeyboardLayout(&keyLayoutRef);
     OSStatus err;
@@ -481,7 +481,7 @@ static bool translateKeyEventInternal(EventHandlerCallRef er, EventRef keyEvent,
                      long(err), __FILE__, __LINE__);
         }
     }
-#ifdef Q_OS_MAC32
+#if defined(Q_OS_DARWIN32) || defined(Q_OS_MAC32)
     else {
         // The road less travelled; use KeyTranslate
         const void *keyboard_layout;
@@ -554,7 +554,7 @@ QKeyMapperPrivate::QKeyMapperPrivate()
 {
     memset(keyLayout, 0, sizeof(keyLayout));
     keyboard_layout_format.unicode = 0;
-#ifdef Q_OS_MAC32
+#if defined(Q_OS_DARWIN32) || defined(Q_OS_MAC32)
     keyboard_mode = NullMode;
 #else
     currentInputSource = 0;
@@ -570,7 +570,7 @@ bool
 QKeyMapperPrivate::updateKeyboard()
 {
     const UCKeyboardLayout *uchrData = 0;
-#ifdef Q_OS_MAC32
+#if defined(Q_OS_DARWIN32) || defined(Q_OS_MAC32)
     KeyboardLayoutRef keyLayoutRef = 0;
     KLGetCurrentKeyboardLayout(&keyLayoutRef);
 
@@ -602,7 +602,7 @@ QKeyMapperPrivate::updateKeyboard()
         keyboard_layout_format.unicode = uchrData;
         keyboard_mode = UnicodeMode;
     }
-#ifdef Q_OS_MAC32
+#if defined(Q_OS_DARWIN32) || defined(Q_OS_MAC32)
     else {
         void *happy;
         err = KLGetKeyboardLayoutProperty(keyLayoutRef, kKLKCHRData,
@@ -621,7 +621,7 @@ QKeyMapperPrivate::updateKeyboard()
 #endif
     keyboard_dead = 0;
     CFStringRef iso639Code;
-#ifdef Q_OS_MAC32
+#if defined(Q_OS_DARWIN32) || defined(Q_OS_MAC32)
 # ifndef kKLLanguageCode
 # define kKLLanguageCode 9
 # endif
diff --git a/src/gui/kernel/qkeysequence.cpp b/src/gui/kernel/qkeysequence.cpp
index 528d512..edbe75b 100644
--- a/src/gui/kernel/qkeysequence.cpp
+++ b/src/gui/kernel/qkeysequence.cpp
@@ -1139,10 +1139,10 @@ int QKeySequencePrivate::decodeString(const QString &str, QKeySequence::Sequence
 
     QList<QModifKeyName> modifs;
     if (nativeText) {
-        modifs << QModifKeyName(Qt::CTRL, QShortcut::tr("Ctrl").toLower().append(QLatin1Char('+')))
-               << QModifKeyName(Qt::SHIFT, QShortcut::tr("Shift").toLower().append(QLatin1Char('+')))
-               << QModifKeyName(Qt::ALT, QShortcut::tr("Alt").toLower().append(QLatin1Char('+')))
-               << QModifKeyName(Qt::META, QShortcut::tr("Meta").toLower().append(QLatin1Char('+')));
+        modifs << QModifKeyName(Qt::CTRL, QShortcut::tr("Ctrl", "Ctrl key, used for shortcuts").toLower().append(QLatin1Char('+')))
+               << QModifKeyName(Qt::SHIFT, QShortcut::tr("Shift", "Shift key, used for shortcuts").toLower().append(QLatin1Char('+')))
+               << QModifKeyName(Qt::ALT, QShortcut::tr("Alt", "Alt key, used for shortcuts").toLower().append(QLatin1Char('+')))
+               << QModifKeyName(Qt::META, QShortcut::tr("Meta", "Meta key, used for shortcuts").toLower().append(QLatin1Char('+')));
     }
     modifs += *gmodifs; // Test non-translated ones last
 
@@ -1232,7 +1232,7 @@ QString QKeySequence::encodeString(int key)
 static inline void addKey(QString &str, const QString &theKey, QKeySequence::SequenceFormat format)
 {
     if (!str.isEmpty())
-        str += (format == QKeySequence::NativeText) ? QShortcut::tr("+")
+        str += (format == QKeySequence::NativeText) ? QShortcut::tr("+", "Symbol used to concatenate keys in shortcuts")
                                                     : QString::fromLatin1("+");
     str += theKey;
 }
@@ -1272,13 +1272,13 @@ QString QKeySequencePrivate::encodeString(int key, QKeySequence::SequenceFormat
     {
         // On other systems the order is Meta, Control, Alt, Shift
         if ((key & Qt::META) == Qt::META)
-            s = nativeText ? QShortcut::tr("Meta") : QString::fromLatin1("Meta");
+            s = nativeText ? QShortcut::tr("Meta", "Meta key, used for shortcuts") : QString::fromLatin1("Meta");
         if ((key & Qt::CTRL) == Qt::CTRL)
-            addKey(s, nativeText ? QShortcut::tr("Ctrl") : QString::fromLatin1("Ctrl"), format);
+            addKey(s, nativeText ? QShortcut::tr("Ctrl", "Ctrl key, used for shortcuts") : QString::fromLatin1("Ctrl"), format);
         if ((key & Qt::ALT) == Qt::ALT)
-            addKey(s, nativeText ? QShortcut::tr("Alt") : QString::fromLatin1("Alt"), format);
+            addKey(s, nativeText ? QShortcut::tr("Alt", "Alt key, used for shortcuts") : QString::fromLatin1("Alt"), format);
         if ((key & Qt::SHIFT) == Qt::SHIFT)
-            addKey(s, nativeText ? QShortcut::tr("Shift") : QString::fromLatin1("Shift"), format);
+            addKey(s, nativeText ? QShortcut::tr("Shift", "Shift key, used for shortcuts") : QString::fromLatin1("Shift"), format);
     }
 
 
@@ -1293,7 +1293,7 @@ QString QKeySequencePrivate::encodeString(int key, QKeySequence::SequenceFormat
             p += QChar((key-0x10000)%400+0xdc00);
         }
     } else if (key >= Qt::Key_F1 && key <= Qt::Key_F35) {
-            p = nativeText ? QShortcut::tr("F%1").arg(key - Qt::Key_F1 + 1)
+            p = nativeText ? QShortcut::tr("F%1", "Fx key, used for shortcuts").arg(key - Qt::Key_F1 + 1)
                            : QString::fromLatin1("F%1").arg(key - Qt::Key_F1 + 1);
     } else if (key) {
         int i=0;
diff --git a/src/gui/kernel/qt_mac.cpp b/src/gui/kernel/qt_mac.cpp
index 20f24ce..1d287e1 100644
--- a/src/gui/kernel/qt_mac.cpp
+++ b/src/gui/kernel/qt_mac.cpp
@@ -128,7 +128,7 @@ QColor qcolorForTheme(ThemeBrush brush)
 
 QColor qcolorForThemeTextColor(ThemeTextColor themeColor)
 {
-#ifdef Q_OS_MAC32
+#if defined(Q_OS_DARWIN32) || defined(Q_OS_MAC32)
     RGBColor c;
     GetThemeTextColor(themeColor, 32, true, &c);
     QColor color = QColor(c.red / 256, c.green / 256, c.blue / 256);
diff --git a/src/gui/kernel/qwidget_p.h b/src/gui/kernel/qwidget_p.h
index 7832393..18c331a 100644
--- a/src/gui/kernel/qwidget_p.h
+++ b/src/gui/kernel/qwidget_p.h
@@ -661,6 +661,7 @@ public:
     static QWidget *keyboardGrabber;
 
     void setWindowRole();
+    virtual void checkWindowRole();
     void sendStartupMessage(const char *message) const;
     void setNetWmWindowTypes();
     void x11UpdateIsOpaque();
diff --git a/src/gui/kernel/qwidget_x11.cpp b/src/gui/kernel/qwidget_x11.cpp
index 3135ece..5c997a4 100644
--- a/src/gui/kernel/qwidget_x11.cpp
+++ b/src/gui/kernel/qwidget_x11.cpp
@@ -763,6 +763,11 @@ void QWidgetPrivate::create_sys(WId window, bool initializeWindow, bool destroyO
         Q_ASSERT(id);
         XChangeWindowAttributes(dpy, id, CWOverrideRedirect | CWSaveUnder,
                                 &wsa);
+        XClassHint class_hint;
+        QByteArray appName = qAppName().toLatin1();
+        class_hint.res_name = appName.data(); // application name
+        class_hint.res_class = const_cast<char *>(QX11Info::appClass());   // application class
+        XSetWMProperties(dpy, id, 0, 0, 0, 0, 0, 0, &class_hint);
     } else if (topLevel && !desktop) {        // top-level widget
         if (!X11->wm_client_leader)
             create_wm_client_leader();
@@ -816,32 +821,40 @@ void QWidgetPrivate::create_sys(WId window, bool initializeWindow, bool destroyO
         // set EWMH window types
         setNetWmWindowTypes();
 
+        // when we create a toplevel widget, the frame strut should be dirty
+        data.fstrut_dirty = 1;
+
+    } else {
+        // non-toplevel widgets don't have a frame, so no need to
+        // update the strut
+        data.fstrut_dirty = 0;
+    }
+
+    if (initializeWindow && (popup || (topLevel && !desktop))) { // properties set on all toplevel windows
         // set _NET_WM_PID
         long curr_pid = getpid();
         XChangeProperty(dpy, id, ATOM(_NET_WM_PID), XA_CARDINAL, 32, PropModeReplace,
                         (unsigned char *) &curr_pid, 1);
 
-        // when we create a toplevel widget, the frame strut should be dirty
-        data.fstrut_dirty = 1;
 
         // declare the widget's window role
+        QByteArray windowRole;
         if (QTLWExtra *topData = maybeTopData()) {
-            if (!topData->role.isEmpty()) {
-                QByteArray windowRole = topData->role.toUtf8();
-                XChangeProperty(dpy, id,
-                                ATOM(WM_WINDOW_ROLE), XA_STRING, 8, PropModeReplace,
-                                (unsigned char *)windowRole.constData(), windowRole.length());
-            }
+            if (!topData->role.isEmpty())
+                windowRole = topData->role.toUtf8();
+        }
+        if (windowRole.isEmpty()) // use object name as a fallback
+            windowRole = objectName.toUtf8();
+        if (!windowRole.isEmpty()) {
+            XChangeProperty(dpy, id,
+                            ATOM(WM_WINDOW_ROLE), XA_STRING, 8, PropModeReplace,
+                            (unsigned char *)windowRole.constData(), windowRole.length());
         }
 
         // set client leader property
         XChangeProperty(dpy, id, ATOM(WM_CLIENT_LEADER),
                         XA_WINDOW, 32, PropModeReplace,
                         (unsigned char *)&X11->wm_client_leader, 1);
-    } else {
-        // non-toplevel widgets don't have a frame, so no need to
-        // update the strut
-        data.fstrut_dirty = 0;
     }
 
     if (initializeWindow && q->internalWinId()) {
@@ -2919,6 +2932,17 @@ void QWidgetPrivate::setWindowRole()
                     (unsigned char *)windowRole.constData(), windowRole.length());
 }
 
+void QWidgetPrivate::checkWindowRole()
+{
+    Q_Q(QWidget);
+    if( !q->windowRole().isEmpty() || !q->internalWinId())
+        return;
+    QByteArray windowRole = objectName.toUtf8(); // use as a fallback
+    XChangeProperty(X11->display, q->internalWinId(),
+                    ATOM(WM_WINDOW_ROLE), XA_STRING, 8, PropModeReplace,
+                    (unsigned char *)windowRole.constData(), windowRole.length());
+}
+
 Q_GLOBAL_STATIC(QX11PaintEngine, qt_widget_paintengine)
 QPaintEngine *QWidget::paintEngine() const
 {
diff --git a/src/gui/painting/qdrawhelper_p.h b/src/gui/painting/qdrawhelper_p.h
index 1968210..6737386 100644
--- a/src/gui/painting/qdrawhelper_p.h
+++ b/src/gui/painting/qdrawhelper_p.h
@@ -69,7 +69,7 @@
 
 // Disable MMX and SSE on Mac/PPC builds, or if the compiler
 // does not support -Xarch argument passing
-#if defined(QT_NO_MAC_XARCH) || (defined(Q_OS_DARWIN) && (defined(__ppc__) || defined(__ppc64__)))
+#if defined(QT_NO_MAC_XARCH) || ((defined(Q_OS_DARWIN) || defined(Q_OS_MAC)) && (defined(__ppc__) || defined(__ppc64__)))
 #undef QT_HAVE_SSE2
 #undef QT_HAVE_SSE
 #undef QT_HAVE_3DNOW
diff --git a/src/gui/widgets/qtabbar.cpp b/src/gui/widgets/qtabbar.cpp
index 30f6144..36dfe6d 100644
--- a/src/gui/widgets/qtabbar.cpp
+++ b/src/gui/widgets/qtabbar.cpp
@@ -678,8 +678,8 @@ void QTabBarPrivate::refresh()
         layoutTabs();
         makeVisible(currentIndex);
         q->update();
-        q->updateGeometry();
     }
+    q->updateGeometry();
 }
 
 /*!
diff --git a/src/network/kernel/qhostinfo_unix.cpp b/src/network/kernel/qhostinfo_unix.cpp
index 2a05f05..933f6bc 100644
--- a/src/network/kernel/qhostinfo_unix.cpp
+++ b/src/network/kernel/qhostinfo_unix.cpp
@@ -148,7 +148,7 @@ QHostInfo QHostInfoAgent::fromName(const QString &hostName)
     if (address.setAddress(hostName)) {
         // Reverse lookup
 // Reverse lookups using getnameinfo are broken on darwin, use gethostbyaddr instead.
-#if !defined (QT_NO_GETADDRINFO) && !defined (Q_OS_DARWIN) && !defined (Q_OS_SYMBIAN)
+#if !defined (QT_NO_GETADDRINFO) && !defined (Q_OS_DARWIN) && !defined (Q_OS_MAC) && !defined (Q_OS_SYMBIAN)
         sockaddr_in sa4;
 #ifndef QT_NO_IPV6
         sockaddr_in6 sa6;
diff --git a/src/network/ssl/qsslsocket_openssl_symbols.cpp b/src/network/ssl/qsslsocket_openssl_symbols.cpp
index 86b94fc..5b6cade 100644
--- a/src/network/ssl/qsslsocket_openssl_symbols.cpp
+++ b/src/network/ssl/qsslsocket_openssl_symbols.cpp
@@ -320,7 +320,7 @@ static bool libGreaterThan(const QString &lhs, const QString &rhs)
 static QStringList findAllLibSsl()
 {
     QStringList paths;
-#  ifdef Q_OS_DARWIN
+#  if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
     paths = QString::fromLatin1(qgetenv("DYLD_LIBRARY_PATH"))
             .split(QLatin1Char(':'), QString::SkipEmptyParts);
 #  else
diff --git a/src/phonon/phonon.pro b/src/phonon/phonon.pro
index 0469839..f62e958 100644
--- a/src/phonon/phonon.pro
+++ b/src/phonon/phonon.pro
@@ -3,7 +3,7 @@ include(../qbase.pri)
 
 PHONON_MAJOR_VERSION = $${QT_MAJOR_VERSION}
 PHONON_MINOR_VERSION = 3
-PHONON_PATCH_VERSION = 1
+PHONON_PATCH_VERSION = 80
 VERSION = $${PHONON_MAJOR_VERSION}.$${PHONON_MINOR_VERSION}.$${PHONON_PATCH_VERSION}
 
 DEPENDPATH += .
@@ -21,6 +21,9 @@ HEADERS += $$PHONON_DIR/abstractaudiooutput.h \
            $$PHONON_DIR/abstractvideooutput.h \
            $$PHONON_DIR/abstractvideooutput_p.h \
            $$PHONON_DIR/addoninterface.h \
+           $$PHONON_DIR/audiodataoutput.h \
+           $$PHONON_DIR/audiodataoutput_p.h \
+           $$PHONON_DIR/audiodataoutputinterface.h \
            $$PHONON_DIR/audiooutput.h \
            $$PHONON_DIR/audiooutput_p.h \
            $$PHONON_DIR/audiooutputinterface.h \
@@ -36,6 +39,7 @@ HEADERS += $$PHONON_DIR/abstractaudiooutput.h \
            $$PHONON_DIR/effectwidget_p.h \
            $$PHONON_DIR/factory_p.h \
            $$PHONON_DIR/frontendinterface_p.h \
+           $$PHONON_DIR/globalconfig.h \
            $$PHONON_DIR/globalconfig_p.h \
            $$PHONON_DIR/iodevicestream_p.h \
            $$PHONON_DIR/mediacontroller.h \
@@ -59,11 +63,13 @@ HEADERS += $$PHONON_DIR/abstractaudiooutput.h \
            $$PHONON_DIR/phononnamespace_p.h \
            $$PHONON_DIR/platform_p.h \
            $$PHONON_DIR/platformplugin.h \
+           $$PHONON_DIR/pulsesupport.h \
            $$PHONON_DIR/qsettingsgroup_p.h \
            $$PHONON_DIR/seekslider.h \
            $$PHONON_DIR/seekslider_p.h \
            $$PHONON_DIR/streaminterface.h \
            $$PHONON_DIR/streaminterface_p.h \
+           $$PHONON_DIR/swiftslider_p.h \
            $$PHONON_DIR/videoplayer.h \
            $$PHONON_DIR/videowidget.h \
            $$PHONON_DIR/videowidget_p.h \
@@ -73,35 +79,39 @@ HEADERS += $$PHONON_DIR/abstractaudiooutput.h \
            $$PHONON_DIR/volumefaderinterface.h \
            $$PHONON_DIR/volumeslider.h \
            $$PHONON_DIR/volumeslider_p.h
-SOURCES += $$PHONON_DIR/objectdescription.cpp \
-           $$PHONON_DIR/objectdescriptionmodel.cpp \
-           $$PHONON_DIR/phononnamespace.cpp \
-           $$PHONON_DIR/mediasource.cpp \
-           $$PHONON_DIR/abstractmediastream.cpp \
-           $$PHONON_DIR/streaminterface.cpp \
-           $$PHONON_DIR/mediaobject.cpp \
-           $$PHONON_DIR/medianode.cpp \
-           $$PHONON_DIR/path.cpp \
-           $$PHONON_DIR/effectparameter.cpp \
-           $$PHONON_DIR/effect.cpp \
-           $$PHONON_DIR/volumefadereffect.cpp \
-           $$PHONON_DIR/abstractaudiooutput.cpp \
+
+SOURCES += $$PHONON_DIR/abstractaudiooutput.cpp \
            $$PHONON_DIR/abstractaudiooutput_p.cpp \
-           $$PHONON_DIR/audiooutput.cpp \
-           $$PHONON_DIR/audiooutputinterface.cpp \
+           $$PHONON_DIR/abstractmediastream.cpp \
            $$PHONON_DIR/abstractvideooutput.cpp \
            $$PHONON_DIR/abstractvideooutput_p.cpp \
+           $$PHONON_DIR/audiodataoutput.cpp \
+           $$PHONON_DIR/audiooutput.cpp \
+           $$PHONON_DIR/audiooutputinterface.cpp \
            $$PHONON_DIR/backendcapabilities.cpp \
-           $$PHONON_DIR/globalconfig.cpp \
+           $$PHONON_DIR/effect.cpp \
+           $$PHONON_DIR/effectparameter.cpp \
+           $$PHONON_DIR/effectwidget.cpp \
            $$PHONON_DIR/factory.cpp \
-           $$PHONON_DIR/platform.cpp \
+           $$PHONON_DIR/globalconfig.cpp \
+           $$PHONON_DIR/iodevicestream.cpp \
            $$PHONON_DIR/mediacontroller.cpp \
-           $$PHONON_DIR/videowidget.cpp \
-           $$PHONON_DIR/videoplayer.cpp \
+           $$PHONON_DIR/medianode.cpp \
+           $$PHONON_DIR/mediaobject.cpp \
+           $$PHONON_DIR/mediasource.cpp \
+           $$PHONON_DIR/objectdescription.cpp \
+           $$PHONON_DIR/objectdescriptionmodel.cpp \
+           $$PHONON_DIR/path.cpp \
+           $$PHONON_DIR/phononnamespace.cpp \
+           $$PHONON_DIR/platform.cpp \
+           $$PHONON_DIR/pulsesupport.cpp \
            $$PHONON_DIR/seekslider.cpp \
-           $$PHONON_DIR/volumeslider.cpp \
-           $$PHONON_DIR/effectwidget.cpp \
-           $$PHONON_DIR/iodevicestream.cpp
+           $$PHONON_DIR/streaminterface.cpp \
+           $$PHONON_DIR/swiftslider.cpp \
+           $$PHONON_DIR/videoplayer.cpp \
+           $$PHONON_DIR/videowidget.cpp \
+           $$PHONON_DIR/volumefadereffect.cpp \
+           $$PHONON_DIR/volumeslider.cpp
 
 contains(QT_CONFIG, dbus) {
        QT      += dbus
diff --git a/src/qt3support/other/q3process_unix.cpp b/src/qt3support/other/q3process_unix.cpp
index 88cb73a..dde8a2a 100644
--- a/src/qt3support/other/q3process_unix.cpp
+++ b/src/qt3support/other/q3process_unix.cpp
@@ -790,7 +790,7 @@ bool Q3Process::start( QStringList *env )
 	} else { // start process with environment settins as specified in env
 	    // construct the environment for exec
 	    int numEntries = env->count();
-#if defined(Q_OS_MACX)
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 	    QString ld_library_path(QLatin1String("DYLD_LIBRARY_PATH"));
 #else
 	    QString ld_library_path(QLatin1String("LD_LIBRARY_PATH"));
@@ -832,7 +832,7 @@ bool Q3Process::start( QStringList *env )
 			QFileInfo fileInfo( dir + QLatin1Char('/') + command );
 #endif
 			if ( fileInfo.isExecutable() ) {
-#if defined(Q_OS_MACX)
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
 			    arglistQ[0] = fileInfo.absFilePath().local8Bit();
 #else
 			    arglistQ[0] = fileInfo.filePath().local8Bit();
diff --git a/src/qt3support/qt3support.pro b/src/qt3support/qt3support.pro
index a30117c..c2e718b 100644
--- a/src/qt3support/qt3support.pro
+++ b/src/qt3support/qt3support.pro
@@ -26,6 +26,7 @@ unix {
    QMAKE_PKGCONFIG_REQUIRES = QtCore QtGui QtNetwork QtSql
 }
 mac:LIBS_PRIVATE += -framework Carbon
+darwin-*:LIBS += -lresolv
 
 QMAKE_LIBS += $$QMAKE_LIBS_COMPAT $$QMAKE_LIBS_NETWORK
 DEFINES -= QT3_SUPPORT_WARNINGS
diff --git a/src/qt3support/text/q3textedit.cpp b/src/qt3support/text/q3textedit.cpp
index 0d0e1a2..6887cec 100644
--- a/src/qt3support/text/q3textedit.cpp
+++ b/src/qt3support/text/q3textedit.cpp
@@ -4981,7 +4981,7 @@ void Q3TextEdit::pasteSubType(const QByteArray& subtype, QMimeSource *m)
 #if defined(Q_OS_WIN32)
         // Need to convert CRLF to LF
         t.replace(QLatin1String("\r\n"), QLatin1String("\n"));
-#elif defined(Q_OS_MAC)
+#elif defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
         //need to convert CR to LF
         t.replace(QLatin1Char('\r'), QLatin1Char('\n'));
 #endif
diff --git a/src/sql/drivers/odbc/qsql_odbc.h b/src/sql/drivers/odbc/qsql_odbc.h
index 76627b8..4daf4d3 100644
--- a/src/sql/drivers/odbc/qsql_odbc.h
+++ b/src/sql/drivers/odbc/qsql_odbc.h
@@ -49,7 +49,7 @@
 #include <QtCore/qt_windows.h>
 #endif
 
-#if defined (Q_OS_MAC) && (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_3)
+#if (defined (Q_OS_DARWIN) || defined (Q_OS_MAC)) && (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_3)
 // assume we use iodbc on MACX
 // comment next line out if you use a
 // unicode compatible manager
diff --git a/src/testlib/qbenchmark_p.h b/src/testlib/qbenchmark_p.h
index e981646..d59a071 100644
--- a/src/testlib/qbenchmark_p.h
+++ b/src/testlib/qbenchmark_p.h
@@ -55,7 +55,7 @@
 
 #include <QtCore/qglobal.h>
 
-#if (defined(Q_OS_LINUX) || defined Q_OS_MAC) && !defined(QT_NO_PROCESS)
+#if (defined(Q_OS_LINUX) || defined (Q_OS_DARWIN) || defined(Q_OS_MAC)) && !defined(QT_NO_PROCESS)
 #define QTESTLIB_USE_VALGRIND 
 #else
 #undef QTESTLIB_USE_VALGRIND
diff --git a/src/tools/moc/main.cpp b/src/tools/moc/main.cpp
index 8e033b7..b5b2edd 100644
--- a/src/tools/moc/main.cpp
+++ b/src/tools/moc/main.cpp
@@ -94,7 +94,13 @@ static QByteArray combinePath(const char *infile, const char *outfile)
         inSplitted.prepend(QLatin1String(".."));
     }
     inSplitted.append(inFileInfo.fileName());
+#ifdef Q_WS_WIN
+    const QString rel = inSplitted.join(QLatin1String("/"));
+    const QString abs = inFileInfo.absoluteFilePath();
+    return QFile::encodeName(rel.length() < abs.length() ? rel : abs);
+#else
     return QFile::encodeName(inSplitted.join(QLatin1String("/")));
+#endif
 }
 
 
diff --git a/tools/assistant/lib/fulltextsearch/qclucene-config_p.h b/tools/assistant/lib/fulltextsearch/qclucene-config_p.h
index ffa5f5d..3a20995 100644
--- a/tools/assistant/lib/fulltextsearch/qclucene-config_p.h
+++ b/tools/assistant/lib/fulltextsearch/qclucene-config_p.h
@@ -354,7 +354,7 @@ configure.
 #endif
 
 #if !defined(__SUNPRO_CC) && !defined(__SUNPRO_C) && !defined(__MINGW32__) && \
-    !defined(Q_OS_MAC) && !defined(__HP_aCC)
+    !defined(Q_OS_DARWIN) && !defined(Q_OS_MAC) && !defined(__HP_aCC)
     /* Define to 1 if you have the `wcscasecmp' function. */
 #   ifndef _CL_HAVE_WCSCASECMP
 #   define _CL_HAVE_WCSCASECMP  1
diff --git a/tools/designer/src/plugins/plugins.pro b/tools/designer/src/plugins/plugins.pro
index baf5261..9f3a4ce 100644
--- a/tools/designer/src/plugins/plugins.pro
+++ b/tools/designer/src/plugins/plugins.pro
@@ -1,5 +1,7 @@
 TEMPLATE = subdirs
 CONFIG += ordered
+CONFIG -= lib_bundle
+QT_CONFIG -= qt_framework
 
 REQUIRES = !CONFIG(static,shared|static)
 contains(QT_CONFIG, qt3support): SUBDIRS += widgets
